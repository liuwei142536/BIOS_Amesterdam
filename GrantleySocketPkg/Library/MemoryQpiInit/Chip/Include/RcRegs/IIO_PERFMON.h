/* Date Stamp: 8/23/2014 */

#ifndef IIO_PERFMON_h
#define IIO_PERFMON_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* IIO_PERFMON_DEV 5                                                          */
/* IIO_PERFMON_FUN 6                                                          */

/* VID_IIO_PERFMON_REG supported on:                                          */
/*       IVT_EP (0x2002E000)                                                  */
/*       IVT_EX (0x2002E000)                                                  */
/*       HSX (0x2002E000)                                                     */
/*       BDX (0x2002E000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_PERFMON_REG 0x09062000
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* DID_IIO_PERFMON_REG supported on:                                          */
/*       IVT_EP (0x2002E002)                                                  */
/*       IVT_EX (0x2002E002)                                                  */
/*       HSX (0x2002E002)                                                     */
/*       BDX (0x2002E002)                                                     */
/* Register default value on IVT_EP:    0x0E39                                */
/* Register default value on IVT_EX:    0x0E39                                */
/* Register default value on HSX:       0x2F39                                */
/* Register default value on BDX:       0x6F39                                */
#define DID_IIO_PERFMON_REG 0x09062002
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'b0110111100111001 
       Device ID values vary from function to function. Bits 15:8 are equal to 0x6F for 
       the processor. The following list is a breakdown of the function groups. 
       0x6F00 - 0x6F1F : PCI Express and DMI ports
       0x6F20 - 0x6F3F : IO Features (Intel QuickData Technology, APIC, VT, RAS, Intel 
       TXT) 
       0x6F40 - 0x6F5F : Performance Monitors
       0x6F60 - 0x6F7F : DFX
       0x6F80 - 0x6F9F : Intel QPI
       0x6FA0 - 0x6FBF : Home Agent/Memory Controller
       0x6FC0 - 0x6FDF : Power Management
       0x6FE0 - 0x6FFF : Cbo/Ring
       
       Default value may vary based on bus, device, and function of this CSR location.
     */
  } Bits;
  UINT16 Data;
} DID_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PCICMD_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x2002E004)                                                  */
/*       IVT_EX (0x2002E004)                                                  */
/*       HSX (0x2002E004)                                                     */
/*       BDX (0x2002E004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_PERFMON_REG 0x09062004
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x004
 */
typedef union {
  struct {
    UINT16 io_space_enable : 1;
    /* io_space_enable - Bits[0:0], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any IO BARs
     */
    UINT16 memory_space_enable : 1;
    /* memory_space_enable - Bits[1:1], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any memory BARs
     */
    UINT16 bus_master_enable : 1;
    /* bus_master_enable - Bits[2:2], RO, default = 1'b0 
       Hardwired to 0 since these devices don't generate any transactions
     */
    UINT16 special_cycle_enable : 1;
    /* special_cycle_enable - Bits[3:3], RO, default = 1'b0 
       Not applicable. Hardwired to 0.
     */
    UINT16 memory_write_and_invalidate_enable : 1;
    /* memory_write_and_invalidate_enable - Bits[4:4], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 parity_error_response : 1;
    /* parity_error_response - Bits[6:6], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 serr_enable : 1;
    /* serr_enable - Bits[8:8], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0
     */
    UINT16 intx_disable : 1;
    /* intx_disable - Bits[10:10], RO, default = 1'b0 
       N/A for these devices
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PCISTS_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x2002E006)                                                  */
/*       IVT_EX (0x2002E006)                                                  */
/*       HSX (0x2002E006)                                                     */
/*       BDX (0x2002E006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_PERFMON_REG 0x09062006
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x006
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure
     */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 master_data_parity_error : 1;
    /* master_data_parity_error - Bits[8:8], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 signaled_target_abort : 1;
    /* signaled_target_abort - Bits[11:11], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_target_abort : 1;
    /* received_target_abort - Bits[12:12], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_master_abort : 1;
    /* received_master_abort - Bits[13:13], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 signaled_system_error : 1;
    /* signaled_system_error - Bits[14:14], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 detected_parity_error : 1;
    /* detected_parity_error - Bits[15:15], RO, default = 1'b0 
       This bit is set when the device receives a packet on the primary side with an 
       uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
       R2PCIe will never set this bit. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* RID_IIO_PERFMON_REG supported on:                                          */
/*       IVT_EP (0x1002E008)                                                  */
/*       IVT_EX (0x1002E008)                                                  */
/*       HSX (0x1002E008)                                                     */
/*       BDX (0x1002E008)                                                     */
/* Register default value:              0x00                                  */
#define RID_IIO_PERFMON_REG 0x09061008
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * "PCIe header Revision ID register"
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], ROS_V, default = 8'b00000000 
       Reflects the Uncore Revision ID after reset.
       Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID 
       register in the processor uncore. 
       
     */
  } Bits;
  UINT8 Data;
} RID_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* CCR_N0_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x1002E009)                                                  */
/*       IVT_EX (0x1002E009)                                                  */
/*       HSX (0x1002E009)                                                     */
/*       BDX (0x1002E009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_PERFMON_REG 0x09061009


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.6.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT8 register_level_programming_interface : 8;
    /* register_level_programming_interface - Bits[7:0], RO_V, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} CCR_N0_IIO_PERFMON_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* CCR_N1_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x2002E00A)                                                  */
/*       IVT_EX (0x2002E00A)                                                  */
/*       HSX (0x2002E00A)                                                     */
/*       BDX (0x2002E00A)                                                     */
/* Register default value:              0x1101                                */
#define CCR_N1_IIO_PERFMON_REG 0x0906200A
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO_V, default = 8'b00000001 
       The value changes dependent upon the dev/func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h80 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h01. 
                 dev-0x0 through 0x7 (return 0x4, d0f0 return 0x0 under default 
       settings) 
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO_V, default = 8'b00010001 
       The value changes dependent upon the dev-func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h08 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h11. 
                 dev-0x0 through 0x7 (return 0x6)
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
  } Bits;
  UINT16 Data;
} CCR_N1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* CLSR_IIO_PERFMON_REG supported on:                                         */
/*       IVT_EP (0x1002E00C)                                                  */
/*       IVT_EX (0x1002E00C)                                                  */
/*       HSX (0x1002E00C)                                                     */
/*       BDX (0x1002E00C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_PERFMON_REG 0x0906100C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only. Cacheline size for 
       processor is always 64B. 
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* HDR_IIO_PERFMON_REG supported on:                                          */
/*       IVT_EP (0x1002E00E)                                                  */
/*       IVT_EX (0x1002E00E)                                                  */
/*       HSX (0x1002E00E)                                                     */
/*       BDX (0x1002E00E)                                                     */
/* Register default value:              0x80                                  */
#define HDR_IIO_PERFMON_REG 0x0906100E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x00e
 */
typedef union {
  struct {
    UINT8 configuration_layout : 7;
    /* configuration_layout - Bits[6:0], RO, default = 7'b0000000 
       This field identifies the format of the configuration header layout. It is Type 
       0 for all these devices. The default is 00h, indicating a 'endpoint device'. 
     */
    UINT8 multi_function_device : 1;
    /* multi_function_device - Bits[7:7], RO, default = 1'b1 
       This bit defaults to 1b since all these devices are multi-function
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* SVID_IIO_PERFMON_REG supported on:                                         */
/*       IVT_EP (0x2002E02C)                                                  */
/*       IVT_EX (0x2002E02C)                                                  */
/*       HSX (0x2002E02C)                                                     */
/*       BDX (0x2002E02C)                                                     */
/* Register default value:              0x0000                                */
#define SVID_IIO_PERFMON_REG 0x0906202C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_identification_number : 16;
    /* subsystem_vendor_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       The default value specifies Intel but can be set to any value once after reset.
     */
  } Bits;
  UINT16 Data;
} SVID_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* SDID_IIO_PERFMON_REG supported on:                                         */
/*       IVT_EP (0x2002E02E)                                                  */
/*       IVT_EX (0x2002E02E)                                                  */
/*       HSX (0x2002E02E)                                                     */
/*       BDX (0x2002E02E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_PERFMON_REG 0x0906202E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_identification_number : 16;
    /* subsystem_device_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       Assigned by the subsystem vendor to uniquely identify the subsystem
     */
  } Bits;
  UINT16 Data;
} SDID_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* CAPPTR_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x1002E034)                                                  */
/*       IVT_EX (0x1002E034)                                                  */
/*       HSX (0x1002E034)                                                     */
/*       BDX (0x1002E034)                                                     */
/* Register default value:              0x40                                  */
#define CAPPTR_IIO_PERFMON_REG 0x09061034
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'b01000000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* INTL_IIO_PERFMON_REG supported on:                                         */
/*       IVT_EP (0x1002E03C)                                                  */
/*       IVT_EX (0x1002E03C)                                                  */
/*       HSX (0x1002E03C)                                                     */
/*       BDX (0x1002E03C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_PERFMON_REG 0x0906103C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* INTPIN_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x1002E03D)                                                  */
/*       IVT_EX (0x1002E03D)                                                  */
/*       HSX (0x1002E03D)                                                     */
/*       BDX (0x1002E03D)                                                     */
/* Register default value:              0x00                                  */
#define INTPIN_IIO_PERFMON_REG 0x0906103D
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x03d
 */
typedef union {
  struct {
    UINT8 interrupt_pin : 8;
    /* interrupt_pin - Bits[7:0], RO, default = 8'b00000000 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* MINGNT_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x1002E03E)                                                  */
/*       IVT_EX (0x1002E03E)                                                  */
/*       HSX (0x1002E03E)                                                     */
/*       BDX (0x1002E03E)                                                     */
/* Register default value:              0x00                                  */
#define MINGNT_IIO_PERFMON_REG 0x0906103E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x03e
 */
typedef union {
  struct {
    UINT8 mgv : 8;
    /* mgv - Bits[7:0], RO, default = 8'b00000000 
       The Device does not burst as a PCI compliant master.
     */
  } Bits;
  UINT8 Data;
} MINGNT_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* MAXLAT_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x1002E03F)                                                  */
/*       IVT_EX (0x1002E03F)                                                  */
/*       HSX (0x1002E03F)                                                     */
/*       BDX (0x1002E03F)                                                     */
/* Register default value:              0x00                                  */
#define MAXLAT_IIO_PERFMON_REG 0x0906103F
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x03f
 */
typedef union {
  struct {
    UINT8 mlv : 8;
    /* mlv - Bits[7:0], RO, default = 8'b00000000 
       The Device has no specific requirements for how often it needs to access the PCI 
       bus. 
     */
  } Bits;
  UINT8 Data;
} MAXLAT_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PXPCAPID_IIO_PERFMON_REG supported on:                                     */
/*       IVT_EP (0x1002E040)                                                  */
/*       IVT_EX (0x1002E040)                                                  */
/*       HSX (0x1002E040)                                                     */
/*       BDX (0x1002E040)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_PERFMON_REG 0x09061040
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x040
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PXPNXTPTR_IIO_PERFMON_REG supported on:                                    */
/*       IVT_EP (0x1002E041)                                                  */
/*       IVT_EX (0x1002E041)                                                  */
/*       HSX (0x1002E041)                                                     */
/*       BDX (0x1002E041)                                                     */
/* Register default value:              0x00                                  */
#define PXPNXTPTR_IIO_PERFMON_REG 0x09061041
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x041
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b00000000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PXPCAP_IIO_PERFMON_REG supported on:                                       */
/*       IVT_EP (0x2002E042)                                                  */
/*       IVT_EX (0x2002E042)                                                  */
/*       HSX (0x2002E042)                                                     */
/*       BDX (0x2002E042)                                                     */
/* Register default value:              0x0092                                */
#define PXPCAP_IIO_PERFMON_REG 0x09062042
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x042
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RO, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure. Set 
       to 2h for PCI Express and DMA devices for compliance with the extended base 
       registers. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO, default = 4'b1001 
       This field identifies the type of device. It is set to for the DMA to indicate 
       root complex integrated endpoint device. 
     */
    UINT16 slot_implemented_n_a : 1;
    /* slot_implemented_n_a - Bits[8:8], RO, default = 1'b0  */
    UINT16 interrupt_message_number_n_a : 5;
    /* interrupt_message_number_n_a - Bits[13:9], RO, default = 5'b00000  */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP_PMONFILTER_N0_IIO_PERFMON_REG supported on:                            */
/*       IVT_EP (0x4002E080)                                                  */
/*       IVT_EX (0x4002E080)                                                  */
/*       HSX (0x4002E080)                                                     */
/*       BDX (0x4002E080)                                                     */
/* Register default value:              0x00000000                            */
#define IRP_PMONFILTER_N0_IIO_PERFMON_REG 0x09064080
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * Special filtering controls for IRP perfmons
 */
typedef union {
  struct {
    UINT32 orderingq : 5;
    /* orderingq - Bits[4:0], RW, default = 5'b00000 
       Select a specific source ordering queue to monitor. Certain events allow us to 
       filter based on a given source. For example, we can count the number of reads 
       out of a given source, or the number of outstanding writes in the write cache 
       for a given source. This is to be used in conjunction with the "ORDERING_QUEUE" 
       filter selection for events that support it. Only a single ordering queue filter 
       can be setup at a given time, and this is used across the two IRPs and for all 
       the counters. 
     */
    UINT32 rsvd : 27;
    /* rsvd - Bits[31:5], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IRP_PMONFILTER_N0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */




/* IRP0_PMONCNTR_0_N0_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0A0)                                                  */
/*       IVT_EX (0x4002E0A0)                                                  */
/*       HSX (0x4002E0A0)                                                     */
/*       BDX (0x4002E0A0)                                                     */
/* Register default value:              0x00000000                            */
#define IRP0_PMONCNTR_0_N0_IIO_PERFMON_REG 0x090640A0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 32;
    /* countervalue - Bits[31:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} IRP0_PMONCNTR_0_N0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP0_PMONCNTR_0_N1_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0A4)                                                  */
/*       IVT_EX (0x4002E0A4)                                                  */
/*       HSX (0x4002E0A4)                                                     */
/*       BDX (0x4002E0A4)                                                     */
/* Register default value:              0x00000000                            */
#define IRP0_PMONCNTR_0_N1_IIO_PERFMON_REG 0x090640A4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 16;
    /* countervalue - Bits[15:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IRP0_PMONCNTR_0_N1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP0_PMONCNTR_1_N0_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0B0)                                                  */
/*       IVT_EX (0x4002E0B0)                                                  */
/*       HSX (0x4002E0A8)                                                     */
/*       BDX (0x4002E0A8)                                                     */
/* Register default value:              0x00000000                            */
#define IRP0_PMONCNTR_1_N0_IIO_PERFMON_REG 0x0906C000
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 32;
    /* countervalue - Bits[31:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} IRP0_PMONCNTR_1_N0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP0_PMONCNTR_1_N1_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0B4)                                                  */
/*       IVT_EX (0x4002E0B4)                                                  */
/*       HSX (0x4002E0AC)                                                     */
/*       BDX (0x4002E0AC)                                                     */
/* Register default value:              0x00000000                            */
#define IRP0_PMONCNTR_1_N1_IIO_PERFMON_REG 0x0906C001
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 16;
    /* countervalue - Bits[15:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IRP0_PMONCNTR_1_N1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP1_PMONCNTR_0_N0_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0B8)                                                  */
/*       IVT_EX (0x4002E0B8)                                                  */
/*       HSX (0x4002E0B0)                                                     */
/*       BDX (0x4002E0B0)                                                     */
/* Register default value:              0x00000000                            */
#define IRP1_PMONCNTR_0_N0_IIO_PERFMON_REG 0x0906C002
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 32;
    /* countervalue - Bits[31:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} IRP1_PMONCNTR_0_N0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP1_PMONCNTR_0_N1_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0BC)                                                  */
/*       IVT_EX (0x4002E0BC)                                                  */
/*       HSX (0x4002E0B4)                                                     */
/*       BDX (0x4002E0B4)                                                     */
/* Register default value:              0x00000000                            */
#define IRP1_PMONCNTR_0_N1_IIO_PERFMON_REG 0x0906C003
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 16;
    /* countervalue - Bits[15:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IRP1_PMONCNTR_0_N1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP1_PMONCNTR_1_N0_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0C0)                                                  */
/*       IVT_EX (0x4002E0C0)                                                  */
/*       HSX (0x4002E0B8)                                                     */
/*       BDX (0x4002E0B8)                                                     */
/* Register default value:              0x00000000                            */
#define IRP1_PMONCNTR_1_N0_IIO_PERFMON_REG 0x0906C004
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 32;
    /* countervalue - Bits[31:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} IRP1_PMONCNTR_1_N0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP1_PMONCNTR_1_N1_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0C4)                                                  */
/*       IVT_EX (0x4002E0C4)                                                  */
/*       HSX (0x4002E0BC)                                                     */
/*       BDX (0x4002E0BC)                                                     */
/* Register default value:              0x00000000                            */
#define IRP1_PMONCNTR_1_N1_IIO_PERFMON_REG 0x0906C005
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This register is a perfmon counter.  Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 countervalue : 16;
    /* countervalue - Bits[15:0], RW_V, default = 48'b000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IRP1_PMONCNTR_1_N1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP0_PMONCNTRCFG_0_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0D8)                                                  */
/*       IVT_EX (0x4002E0D8)                                                  */
/*       HSX (0x4002E0D8)                                                     */
/*       BDX (0x4002E0D8)                                                     */
/* Register default value:              0x00000000                            */
#define IRP0_PMONCNTRCFG_0_IIO_PERFMON_REG 0x090640D8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * Perfmon Counter Control Register
 */
typedef union {
  struct {
    UINT32 eventselect : 8;
    /* eventselect - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       individual unit performance monitoring documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       =event -1 bit 8 must be set to 1 in this case. 
     */
    UINT32 queueoccupancyreset : 1;
    /* queueoccupancyreset - Bits[16:16], WO, default = 1'b0 
       This write only bit causes the queue occupancy counter of the PerfMon counter 
       for which this Perf event select register is associated to be cleared to all 
       zeroes when a \q1\q is written to it. No action is taken when a \q0\q is 
       written. Note: Since the queue occupancy counters never drop below zero, it is 
       possible for the counters to 'catch up' with the real occupancy of the queue in 
       question when the real occupancy drop to zero. 
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedetect : 1;
    /* edgedetect - Bits[18:18], RW_V, default = 1'b0 
       Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given 
       event. For example, we have an event that counts the number of cycles in L1 mode 
       in Intel QPI. By using edge detect, one can count the number of times that we 
       entered L1 mode (by detecting the rising edge). 
       
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
       
       Edge detect can also be used with the invert. This is generally not particularly 
       useful, as the count of falling edges compared to rising edges will always on 
       differ by 1. 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 overflowenable : 1;
    /* overflowenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 rsvd_21 : 1;
    UINT32 counterenable : 1;
    /* counterenable - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold &lt; event. The invert bit only works when 
       Threshhold != 0. So, if one would like to invert a non-occupancy event (like LLC 
       Hit), one needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} IRP0_PMONCNTRCFG_0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP0_PMONCNTRCFG_1_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0DC)                                                  */
/*       IVT_EX (0x4002E0DC)                                                  */
/*       HSX (0x4002E0DC)                                                     */
/*       BDX (0x4002E0DC)                                                     */
/* Register default value:              0x00000000                            */
#define IRP0_PMONCNTRCFG_1_IIO_PERFMON_REG 0x090640DC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * Perfmon Counter Control Register
 */
typedef union {
  struct {
    UINT32 eventselect : 8;
    /* eventselect - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       individual unit performance monitoring documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       =event -1 bit 8 must be set to 1 in this case. 
     */
    UINT32 queueoccupancyreset : 1;
    /* queueoccupancyreset - Bits[16:16], WO, default = 1'b0 
       This write only bit causes the queue occupancy counter of the PerfMon counter 
       for which this Perf event select register is associated to be cleared to all 
       zeroes when a \q1\q is written to it. No action is taken when a \q0\q is 
       written. Note: Since the queue occupancy counters never drop below zero, it is 
       possible for the counters to 'catch up' with the real occupancy of the queue in 
       question when the real occupancy drop to zero. 
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedetect : 1;
    /* edgedetect - Bits[18:18], RW_V, default = 1'b0 
       Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given 
       event. For example, we have an event that counts the number of cycles in L1 mode 
       in Intel QPI. By using edge detect, one can count the number of times that we 
       entered L1 mode (by detecting the rising edge). 
       
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
       
       Edge detect can also be used with the invert. This is generally not particularly 
       useful, as the count of falling edges compared to rising edges will always on 
       differ by 1. 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 overflowenable : 1;
    /* overflowenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 rsvd_21 : 1;
    UINT32 counterenable : 1;
    /* counterenable - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold &lt; event. The invert bit only works when 
       Threshhold != 0. So, if one would like to invert a non-occupancy event (like LLC 
       Hit), one needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} IRP0_PMONCNTRCFG_1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP1_PMONCNTRCFG_0_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0E0)                                                  */
/*       IVT_EX (0x4002E0E0)                                                  */
/*       HSX (0x4002E0E0)                                                     */
/*       BDX (0x4002E0E0)                                                     */
/* Register default value:              0x00000000                            */
#define IRP1_PMONCNTRCFG_0_IIO_PERFMON_REG 0x090640E0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * Perfmon Counter Control Register
 */
typedef union {
  struct {
    UINT32 eventselect : 8;
    /* eventselect - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       individual unit performance monitoring documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       =event -1 bit 8 must be set to 1 in this case. 
     */
    UINT32 queueoccupancyreset : 1;
    /* queueoccupancyreset - Bits[16:16], WO, default = 1'b0 
       This write only bit causes the queue occupancy counter of the PerfMon counter 
       for which this Perf event select register is associated to be cleared to all 
       zeroes when a \q1\q is written to it. No action is taken when a \q0\q is 
       written. Note: Since the queue occupancy counters never drop below zero, it is 
       possible for the counters to 'catch up' with the real occupancy of the queue in 
       question when the real occupancy drop to zero. 
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedetect : 1;
    /* edgedetect - Bits[18:18], RW_V, default = 1'b0 
       Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given 
       event. For example, we have an event that counts the number of cycles in L1 mode 
       in Intel QPI. By using edge detect, one can count the number of times that we 
       entered L1 mode (by detecting the rising edge). 
       
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
       
       Edge detect can also be used with the invert. This is generally not particularly 
       useful, as the count of falling edges compared to rising edges will always on 
       differ by 1. 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 overflowenable : 1;
    /* overflowenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 rsvd_21 : 1;
    UINT32 counterenable : 1;
    /* counterenable - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold &lt; event. The invert bit only works when 
       Threshhold != 0. So, if one would like to invert a non-occupancy event (like LLC 
       Hit), one needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} IRP1_PMONCNTRCFG_0_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP1_PMONCNTRCFG_1_IIO_PERFMON_REG supported on:                           */
/*       IVT_EP (0x4002E0E4)                                                  */
/*       IVT_EX (0x4002E0E4)                                                  */
/*       HSX (0x4002E0E4)                                                     */
/*       BDX (0x4002E0E4)                                                     */
/* Register default value:              0x00000000                            */
#define IRP1_PMONCNTRCFG_1_IIO_PERFMON_REG 0x090640E4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * Perfmon Counter Control Register
 */
typedef union {
  struct {
    UINT32 eventselect : 8;
    /* eventselect - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       individual unit performance monitoring documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       =event -1 bit 8 must be set to 1 in this case. 
     */
    UINT32 queueoccupancyreset : 1;
    /* queueoccupancyreset - Bits[16:16], WO, default = 1'b0 
       This write only bit causes the queue occupancy counter of the PerfMon counter 
       for which this Perf event select register is associated to be cleared to all 
       zeroes when a \q1\q is written to it. No action is taken when a \q0\q is 
       written. Note: Since the queue occupancy counters never drop below zero, it is 
       possible for the counters to 'catch up' with the real occupancy of the queue in 
       question when the real occupancy drop to zero. 
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedetect : 1;
    /* edgedetect - Bits[18:18], RW_V, default = 1'b0 
       Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given 
       event. For example, we have an event that counts the number of cycles in L1 mode 
       in Intel QPI. By using edge detect, one can count the number of times that we 
       entered L1 mode (by detecting the rising edge). 
       
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
       
       Edge detect can also be used with the invert. This is generally not particularly 
       useful, as the count of falling edges compared to rising edges will always on 
       differ by 1. 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 overflowenable : 1;
    /* overflowenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 rsvd_21 : 1;
    UINT32 counterenable : 1;
    /* counterenable - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold &lt; event. The invert bit only works when 
       Threshhold != 0. So, if one would like to invert a non-occupancy event (like LLC 
       Hit), one needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} IRP1_PMONCNTRCFG_1_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP_PMONUNITCTRL_IIO_PERFMON_REG supported on:                             */
/*       IVT_EP (0x4002E0F4)                                                  */
/*       IVT_EX (0x4002E0F4)                                                  */
/*       HSX (0x4002E0F0)                                                     */
/*       BDX (0x4002E0F0)                                                     */
/* Register default value on IVT_EP:    0x00000000                            */
/* Register default value on IVT_EX:    0x00000000                            */
/* Register default value on HSX:       0x00030000                            */
/* Register default value on BDX:       0x00030000                            */
#define IRP_PMONUNITCTRL_IIO_PERFMON_REG 0x0906C006
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * generated by critter 05_6_0x0f0
 */
typedef union {
  struct {
    UINT32 resetcounterconfigs : 1;
    /* resetcounterconfigs - Bits[0:0], WO, default = 1'b0 
       When this bit is written to, the counter configuration registers will be reset. 
       This does not effect the values in the counters. 
     */
    UINT32 resetcounters : 1;
    /* resetcounters - Bits[1:1], WO, default = 1'b0 
       When this bit is written to, the counters data fields will be reset. The 
       configuration values will not be reset. 
     */
    UINT32 rsvd_2 : 6;
    /* rsvd_2 - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 freezecounters : 1;
    /* freezecounters - Bits[8:8], RW, default = 1'b0 
       This bit is written to when the counters should be frozen. If this bit is 
       written to and freeze is enabled, the counters in the unit will stop counting. 
     */
    UINT32 rsvd_9 : 7;
    /* rsvd_9 - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 freezeenable : 1;
    /* freezeenable - Bits[16:16], RO, default = 1'b1 
       This bit controls what the counters in the unit will do when they receive a 
       freeze signal. When set, the counters will be allowed to freeze. When not set, 
       the counters will ignore the freeze signal. 
     */
    UINT32 overflowenable : 1;
    /* overflowenable - Bits[17:17], RO, default = 1'b1 
       This bit controls the behavior of counters when they overflow. When set, the 
       system will trigger the overflow handling process throughout the rest of the 
       uncore, potentially triggering a PMI and freezing counters. When it is not set, 
       the counters will simply wrap around and continue to count. 
     */
    UINT32 ptosel : 1;
    /* ptosel - Bits[18:18], RW, default = 1'b0 
       1
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IRP_PMONUNITCTRL_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* IRP0_PMONUNITSTATUS_IIO_PERFMON_REG supported on:                          */
/*       HSX (0x1002E0F4)                                                     */
/*       BDX (0x1002E0F4)                                                     */
/* Register default value:              0x00                                  */
#define IRP0_PMONUNITSTATUS_IIO_PERFMON_REG 0x090610F4

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This field shows which registers have overflowed in the unit.
 * Whenever a register overflows, it should set the relevant bit to 1.  An overflow 
 * should not effect the other status bits.  This status should only be cleared by 
 * software. 
 * We have defined 7 bits for this status.  This is overkill for many units.  See 
 * below for the bits that are used in the different units. 
 * In general, if the unit has a fixed counter, it will use bit 0.  Counter 0 would 
 * use the next LSB, and the largest counter would use the MSB. 
 * HA: [4:0] w/ [4] = Counter4 and [0] = Counter 0
 * IMC: [5:0] w/ [0] = Fixed; [1] = Counter0 and [5] = Counter4
 * Intel QPI: [4:0] (same as HA)
 * PCU: [3:0]: [0] = Counter0 and [3] = Counter 3
 * IO IRP0: [0] = Counter0; [1] = Counter1
 * IO IRP1: [2] = Counter0; [3] = Counter1
 */
typedef union {
  struct {
    UINT8 counteroverflowbitmask : 7;
    /* counteroverflowbitmask - Bits[6:0], RW1C, default = 7'b0000000 
       This is a bitmask that specifies which counter (or counters) have overflowed. If 
       the unit has a fixed counter, it's corresponding bitmask will be stored at 
       position 0. 
     */
    UINT8 rsvd : 1;
    /* rsvd - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} IRP0_PMONUNITSTATUS_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* IRP1_PMONUNITSTATUS_IIO_PERFMON_REG supported on:                          */
/*       HSX (0x1002E0FC)                                                     */
/*       BDX (0x1002E0FC)                                                     */
/* Register default value:              0x00                                  */
#define IRP1_PMONUNITSTATUS_IIO_PERFMON_REG 0x090610FC

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This field shows which registers have overflowed in the unit.
 * Whenever a register overflows, it should set the relevant bit to 1.  An overflow 
 * should not effect the other status bits.  This status should only be cleared by 
 * software. 
 * We have defined 7 bits for this status.  This is overkill for many units.  See 
 * below for the bits that are used in the different units. 
 * In general, if the unit has a fixed counter, it will use bit 0.  Counter 0 would 
 * use the next LSB, and the largest counter would use the MSB. 
 * HA: [4:0] w/ [4] = Counter4 and [0] = Counter 0
 * IMC: [5:0] w/ [0] = Fixed; [1] = Counter0 and [5] = Counter4
 * Intel QPI: [4:0] (same as HA)
 * PCU: [3:0]: [0] = Counter0 and [3] = Counter 3
 * IO IRP0: [0] = Counter0; [1] = Counter1
 * IO IRP1: [2] = Counter0; [3] = Counter1
 */
typedef union {
  struct {
    UINT8 counteroverflowbitmask : 7;
    /* counteroverflowbitmask - Bits[6:0], RW1C, default = 7'b0000000 
       This is a bitmask that specifies which counter (or counters) have overflowed. If 
       the unit has a fixed counter, it's corresponding bitmask will be stored at 
       position 0. 
     */
    UINT8 rsvd : 1;
    /* rsvd - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} IRP1_PMONUNITSTATUS_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* PXPENHCAP_IIO_PERFMON_REG supported on:                                    */
/*       IVT_EP (0x4002E100)                                                  */
/*       IVT_EX (0x4002E100)                                                  */
/*       HSX (0x4002E100)                                                     */
/*       BDX (0x4002E100)                                                     */
/* Register default value:              0x00000000                            */
#define PXPENHCAP_IIO_PERFMON_REG 0x09064100
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * This field points to the next Capability in extended configuration space.
 */
typedef union {
  struct {
    UINT32 capability_id : 16;
    /* capability_id - Bits[15:0], RO, default = 16'b0000000000000000 
       Indicates there are no capability structures in the enhanced configuration 
       space. 
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0000 
       Indicates there are no capability structures in the enhanced configuration 
       space. 
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} PXPENHCAP_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PERFSTAT_IIO_PERFMON_REG supported on:                                     */
/*       IVT_EP (0x4002E104)                                                  */
/*       IVT_EX (0x4002E104)                                                  */
/*       HSX (0x4002E104)                                                     */
/*       BDX (0x4002E104)                                                     */
/* Register default value:              0x00000000                            */
#define PERFSTAT_IIO_PERFMON_REG 0x09064104
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * The PERFSTAT register is a global register used to indicate the performance 
 * monitor event status.  Count status bits are cleared by writing a one to the bit 
 * location. 
 * 
 * Note: The counter output status bits are cleared by writing a 1 to them. 
 * However, these bits cannot be cleared if the counters PM_stat bit is still set. 
 * If a counters PM_stat output is still set, the PMxSTAT bit in this register will 
 * still be set after writing a 1 to it. Counter PM_stat bits, if set, must be 
 * cleared using the PMR register for the counter or GRST. 
 */
typedef union {
  struct {
    UINT32 xp0mp0stat : 1;
    /* xp0mp0stat - Bits[0:0], RW1C, default = 1'b0 
       PCIe Port PM Status: PM0 IOU2 (DMI/x8) Perfmon Status
     */
    UINT32 xp0mp1stat : 1;
    /* xp0mp1stat - Bits[1:1], RW1C, default = 1'b0 
       PCIe Port PM Status: PM1 IOU2 (DMI/x8) Perfmon Status
     */
    UINT32 rsvd_2 : 2;
    /* rsvd_2 - Bits[3:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 xp3mp0stat : 1;
    /* xp3mp0stat - Bits[4:4], RW1C, default = 1'b0 
       PCIe Port PM Status: PM0 IOU0 (x16) Perfmon Status
     */
    UINT32 xp3mp1stat : 1;
    /* xp3mp1stat - Bits[5:5], RW1C, default = 1'b0 
       PCIe Port PM Status: PM1 IOU0 (x16) Perfmon Status
     */
    UINT32 xp7mp0stat : 1;
    /* xp7mp0stat - Bits[6:6], RW1C, default = 1'b0 
       PCIe Port PM Status: PM0 IOU1 (x16) Perfmon Status
     */
    UINT32 xp7mp1stat : 1;
    /* xp7mp1stat - Bits[7:7], RW1C, default = 1'b0 
       PCIe Port PM Status: PM1 IOU1 (x16) Perfmon Status
     */
    UINT32 rsvd_8 : 4;
    /* rsvd_8 - Bits[11:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_12 : 1;
    UINT32 tswpm1stat : 1;
    /* tswpm1stat - Bits[13:13], RW1C, default = 1'b0 
       Switch PM1 Status:
       Switch PM1 either overflowed or had a compare match.
     */
    UINT32 vtdpm0stat : 1;
    /* vtdpm0stat - Bits[14:14], RW1C, default = 1'b0 
       VTd PM0 Status:
       VTd PM0 either overflowed or had a compare match
       
       
     */
    UINT32 vtdpm1stat : 1;
    /* vtdpm1stat - Bits[15:15], RW1C, default = 1'b0 
       VTd PM1 Status:
       VTd PM1 either overflowed or had a compare match
       
       
     */
    UINT32 rsvd_16 : 16;
    /* rsvd_16 - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFSTAT_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */


/* PERFCON_IIO_PERFMON_REG supported on:                                      */
/*       IVT_EP (0x4002E108)                                                  */
/*       IVT_EX (0x4002E108)                                                  */
/*       HSX (0x4002E108)                                                     */
/*       BDX (0x4002E108)                                                     */
/* Register default value:              0x00000000                            */
#define PERFCON_IIO_PERFMON_REG 0x09064108
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.6.CFG.xml.
 * The PERFCON register is a global register used to clear all of the counters.
 */
typedef union {
  struct {
    UINT32 grst : 1;
    /* grst - Bits[0:0], RW, default = 1'b0 
       Setting this bit to a logic 1 will reset the following bit fields in all PerfMon 
       blocks 
       throughout the component.
       xxxPMDx.CNT,
       xxxPMR.OVS,
       xxxPMR.CMPSTAT,
       xxxPMCx.PMCx registers,
       and count mode state latch selected by xxxPMR.CNTMD = 01.
       Where xxx is the cluster prefix name.
       
       Note: Software must clear this bit after setting it, otherwise the PerfMons
       remain in a reset state.
     */
    UINT32 gce : 1;
    /* gce - Bits[1:1], RW, default = 1'b0 
       This bit is AND'ed with the PMR.CENS mux enable selection.
       0: Disable all counters.
       1: Enable local selection of CENS.
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCON_IIO_PERFMON_STRUCT;
#endif /* ASM_INC */
























/* TSWPMER1_IIO_PERFMON_REG supported on:                                     */
/*       IVT_EP (0x4002E230)                                                  */
/*       IVT_EX (0x4002E230)                                                  */
/*       HSX (0x4002E230)                                                     */
/*       BDX (0x4002E230)                                                     */
/* Register default value:              0x00000000                            */
#define TSWPMER1_IIO_PERFMON_REG 0x09064230


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.6.CFG.xml.
 * This register is used to select bus related resource and utilization events, 
 * (i.e., to count number of clocks the selected signal is active) or queue event 
 * measurements. Use of this event register is mutually exclusive with other event 
 * registers. Each of these bit selections are independent from any other event in 
 * this register. The queue events are completely separate from all other event 
 * types and are not matched using the event pre-conditioning logic. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000 
       Queue Measurement Bus Select: This field selects a queue to monitor. These 
       queues are connected the QueueMeasBus that is derived from the difference in the 
       write and read pointers. 
       000000: No queues selected
       000001: XP0 Outbound VC1 CPLH
       000010: XP0 Outbound VCP CPLH
       000011: XP0 Outbound VC0 PRH
       000100: XP0 Outbound VC0 NPRH
       000101: XP0 Outbound VC0 CPLH
       000110: XP0 Outbound VCM CPLH
       000111: XP1 Outbound PRH
       001000: XP1 Outbound NPRH
       001001: XP1 Outbound CPLH
       001010: XP2 Outbound PRH
       001011: XP2 Outbound NPRH
       001100: XP2 Outbound CPLH
       001101: XP3 Outbound PRH
       001110: XP3 Outbound NPRH
       001111: XP3 Outbound CPLH
       010000: XP4 Outbound PRH
       010001: XP4 Outbound NPRH
       010010: XP4 Outbound CPLH
       010011: XP5 Outbound PRH
       010100: XP5 Outbound NPRH
       010101: XP5 Outbound CPLH
       010110: XP6 Outbound PRH
       010111: XP6 Outbound NPRH
       011000: XP6 Outbound CPLH
       011001: XP7 Outbound PRH
       011010: XP7 Outbound NPRH
       011011: XP7 Outbound CPLH
       011100: XP8 Outbound PRH
       011101: XP8 Outbound NPRH
       011110: XP8 Outbound CPLH
       011111: XP9 Outbound PRH
       100000: XP9 Outbound NPRH
       100001: XP9 Outbound CPLH
       100010: XP10 Outbound PRH
       100011: XP10 Outbound NPRH
       100100: XP10 Outbound CPLH
       others: reserved
     */
    UINT32 rsvd_6 : 2;
    /* rsvd_6 - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pshpopqsel : 4;
    /* pshpopqsel - Bits[11:8], RO, default = 4'b0000 
       Push/Pop Queue Select (TBD)
       0000: No queue selected
       0001: TBD
       0010 - 1111: Reserved
     */
    UINT32 qtypesel : 1;
    /* qtypesel - Bits[12:12], RO, default = 1'b0 
       Queue Type Select
       0: Queue Measurement Bus. Use QBUSSEL to select a queue that has a read-write 
       pointer output that connects to the QueueMeasBus. 
       1: FIFO Push/Pop type of queues. Use PSHPOPQSEL to select a FIFO. To enable this 
       type of queue measurement set CNTMD = '11'. 
       Note: The FIFO queue type is unsupported and the bit field was changed from a RW 
       to a RO to re-enforce this. 
     */
    UINT32 rsvd_13 : 19;
    /* rsvd_13 - Bits[31:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TSWPMER1_IIO_PERFMON_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */
































/* IRP_PMONUNITSTATUS0_IIO_PERFMON_REG supported on:                          */
/*       IVT_EP (0x1002E0F8)                                                  */
/*       IVT_EX (0x1002E0F8)                                                  */
/* Register default value:              0x00                                  */
#define IRP_PMONUNITSTATUS0_IIO_PERFMON_REG 0x090610F8



/* IRP_PMONUNITSTATUS1_IIO_PERFMON_REG supported on:                          */
/*       IVT_EP (0x1002E0F9)                                                  */
/*       IVT_EX (0x1002E0F9)                                                  */
/* Register default value:              0x00                                  */
#define IRP_PMONUNITSTATUS1_IIO_PERFMON_REG 0x090610F9



/* DBG_MUX_CTRL_SO_IIO_PERFMON_REG supported on:                              */
/*       IVT_EP (0x1002E5EF)                                                  */
/*       IVT_EX (0x1002E5EF)                                                  */
/* Register default value:              0x00                                  */
#define DBG_MUX_CTRL_SO_IIO_PERFMON_REG 0x090615EF



#endif /* IIO_PERFMON_h */
