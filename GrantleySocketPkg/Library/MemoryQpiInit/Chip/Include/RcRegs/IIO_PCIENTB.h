/* Date Stamp: 8/23/2014 */

#ifndef IIO_PCIENTB_h
#define IIO_PCIENTB_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* IIO_PCIENTB_DEV 3                                                          */
/* IIO_PCIENTB_FUN 0                                                          */

/* VID_IIO_PCIENTB_REG supported on:                                          */
/*       IVT_EP (0x20018000)                                                  */
/*       IVT_EX (0x20018000)                                                  */
/*       HSX (0x20018000)                                                     */
/*       BDX (0x20018000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_PCIENTB_REG 0x10002000
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* DID_IIO_PCIENTB_REG supported on:                                          */
/*       IVT_EP (0x20018002)                                                  */
/*       IVT_EX (0x20018002)                                                  */
/*       HSX (0x20018002)                                                     */
/*       BDX (0x20018002)                                                     */
/* Register default value on IVT_EP:    0x0E08                                */
/* Register default value on IVT_EX:    0x0E08                                */
/* Register default value on HSX:       0x2F08                                */
/* Register default value on BDX:       0x6F08                                */
#define DID_IIO_PCIENTB_REG 0x10002002
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO_V, default = 16'b0110111100001000 
       Device ID values vary from function to function. Bits 15:8 are equal to 0x6F for 
       the processor. The following list is a breakdown of the function groups. 
       0x6F00 - 0x6F1F : PCI Express and DMI ports
       0x6F20 - 0x6F3F : IO Features (Intel QuickData Technology, APIC, VT, RAS, Intel 
       TXT) 
       0x6F40 - 0x6F5F : Performance Monitors
       0x6F60 - 0x6F7F : DFX
       0x6F80 - 0x6F9F : Intel QPI
       0x6FA0 - 0x6FBF : Home Agent/Memory Controller
       0x6FC0 - 0x6FDF : Power Management
       0x6FE0 - 0x6FFF : Cbo/Ring
       
       Hardware sets this field based on the operating mode of this dev/fn:
       PCIe => 0x6F08
       NTB-NTB => 0x6F0D
       NTB-RP => 0x6F0E
       Default value may vary based on bus, device, and function of this CSR location.
     */
  } Bits;
  UINT16 Data;
} DID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PCICMD_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018004)                                                  */
/*       IVT_EX (0x20018004)                                                  */
/*       HSX (0x20018004)                                                     */
/*       BDX (0x20018004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_PCIENTB_REG 0x10002004
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x004
 */
typedef union {
  struct {
    UINT16 iose : 1;
    /* iose - Bits[0:0], RW_L, default = 1'b0 
       1: Enables the I/O address range, defined in the IOBASE and IOLIM registers of 
       the PCI-to-PCI bridge header, for target decode from primary side. 
       0: Disables the I/O address range, defined in the IOBASE and IOLIM registers of 
       the PCI-to-PCI bridge header, for target decode from primary side. 
       
       Notes:
       Note this bit is not ever used by hardware to decode transactions from the 
       secondary side of the root port. 
       This bit is hardwired to 0 in DMI Mode, since the DMI is not a P2P bridge and 
       does not claim any IO resource on its own. Hardware should not use this bit to 
       determine if it can forward memory requests to DMI while in DMI Mode. 
       NTB does not support I/O space accesses. Hardwired to 0.
     */
    UINT16 mse : 1;
    /* mse - Bits[1:1], RW, default = 1'b0 
       1
     */
    UINT16 bme : 1;
    /* bme - Bits[2:2], RW, default = 1'b0 
       Bus Master Enable
       Controls the ability of the PCI Express port in generating and also in 
       forwarding memory (including MSI writes) or I/O transactions (and not messages) 
       or configuration transactions from the secondary side to the primary side. 
       1: Enables the PCI Express port to a) generate MSI writes internally for 
       AER/HP/PM events (note: there are several other RP MSI related control/enable 
       bits. See the RAS Chapter and PCI Express Base Specification, Revision 2.0 for 
       complete details) and also to b) forward memory (including MSI writes from 
       devices south of the RP), config or I/O read/write requests from secondary to 
       primary side 
       0: The Bus Master is disabled. When this bit is 0, IIO root ports will a) treat 
       upstream PCI Express memory writes/reads, IO writes/reads, and configuration 
       reads and writes as unsupported requests (and follow the rules for handling 
       unsupported requests). This behavior is also true towards transactions that are 
       already pending in the IIO root port's internal queues when the BME bit is 
       turned off. b) mask the root port from generating MSI writes internally for 
       AER/HP/PM events at the root port. 
     */
    UINT16 sce : 1;
    /* sce - Bits[3:3], RO, default = 1'b0 
       Special Cycle Enable
       Not applicable to DMI/PCI Express devices. Hardwired to 0.
     */
    UINT16 mwie : 1;
    /* mwie - Bits[4:4], RO, default = 1'b0 
       Memory Write and Invalidate Enable
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 perre : 1;
    /* perre - Bits[6:6], RW, default = 1'b0 
       Parity Error Reporting Enable
       For PCI Express ports, IIO ignores this bit and always does parity checking and 
       signaling for data/address of transactions both to and from root port. This bit 
       though affects the setting of bit 8 in the PCISTS register. 
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 serre : 1;
    /* serre - Bits[8:8], RW, default = 1'b0 
       SERR Reporting Enable
       For PCI Express ports, this field enables notifying the internal IIO core error 
       logic of occurrence of an uncorrectable error (fatal or non-fatal) at the port. 
       The internal core error logic of IIO then decides if/how to escalate the error 
       further (pins/message etc.). Note this bit also controls the propagation of PCI 
       Express ERR_FATAL and ERR_NONFATAL messages received from the port to the 
       internal IIO core error logic. 
       1: Fatal and Non-fatal error message generation and Fatal and Non-fatal error 
       message forwarding is enabled 
       0: Fatal and Non-fatal error message generation and Fatal and Non-fatal error 
       message forwarding is disabled 
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0.
     */
    UINT16 interrupt_disable : 1;
    /* interrupt_disable - Bits[10:10], RW, default = 1'b0 
       1
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PCISTS_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018006)                                                  */
/*       IVT_EX (0x20018006)                                                  */
/*       HSX (0x20018006)                                                     */
/*       BDX (0x20018006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_PCIENTB_REG 0x10002006
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCI Status
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO_V, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure.
     */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0 
       Master Data Parity Error
       This bit is set by a root port if the Parity Error Response bit in the PCI 
       Command register is set and it either receives a completion with poisoned data 
       from the primary side or it forwards a packet with data (including MSI writes) 
       to the primary side with poison. 
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0 
       Signalled Target Abort
       This bit is set when a root port signals a completer abort completion status on 
       the primary side (internal bus of uncore). This condition includes a PCI Express 
       port forwarding a completer abort status received on a completion from the 
       secondary 
     */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0 
       Received Target Abort
       This bit is set when a device experiences a completer abort condition on a 
       transaction it mastered on the primary interface (uncore internal bus). Note 
       that certain errors might be detected right at the PCI Express interface and 
       those transactions might not 'propagate' to the primary interface before the 
       error is detected (e.g. accesses to memory above VTBAR). Such errors do not 
       cause this bit to be set, and are reported via the PCI Express interface error 
       bits (secondary status register). 
       Conditions that cause bit 12 to be set, include:
       - Device receives a completion on the primary interface (internal bus of uncore) 
       with completer abort completion Status. This includes CA status received on the 
       primary side of a PCI Express port on peer-to-peer completions also. 
       - Other completer abort conditions detected on the uncore internal bus.
     */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0 
       Received Master Abort
       This bit is set when a root port experiences a master abort condition on a 
       transaction it mastered on the primary interface (uncore internal bus). 
       Note that certain errors might be detected right at the PCI Express interface 
       and those transactions might not 'propagate' to the primary interface before the 
       error is detected (e.g. accesses to memory above TOCM in cases where the PCIE 
       interface logic itself might have visibility into TOCM). Such errors do not 
       cause this bit to be set, and are reported via the PCI Express interface error 
       bits (secondary status register). 
       Conditions that cause bit 13 to be set, include:
       - Device receives a completion on the primary interface (internal bus of uncore) 
       with Unsupported Request or master abort completion Status. This includes UR 
       status received on the primary side of a PCI Express port on peer-to-peer 
       completions also. 
       - Other master abort conditions detected on the IIO internal bus amongst those 
       listed in the Chapter 5, 'Inbound Address Decoding,' chapter. 
     */
    UINT16 sse : 1;
    /* sse - Bits[14:14], RW1C, default = 1'b0 
       Signalled System Error
       1: The root port reported fatal/non-fatal (and not correctable) errors it 
       detected on its PCI Express (or DMI) interface to the IIO core error logic 
       (which might eventually escalate the error through the ERR[2:0] pins or message 
       to cpu core or message to PCH). Note that the SERRE bit in the PCICMD register 
       must be set for a device to report the error the IIO core error logic.Software 
       clears this bit by writing a '1' to it. This bit is also set (when SERR enable 
       bit is set) when a FATAL/NON-FATAL message is forwarded to the IIO core error 
       logic. Note that IIO internal 'core' errors (like parity error in the internal 
       queues) are not reported via this bit. 
       0: The root port did not report a fatal/non-fatal error
     */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0 
       Detected Parity Error
       This bit is set by a root port when it receives a packet on the primary side 
       with an uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* CLSR_IIO_PCIENTB_REG supported on:                                         */
/*       IVT_EP (0x1001800C)                                                  */
/*       IVT_EX (0x1001800C)                                                  */
/*       HSX (0x1001800C)                                                     */
/*       BDX (0x1001800C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_PCIENTB_REG 0x1000100C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only.
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PLAT_IIO_PCIENTB_REG supported on:                                         */
/*       IVT_EP (0x1001800D)                                                  */
/*       IVT_EX (0x1001800D)                                                  */
/*       HSX (0x1001800D)                                                     */
/*       BDX (0x1001800D)                                                     */
/* Register default value:              0x00                                  */
#define PLAT_IIO_PCIENTB_REG 0x1000100D
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x00d
 */
typedef union {
  struct {
    UINT8 primary_latency_timer : 8;
    /* primary_latency_timer - Bits[7:0], RO, default = 8'b00000000 
       Not applicable to PCI-Express. Hardwired to 00h.
     */
  } Bits;
  UINT8 Data;
} PLAT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* HDR_IIO_PCIENTB_REG supported on:                                          */
/*       IVT_EP (0x1001800E)                                                  */
/*       IVT_EX (0x1001800E)                                                  */
/*       HSX (0x1001800E)                                                     */
/*       BDX (0x1001800E)                                                     */
/* Register default value:              0x81                                  */
#define HDR_IIO_PCIENTB_REG 0x1000100E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x00e
 */
typedef union {
  struct {
    UINT8 cl : 7;
    /* cl - Bits[6:0], RO_V, default = 7'b0000001 
       This field identifies the format of the configuration header layout. It is Type1 
       for PCI Express and Type0 in NTB mode. The default is 01h for PCIe, indicating a 
       'PCI to PCI Bridge', and 00h for NTB, indicating a 'non-bridge function'. 
     */
    UINT8 mfd : 1;
    /* mfd - Bits[7:7], RO_V, default = 1'b1 
       This bit defaults to 0 for PCI Express NTB port.
       BIOS can individually control the value of this bit, based on HDRTYPCTRL 
       register. BIOS will write to that register to change this field to 0, if it 
       exposes only function 0 in the device to OS. 
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* BIST_IIO_PCIENTB_REG supported on:                                         */
/*       IVT_EP (0x1001800F)                                                  */
/*       IVT_EX (0x1001800F)                                                  */
/*       HSX (0x1001800F)                                                     */
/*       BDX (0x1001800F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_IIO_PCIENTB_REG 0x1000100F
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x00f
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} BIST_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PB01BASE_0_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018010)                                                  */
/*       IVT_EX (0x40018010)                                                  */
/*       HSX (0x40018010)                                                     */
/*       BDX (0x40018010)                                                     */
/* Register default value:              0x0000000C                            */
#define PB01BASE_0_IIO_PCIENTB_REG 0x10004010
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x010
 */
typedef union {
  struct {
    UINT32 memory_space_indicator : 1;
    /* memory_space_indicator - Bits[0:0], RO, default = 1'b0  */
    UINT32 type : 2;
    /* type - Bits[2:1], RO, default = 2'b10  */
    UINT32 prefetchable : 1;
    /* prefetchable - Bits[3:3], RO, default = 1'b1  */
    UINT32 rsvd : 12;
    /* rsvd - Bits[15:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 primary_bar_0_1_base : 16;
    /* primary_bar_0_1_base - Bits[31:16], RW, default = 16'b0000000000000000  */
  } Bits;
  UINT32 Data;
} PB01BASE_0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PB01BASE_1_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018014)                                                  */
/*       IVT_EX (0x40018014)                                                  */
/*       HSX (0x40018014)                                                     */
/*       BDX (0x40018014)                                                     */
/* Register default value:              0x00000000                            */
#define PB01BASE_1_IIO_PCIENTB_REG 0x10004014
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x014
 */
typedef union {
  struct {
    UINT32 primary_bar_0_1_base : 32;
    /* primary_bar_0_1_base - Bits[31:0], RW, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} PB01BASE_1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PB23BASE_0_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018018)                                                  */
/*       IVT_EX (0x40018018)                                                  */
/*       HSX (0x40018018)                                                     */
/*       BDX (0x40018018)                                                     */
/* Register default value:              0x0000000C                            */
#define PB23BASE_0_IIO_PCIENTB_REG 0x10004018
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x018
 */
typedef union {
  struct {
    UINT32 memory_space_indicator : 1;
    /* memory_space_indicator - Bits[0:0], RO, default = 1'b0  */
    UINT32 type : 2;
    /* type - Bits[2:1], RO, default = 2'b10  */
    UINT32 prefetchable : 1;
    /* prefetchable - Bits[3:3], RO, default = 1'b1  */
    UINT32 rsvd : 8;
    /* rsvd - Bits[11:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 primary_bar_2_3_base : 20;
    /* primary_bar_2_3_base - Bits[31:12], RW, default = 20'b00000000000000000000  */
  } Bits;
  UINT32 Data;
} PB23BASE_0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PB23BASE_1_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x4001801C)                                                  */
/*       IVT_EX (0x4001801C)                                                  */
/*       HSX (0x4001801C)                                                     */
/*       BDX (0x4001801C)                                                     */
/* Register default value:              0x00000000                            */
#define PB23BASE_1_IIO_PCIENTB_REG 0x1000401C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x01c
 */
typedef union {
  struct {
    UINT32 primary_bar_2_3_base : 32;
    /* primary_bar_2_3_base - Bits[31:0], RW, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} PB23BASE_1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PB45BASE_0_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018020)                                                  */
/*       IVT_EX (0x40018020)                                                  */
/*       HSX (0x40018020)                                                     */
/*       BDX (0x40018020)                                                     */
/* Register default value:              0x0000000C                            */
#define PB45BASE_0_IIO_PCIENTB_REG 0x10004020
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x020
 */
typedef union {
  struct {
    UINT32 memory_space_indicator : 1;
    /* memory_space_indicator - Bits[0:0], RO, default = 1'b0  */
    UINT32 type : 2;
    /* type - Bits[2:1], RO, default = 2'b10  */
    UINT32 prefetchable : 1;
    /* prefetchable - Bits[3:3], RO, default = 1'b1  */
    UINT32 rsvd : 8;
    /* rsvd - Bits[11:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 primary_bar_4_5_base : 20;
    /* primary_bar_4_5_base - Bits[31:12], RW, default = 20'b00000000000000000000  */
  } Bits;
  UINT32 Data;
} PB45BASE_0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PB45BASE_1_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018024)                                                  */
/*       IVT_EX (0x40018024)                                                  */
/*       HSX (0x40018024)                                                     */
/*       BDX (0x40018024)                                                     */
/* Register default value:              0x00000000                            */
#define PB45BASE_1_IIO_PCIENTB_REG 0x10004024
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x024
 */
typedef union {
  struct {
    UINT32 primary_bar_4_5_base : 32;
    /* primary_bar_4_5_base - Bits[31:0], RW, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} PB45BASE_1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SVID_IIO_PCIENTB_REG supported on:                                         */
/*       IVT_EP (0x2001802C)                                                  */
/*       IVT_EX (0x2001802C)                                                  */
/*       HSX (0x2001802C)                                                     */
/*       BDX (0x2001802C)                                                     */
/* Register default value:              0x8086                                */
#define SVID_IIO_PCIENTB_REG 0x1000202C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_id : 16;
    /* subsystem_vendor_id - Bits[15:0], RW_O, default = 16'b1000000010000110  */
  } Bits;
  UINT16 Data;
} SVID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SDID_IIO_PCIENTB_REG supported on:                                         */
/*       IVT_EP (0x2001802E)                                                  */
/*       IVT_EX (0x2001802E)                                                  */
/*       HSX (0x2001802E)                                                     */
/*       BDX (0x2001802E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_PCIENTB_REG 0x1000202E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_id : 16;
    /* subsystem_device_id - Bits[15:0], RW_O, default = 16'b0000000000000000  */
  } Bits;
  UINT16 Data;
} SDID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* CAPPTR_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x10018034)                                                  */
/*       IVT_EX (0x10018034)                                                  */
/*       HSX (0x10018034)                                                     */
/*       BDX (0x10018034)                                                     */
/* Register default value:              0x60                                  */
#define CAPPTR_IIO_PCIENTB_REG 0x10001034
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RW_O, default = 8'b01100000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* INTL_IIO_PCIENTB_REG supported on:                                         */
/*       IVT_EP (0x1001803C)                                                  */
/*       IVT_EX (0x1001803C)                                                  */
/*       HSX (0x1001803C)                                                     */
/*       BDX (0x1001803C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_PCIENTB_REG 0x1000103C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RW, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* INTPIN_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x1001803D)                                                  */
/*       IVT_EX (0x1001803D)                                                  */
/*       HSX (0x1001803D)                                                     */
/*       BDX (0x1001803D)                                                     */
/* Register default value:              0x01                                  */
#define INTPIN_IIO_PCIENTB_REG 0x1000103D
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x03d
 */
typedef union {
  struct {
    UINT8 intp : 8;
    /* intp - Bits[7:0], RW_O, default = 8'b00000001 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MINGNT_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x1001803E)                                                  */
/*       IVT_EX (0x1001803E)                                                  */
/*       HSX (0x1001803E)                                                     */
/*       BDX (0x1001803E)                                                     */
/* Register default value:              0x00                                  */
#define MINGNT_IIO_PCIENTB_REG 0x1000103E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x03e
 */
typedef union {
  struct {
    UINT8 minimum_grant : 8;
    /* minimum_grant - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} MINGNT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MAXLAT_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x1001803F)                                                  */
/*       IVT_EX (0x1001803F)                                                  */
/*       HSX (0x1001803F)                                                     */
/*       BDX (0x1001803F)                                                     */
/* Register default value:              0x00                                  */
#define MAXLAT_IIO_PCIENTB_REG 0x1000103F
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x03f
 */
typedef union {
  struct {
    UINT8 maximum_latency : 8;
    /* maximum_latency - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} MAXLAT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSICAPID_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x10018060)                                                  */
/*       IVT_EX (0x10018060)                                                  */
/*       HSX (0x10018060)                                                     */
/*       BDX (0x10018060)                                                     */
/* Register default value:              0x05                                  */
#define MSICAPID_IIO_PCIENTB_REG 0x10001060
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x060
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000101 
       Assigned by PCI-SIG for MSI (root ports).
     */
  } Bits;
  UINT8 Data;
} MSICAPID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSINXTPTR_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x10018061)                                                  */
/*       IVT_EX (0x10018061)                                                  */
/*       HSX (0x10018061)                                                     */
/*       BDX (0x10018061)                                                     */
/* Register default value:              0x90                                  */
#define MSINXTPTR_IIO_PCIENTB_REG 0x10001061
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x061
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RW_O, default = 8'b10010000 
       This field is set to 90h for the next capability list (PCI Express capability 
       structure) in the chain. 
     */
  } Bits;
  UINT8 Data;
} MSINXTPTR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSIMSGCTL_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x20018062)                                                  */
/*       IVT_EX (0x20018062)                                                  */
/*       HSX (0x20018062)                                                     */
/*       BDX (0x20018062)                                                     */
/* Register default value:              0x0102                                */
#define MSIMSGCTL_IIO_PCIENTB_REG 0x10002062
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x062
 */
typedef union {
  struct {
    UINT16 msien : 1;
    /* msien - Bits[0:0], RW, default = 1'b0 
       Software sets this bit to select INTx style interrupt or MSI interrupt for root 
       port generated interrupts. 
       
       0: INTx interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       1: MSI interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       Note there bits 4:2 and bit 2 MISCCTRLSTS can disable both MSI and INTx 
       interrupt from being generated on root port interrupt events. 
     */
    UINT16 mmc : 3;
    /* mmc - Bits[3:1], RO, default = 3'b001 
       Multiple Message Capable
       IIO Root Ports support two messages for all their internal events.
     */
    UINT16 mme : 3;
    /* mme - Bits[6:4], RW, default = 3'b000 
       Applicable only to PCI Express ports. Software writes to this field to indicate 
       the number of allocated messages which is aligned to a power of two. When MSI is 
       enabled, the software will allocate at least one message to the device. A value 
       of 000 indicates 1 message. Any value greater than or equal to 001 indicates a 
       message of 2. 
       
       See MSIDR for discussion on how the interrupts are distributed amongst the 
       various sources of interrupt based on the number of messages allocated by 
       software for the PCI Express ports. 
     */
    UINT16 b64ac : 1;
    /* b64ac - Bits[7:7], RO, default = 1'b0 
       This field is hardwired to 0h since the message addresses are only 32-bit 
       addresses (e.g. FEEx_xxxxh). 
     */
    UINT16 pvmc : 1;
    /* pvmc - Bits[8:8], RO, default = 1'b1 
       This bit indicates that PCI Express ports support MSI per-vector masking.
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} MSIMSGCTL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSGADR_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x40018064)                                                  */
/*       IVT_EX (0x40018064)                                                  */
/*       HSX (0x40018064)                                                     */
/*       BDX (0x40018064)                                                     */
/* Register default value:              0x00000000                            */
#define MSGADR_IIO_PCIENTB_REG 0x10004064
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The MSI Address Register (MSIAR) contains the system specific address 
 * information to route MSI interrupts from the root ports and is broken into its 
 * constituent fields. 
 */
typedef union {
  struct {
    UINT32 rsvd : 2;
    /* rsvd - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 address_id : 30;
    /* address_id - Bits[31:2], RW, default = 30'b000000000000000000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
  } Bits;
  UINT32 Data;
} MSGADR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSGDAT_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x40018068)                                                  */
/*       IVT_EX (0x40018068)                                                  */
/*       HSX (0x40018068)                                                     */
/*       BDX (0x40018068)                                                     */
/* Register default value:              0x00000000                            */
#define MSGDAT_IIO_PCIENTB_REG 0x10004068
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x068
 */
typedef union {
  struct {
    UINT32 data : 16;
    /* data - Bits[15:0], RW, default = 16'b0000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSGDAT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSIMSK_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x4001806C)                                                  */
/*       IVT_EX (0x4001806C)                                                  */
/*       HSX (0x4001806C)                                                     */
/*       BDX (0x4001806C)                                                     */
/* Register default value:              0x00000000                            */
#define MSIMSK_IIO_PCIENTB_REG 0x1000406C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x06c
 */
typedef union {
  struct {
    UINT32 mask_bits : 2;
    /* mask_bits - Bits[1:0], RW, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. For each Mask bit that is set, the PCI Express port is prohibited from 
       sending the associated message. When only one message is allocated to the root 
       port by software, only mask bit 0 is relevant and used by hardware. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIMSK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSIPENDING_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018070)                                                  */
/*       IVT_EX (0x40018070)                                                  */
/*       HSX (0x40018070)                                                     */
/*       BDX (0x40018070)                                                     */
/* Register default value:              0x00000000                            */
#define MSIPENDING_IIO_PCIENTB_REG 0x10004070
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x070
 */
typedef union {
  struct {
    UINT32 pending_bits : 2;
    /* pending_bits - Bits[1:0], RO_V, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. When MSI is not enabled or used by the root port, this register always 
       reads a value 0. For each Pending bit that is set, the PCI Express port has a 
       pending associated message. When only one message is allocated to the root port 
       by software, only pending bit 0 is set/cleared by hardware and pending bit 1 
       always reads 0. 
       Hardware sets this bit whenever it has an interrupt pending to be sent. This bit 
       remains set till either the interrupt is sent by hardware or the status bits 
       associated with the interrupt condition are cleared by software. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIPENDING_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSIXCAPID_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x10018080)                                                  */
/*       IVT_EX (0x10018080)                                                  */
/*       HSX (0x10018080)                                                     */
/*       BDX (0x10018080)                                                     */
/* Register default value:              0x11                                  */
#define MSIXCAPID_IIO_PCIENTB_REG 0x10001080
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x080
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010001 
       Assigned by PCI-SIG for MSI-X (CB DMA).
     */
  } Bits;
  UINT8 Data;
} MSIXCAPID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSIXNXTPTR_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x10018081)                                                  */
/*       IVT_EX (0x10018081)                                                  */
/*       HSX (0x10018081)                                                     */
/*       BDX (0x10018081)                                                     */
/* Register default value:              0x90                                  */
#define MSIXNXTPTR_IIO_PCIENTB_REG 0x10001081
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x081
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RW_O, default = 8'b10010000 
       This field is set to 90h for the next capability list (PCI Express capability 
       structure) in the chain. 
     */
  } Bits;
  UINT8 Data;
} MSIXNXTPTR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MSIXMSGCTRL_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x20018082)                                                  */
/*       IVT_EX (0x20018082)                                                  */
/*       HSX (0x20018082)                                                     */
/*       BDX (0x20018082)                                                     */
/* Register default value:              0x0003                                */
#define MSIXMSGCTRL_IIO_PCIENTB_REG 0x10002082
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x082
 */
typedef union {
  struct {
    UINT16 table_size : 11;
    /* table_size - Bits[10:0], RO_V, default = 11'b00000000011 
       System software reads this field to determine the MSI-X Table Size N, which is 
       encoded as N-1. For example, a returned value of '00000000011' indicates a table 
       size of 4. 
       
       NTB table size is 4, encoded as a value of 003h
     */
    UINT16 rsvd : 3;
    /* rsvd - Bits[13:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 function_mask : 1;
    /* function_mask - Bits[14:14], RW, default = 1'b0 
       1: all the vectors associated with the NTB are masked, regardless of the per 
       vector mask bit state. 
       0: each vector's mask bit determines whether the vector is masked or not.
       
       Notes:
       Setting or clearing the MSI-X function mask bit has no effect on the state of 
       the per-vector Mask bit. 
     */
    UINT16 msi_x_enable : 1;
    /* msi_x_enable - Bits[15:15], RW, default = 1'b0 
       Software uses this bit to select between INTx or MSI or MSI-X method for 
       signalinginterrupts from the DMA 
       0: NTB is prohibited from using MSI-X to request service
       1: MSI-X method is chosen for NTB interrupts
       
       Notes:
       Software must disable INTx and MSI-X for this device when using MSI
     */
  } Bits;
  UINT16 Data;
} MSIXMSGCTRL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* TABLEOFF_BIR_IIO_PCIENTB_REG supported on:                                 */
/*       IVT_EP (0x40018084)                                                  */
/*       IVT_EX (0x40018084)                                                  */
/*       HSX (0x40018084)                                                     */
/*       BDX (0x40018084)                                                     */
/* Register default value:              0x00002000                            */
#define TABLEOFF_BIR_IIO_PCIENTB_REG 0x10004084
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x084
 */
typedef union {
  struct {
    UINT32 table_bir : 3;
    /* table_bir - Bits[2:0], RO, default = 3'b000 
       CB DMA BAR is at offset 10h in the DMA config space and hence this register is 
       0. 
     */
    UINT32 table_offset : 29;
    /* table_offset - Bits[31:3], RO, default = 29'b00000000000000000010000000000 
       MSI-X Table Structure is at offset 8K from the CB BAR address.
     */
  } Bits;
  UINT32 Data;
} TABLEOFF_BIR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PBAOFF_BIR_IIO_PCIENTB_REG supported on:                                   */
/*       IVT_EP (0x40018088)                                                  */
/*       IVT_EX (0x40018088)                                                  */
/*       HSX (0x40018088)                                                     */
/*       BDX (0x40018088)                                                     */
/* Register default value:              0x00003000                            */
#define PBAOFF_BIR_IIO_PCIENTB_REG 0x10004088
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x088
 */
typedef union {
  struct {
    UINT32 pba_bir : 3;
    /* pba_bir - Bits[2:0], RO, default = 3'b000 
       1
     */
    UINT32 table_offset : 29;
    /* table_offset - Bits[31:3], RO, default = 29'b00000000000000000011000000000 
       MSI-X PBA Structure is at offset 12K from the CB BAR address.
     */
  } Bits;
  UINT32 Data;
} PBAOFF_BIR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PXPCAPID_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x10018090)                                                  */
/*       IVT_EX (0x10018090)                                                  */
/*       HSX (0x10018090)                                                     */
/*       BDX (0x10018090)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_PCIENTB_REG 0x10001090
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x090
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PXPNXTPTR_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x10018091)                                                  */
/*       IVT_EX (0x10018091)                                                  */
/*       HSX (0x10018091)                                                     */
/*       BDX (0x10018091)                                                     */
/* Register default value:              0xE0                                  */
#define PXPNXTPTR_IIO_PCIENTB_REG 0x10001091
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x091
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b11100000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PXPCAP_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018092)                                                  */
/*       IVT_EX (0x20018092)                                                  */
/*       HSX (0x20018092)                                                     */
/*       BDX (0x20018092)                                                     */
/* Register default value:              0x0002                                */
#define PXPCAP_IIO_PCIENTB_REG 0x10002092
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x092
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RW_O, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure, which 
       is 2h as of now. This register field is left as RW-O to cover any unknowns with 
       Gen3. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO_V, default = 4'b0000 
       This field identifies the type of device. It is set to 0100 for all the Express 
       ports. 
     */
    UINT16 slot_implemented : 1;
    /* slot_implemented - Bits[8:8], RW_O, default = 1'b0 
       Applies only to the root ports.
       1: indicates that the PCI Express link associated with the port is connected to 
       a slot. 
       0: indicates no slot is connected to this port.
       
       Notes:
       This register bit is of type 'write once' and is set by BIOS.
     */
    UINT16 interrupt_message_number : 5;
    /* interrupt_message_number - Bits[13:9], RO, default = 5'b00000 
       Applies to root ports. This field indicates the interrupt message number that is 
       generated for Power Management/Hot Plug/Bandwidth-change events. When there are 
       more than one MSI interrupt Number allocated for the root port MSI interrupts, 
       this register field is required to contain the offset between the base Message 
       Data and the MSI Message that is generated when there are these change 
       interrupts. IIO assigns the first vector for these change events and so this 
       field is set to 0. 
     */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* DEVCAP_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x40018094)                                                  */
/*       IVT_EX (0x40018094)                                                  */
/*       HSX (0x40018094)                                                     */
/*       BDX (0x40018094)                                                     */
/* Register default value:              0x00008021                            */
#define DEVCAP_IIO_PCIENTB_REG 0x10004094
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The PCI Express Device Capabilities register identifies device specific 
 * information for the device. 
 */
typedef union {
  struct {
    UINT32 max_payload_size_supported : 3;
    /* max_payload_size_supported - Bits[2:0], RO, default = 3'b001 
       1
     */
    UINT32 phantom_functions_supported : 2;
    /* phantom_functions_supported - Bits[4:3], RO, default = 2'b00 
       CB DMA does not support phantom functions.
     */
    UINT32 extended_tag_field_supported : 1;
    /* extended_tag_field_supported - Bits[5:5], RW_O, default = 1'b1  */
    UINT32 endpoint_l0s_acceptable_latency : 3;
    /* endpoint_l0s_acceptable_latency - Bits[8:6], RO, default = 3'b000 
       N/A
     */
    UINT32 endpoint_l1_acceptable_latency : 3;
    /* endpoint_l1_acceptable_latency - Bits[11:9], RO, default = 3'b000 
       N/A
     */
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[12:12], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[13:13], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 power_indicator_present_on_device : 1;
    /* power_indicator_present_on_device - Bits[14:14], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 role_based_error_reporting : 1;
    /* role_based_error_reporting - Bits[15:15], RO, default = 1'b1 
       IIO is 1.1 compliant and so supports this feature
     */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 captured_slot_power_limit_value : 8;
    /* captured_slot_power_limit_value - Bits[25:18], RO, default = 8'b00000000 
       Does not apply to CB DMA
     */
    UINT32 captured_slot_power_limit_scale : 2;
    /* captured_slot_power_limit_scale - Bits[27:26], RO, default = 2'b00 
       Does not apply to CB DMA
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* DEVCTRL_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x20018098)                                                  */
/*       IVT_EX (0x20018098)                                                  */
/*       HSX (0x20018098)                                                     */
/*       BDX (0x20018098)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL_IIO_PCIENTB_REG 0x10002098
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x098
 */
typedef union {
  struct {
    UINT16 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Controls the reporting of correctable errors that IIO detects on the PCI 
       Express/DMI interface 
       0: Reporting of link Correctable error detected by the port is disabled
       1: Reporting of link Correctable error detected by port is enabled
     */
    UINT16 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Controls the reporting of non-fatal errors that IIO detects on the PCI Express 
       interface. 
       0: Reporting of Non Fatal error detected by device is disabled
       1: Reporting of Non Fatal error detected by device is enabled
     */
    UINT16 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Controls the reporting of fatal errors that IIO detects on the PCI Express/DMI 
       interface. 
       0: Reporting of Fatal error detected by device is disabled
       1: Reporting of Fatal error detected by device is enabled
     */
    UINT16 unsupported_request_reporting_enable : 1;
    /* unsupported_request_reporting_enable - Bits[3:3], RW, default = 1'b0 
       This bit controls the reporting of unsupported requests that IIO itself detects 
       on requests its receives from a PCI Express port. 
       0: Reporting of unsupported requests is disabled
       1: Reporting of unsupported requests is enabled.
     */
    UINT16 enable_relaxed_ordering : 1;
    /* enable_relaxed_ordering - Bits[4:4], RO, default = 1'b0 
       Not applicable to root ports since they never set relaxed ordering bit as a 
       requester (this does not include tx forwarded from peer devices). This bit has 
       no impact on forwarding of relaxed ordering attribute on peer requests. 
     */
    UINT16 max_payload_size : 3;
    /* max_payload_size - Bits[7:5], RW_LV, default = 3'b000 
       000: 128B max payload size
       001: 256B max payload size
       others: alias to 128B
       
       IIO can receive packets equal to the size set by this field.
       IIO generate read completions as large as the value set by this field.
       IIO generates memory writes of max 64B.
     */
    UINT16 extended_tag_field_enable : 1;
    /* extended_tag_field_enable - Bits[8:8], RW, default = 1'b0 
       Not applicable, since IIO never generates any requests on its own that uses tags 
       7:5. However, IIO forwards the entire tag field for peer to peer requests, so 
       tag[7:5] could be set. 
     */
    UINT16 phantom_functions_enable : 1;
    /* phantom_functions_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable, since IIO never uses phantom functions as a requestor.
     */
    UINT16 auxiliary_power_management_enable : 1;
    /* auxiliary_power_management_enable - Bits[10:10], RO, default = 1'b0 
       Not applicable
     */
    UINT16 enable_no_snoop : 1;
    /* enable_no_snoop - Bits[11:11], RO, default = 1'b0 
       Not applicable to PCIe root ports since they never set the 'No Snoop' bit for 
       transactions they originate (not forwarded from peer) to PCI Express/DMI. This 
       bit has no impact on forwarding of NoSnoop attribute on peer requests. 
     */
    UINT16 max_read_request_size : 3;
    /* max_read_request_size - Bits[14:12], RO, default = 3'b000 
       PCI Express ports do not generate requests greater than 64B and this field is 
       RO. 
     */
    UINT16 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* DEVSTS_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x2001809A)                                                  */
/*       IVT_EX (0x2001809A)                                                  */
/*       HSX (0x2001809A)                                                     */
/*       BDX (0x2001809A)                                                     */
/* Register default value:              0x0000                                */
#define DEVSTS_IIO_PCIENTB_REG 0x1000209A
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCI Express Device Status
 */
typedef union {
  struct {
    UINT16 correctable_error_detected : 1;
    /* correctable_error_detected - Bits[0:0], RW1C, default = 1'b0 
       This bit gets set if a correctable error is detected by the root port. Errors 
       are logged in this register regardless of whether error reporting is enabled or 
       not in the PCI Express Device Control register. 
       1: correctable errors detected
       0: No correctable errors detected
     */
    UINT16 non_fatal_error_detected : 1;
    /* non_fatal_error_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit gets set if a non-fatal uncorrectable error is detected by the root 
       port. Errors are logged in this register regardless of whether error reporting 
       is enabled or not in the Device Control register. 
       1: Non Fatal errors detected
       0: No non-Fatal Errors detected
     */
    UINT16 fatal_error_detected : 1;
    /* fatal_error_detected - Bits[2:2], RW1C, default = 1'b0 
       This bit indicates that a fatal (uncorrectable) error is detected by the root 
       port. Errors are logged in this register regardless of whether error reporting 
       is enabled or not in the Device Control register. 
       1: Fatal errors detected
       0: No Fatal errors detected
     */
    UINT16 unsupported_request_detected : 1;
    /* unsupported_request_detected - Bits[3:3], RW1C, default = 1'b0 
       This bit indicates that the root port port detected an Unsupported Request. 
       Errors are logged in this register regardless of whether error reporting is 
       enabled or not in the Device Control Register. 
       1: Unsupported Request detected at the device/port. These unsupported requests 
       are NP requests inbound that the root port port received and it detected them as 
       unsupported requests (e.g. address decoding failures that the root port detected 
       on a packet, receiving inbound lock reads, BME bit is clear etc.). 
       0: No unsupported request detected by the root port
       
       This bit is not set on peer2peer completions with UR status that are forwarded 
       by the root port to the PCIe link. 
     */
    UINT16 aux_power_detected : 1;
    /* aux_power_detected - Bits[4:4], RO, default = 1'b0 
       Does not apply to IIO
     */
    UINT16 transactions_pending : 1;
    /* transactions_pending - Bits[5:5], RO, default = 1'b0 
       Does not apply to Root/DMI ports, i.e. bit hardwired to 0 for these devices.
     */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PBAR23SZ_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x100180D0)                                                  */
/*       IVT_EX (0x100180D0)                                                  */
/*       HSX (0x100180D0)                                                     */
/*       BDX (0x100180D0)                                                     */
/* Register default value:              0x00                                  */
#define PBAR23SZ_IIO_PCIENTB_REG 0x100010D0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * This register contains a value used to set the size of the memory window 
 * requested by the 64-bit BAR 2/3 pair for the Primary side of the NTB. 
 */
typedef union {
  struct {
    UINT8 primary_bar_2_3_size : 8;
    /* primary_bar_2_3_size - Bits[7:0], RW_L, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} PBAR23SZ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PBAR45SZ_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x100180D1)                                                  */
/*       IVT_EX (0x100180D1)                                                  */
/*       HSX (0x100180D1)                                                     */
/*       BDX (0x100180D1)                                                     */
/* Register default value:              0x00                                  */
#define PBAR45SZ_IIO_PCIENTB_REG 0x100010D1
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * This register contains a value used to set the size of the memory window 
 * requested by the 64-bit BAR 4/5 pair for the Primary side of the NTB. 
 * If BARs 4 and 5 are configured as 32b BARs (ppd.bar45_32bit=1), then this 
 * configures BAR4 only. 
 */
typedef union {
  struct {
    UINT8 primary_bar_4_5_size : 8;
    /* primary_bar_4_5_size - Bits[7:0], RW_L, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} PBAR45SZ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SBAR23SZ_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x100180D2)                                                  */
/*       IVT_EX (0x100180D2)                                                  */
/*       HSX (0x100180D2)                                                     */
/*       BDX (0x100180D2)                                                     */
/* Register default value:              0x00                                  */
#define SBAR23SZ_IIO_PCIENTB_REG 0x100010D2
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x0d2
 */
typedef union {
  struct {
    UINT8 secondary_bar_2_3_size : 8;
    /* secondary_bar_2_3_size - Bits[7:0], RW_L, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} SBAR23SZ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SBAR45SZ_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x100180D3)                                                  */
/*       IVT_EX (0x100180D3)                                                  */
/*       HSX (0x100180D3)                                                     */
/*       BDX (0x100180D3)                                                     */
/* Register default value:              0x00                                  */
#define SBAR45SZ_IIO_PCIENTB_REG 0x100010D3
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x0d3
 */
typedef union {
  struct {
    UINT8 secondary_bar_4_5_size : 8;
    /* secondary_bar_4_5_size - Bits[7:0], RW_L, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} SBAR45SZ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PPD_IIO_PCIENTB_REG supported on:                                          */
/*       IVT_EP (0x100180D4)                                                  */
/*       IVT_EX (0x100180D4)                                                  */
/*       HSX (0x100180D4)                                                     */
/*       BDX (0x100180D4)                                                     */
/* Register default value:              0x00                                  */
#define PPD_IIO_PCIENTB_REG 0x100010D4


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.3.0.Port3_NTB.xml.
 * This register defines the behavior of the PCIE port which can be either a RP, 
 * NTB connected to another NTB or an NTB connected to a Root Complex. This 
 * register is used to set the value in the DID register on the Primary side of the 
 * NTB (located at offset 02h). This value is loaded by BIOS prior to running PCI 
 * enumeration. 
 */
typedef union {
  struct {
    UINT8 port_definition : 2;
    /* port_definition - Bits[1:0], RW_LV, default = 2'b00 
       Value indicating the value to be loaded into the DID register (offset 02h).
       00b - Transparent bridge
       01b - 2 NTBs connected back to back
       10b - NTB connected to a RP
       11b - Reserved
     */
    UINT8 crosslink_control : 2;
    /* crosslink_control - Bits[3:2], RW_LV, default = 2'b00 
       Directly forces the polarity of the NTB port to be either an Upstream Device 
       (USD) or Downstream Device (DSD). 
       
       11: Force NTB port to USD/DSP;
       10: Force NTB port to DSD/USP;
       Others: Reserved
       
       NOTE: Bits 03:02 of this register only have meaning when bits 01:00 of this same 
       register are programmed as '01'b (NTB/NTB). When configured as NTB/RP hardware 
       directly sets port to DSD/USP so this field is not required. 
     */
    UINT8 crosslink_configuration_status : 1;
    /* crosslink_configuration_status - Bits[4:4], RO_V, default = 1'b0 
       This bit is written by hardware and shows the result of the NTBCROSSLINK.
       
       0: NTB port is configured as USD/DSP
       1: NTB port is configured as DSD/USP
     */
    UINT8 ntb_primary_side_msi_x_single_message_vector : 1;
    /* ntb_primary_side_msi_x_single_message_vector - Bits[5:5], RW_LV, default = 1'b0 
       This bit when set, causes only a single MSI-X message to be generated if MSI-X 
       is enabled. This bit affects the default value of the MSI-X Table Size field. 
     */
    UINT8 bar45_32bit : 1;
    /* bar45_32bit - Bits[6:6], RW_LV, default = 1'b0 
       If set, BARs 4 and 5 are presented as two 32b non-prefetchable BARs.
       If clear, BARs 4 and 5 are presented as one 64b BAR.
     */
    UINT8 rsvd : 1;
    /* rsvd - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} PPD_IIO_PCIENTB_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* PMCAP_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x400180E0)                                                  */
/*       IVT_EX (0x400180E0)                                                  */
/*       HSX (0x400180E0)                                                     */
/*       BDX (0x400180E0)                                                     */
/* Register default value:              0xC8030001                            */
#define PMCAP_IIO_PCIENTB_REG 0x100040E0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x0e0
 */
typedef union {
  struct {
    UINT32 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000001 
       Provides the PM capability ID assigned by PCI-SIG.
     */
    UINT32 next_capability_pointer : 8;
    /* next_capability_pointer - Bits[15:8], RO, default = 8'b00000000 
       This is the last capability in the chain and hence set to 0.
     */
    UINT32 version : 3;
    /* version - Bits[18:16], RO, default = 3'b011 
       This field is set to 3h (PM 1.2 compliant) as version number.
     */
    UINT32 pme_clock : 1;
    /* pme_clock - Bits[19:19], RO, default = 1'b0 
       This field is hardwired to 0h as it does not apply to PCI Express.
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[20:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 device_specific_initialization : 1;
    /* device_specific_initialization - Bits[21:21], RO, default = 1'b0  */
    UINT32 aux_current : 3;
    /* aux_current - Bits[24:22], RO, default = 3'b000  */
    UINT32 d1_support : 1;
    /* d1_support - Bits[25:25], RO, default = 1'b0 
       I/OxAPIC does not support power management state D1.
     */
    UINT32 d2_support : 1;
    /* d2_support - Bits[26:26], RO, default = 1'b0 
       I/OxAPIC does not support power management state D2.
     */
    UINT32 pme_support : 5;
    /* pme_support - Bits[31:27], RO_V, default = 5'b11001 
       Bits 31, 30 and 27 must be set to \q1\q for PCI-PCI bridge structures 
       representing ports on root complexes. 
     */
  } Bits;
  UINT32 Data;
} PMCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PMCSR_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x400180E4)                                                  */
/*       IVT_EX (0x400180E4)                                                  */
/*       HSX (0x400180E4)                                                     */
/*       BDX (0x400180E4)                                                     */
/* Register default value:              0x00000008                            */
#define PMCSR_IIO_PCIENTB_REG 0x100040E4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x0e4
 */
typedef union {
  struct {
    UINT32 power_state : 2;
    /* power_state - Bits[1:0], RW, default = 2'b00 
       This 2-bit field is used to determine the current power state of the function 
       and to set a new power state as well. 
       00: D0
       01: D1 (not supported by IOAPIC)
       10: D2 (not supported by IOAPIC)
       11: D3_hot
       If Software tries to write 01 or 10 to this field, the power state does not 
       change from the existing power state (which is either D0 or D3hot) and nor do 
       these bits1:0 change value. 
       When in D3hot state, I/OxAPIC will
       a) respond to only Type 0 configuration transactions targeted at the device's 
       configuration space, when in D3hot state 
       c) will not respond to memory (i.e. D3hot state is equivalent to MSE ), accesses 
       to MBAR region (note: ABAR region access still go through in D3hot state, if it 
       enabled) 
       d) will not generate any MSI writes
     */
    UINT32 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 no_soft_reset : 1;
    /* no_soft_reset - Bits[3:3], RW_O, default = 1'b1 
       Indicates I/OxAPIC does not reset its registers when transitioning from D3hot to 
       D0. 
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pme_enable : 1;
    /* pme_enable - Bits[8:8], RWS_L, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data_select : 4;
    /* data_select - Bits[12:9], RO, default = 4'b0000 
       Not relevant for I/OxAPIC
     */
    UINT32 data_scale : 2;
    /* data_scale - Bits[14:13], RO, default = 2'b00 
       Not relevant for I/OxAPIC
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[15:15], RW1CS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 rsvd_16 : 6;
    /* rsvd_16 - Bits[21:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 b2_b3_support : 1;
    /* b2_b3_support - Bits[22:22], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 bus_power_clock_control_enable : 1;
    /* bus_power_clock_control_enable - Bits[23:23], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data : 8;
    /* data - Bits[31:24], RO, default = 8'b00000000 
       Not relevant for I/OxAPIC
     */
  } Bits;
  UINT32 Data;
} PMCSR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPREUT_HDR_EXT_IIO_PCIENTB_REG supported on:                               */
/*       IVT_EP (0x40018100)                                                  */
/*       IVT_EX (0x40018100)                                                  */
/*       HSX (0x40018100)                                                     */
/*       BDX (0x40018100)                                                     */
/* Register default value:              0x1101000B                            */
#define XPREUT_HDR_EXT_IIO_PCIENTB_REG 0x10004100
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * REUT PCIe Header Extended
 */
typedef union {
  struct {
    UINT32 pciecapid : 16;
    /* pciecapid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe Extended CapID
       This field has the value 0Bh to identify the CAP_ID assigned by the PCI SIG 
       indicating a vendor specific capability. 
     */
    UINT32 pciecapversion : 4;
    /* pciecapversion - Bits[19:16], RO, default = 4'b0001 
       Capability Version
       This field is a PCI-SIG defined version number that indicates the nature and 
       format of the extended capability. This indicates the version of the REUT 
       Capability. 
     */
    UINT32 pcienextptr : 12;
    /* pcienextptr - Bits[31:20], RO, default = 12'b000100010000 
       Next Capability Pointer
       This field contains the offset to the next PCI capability structure or 00h if no 
       other items exist in the linked list of capabilities. 
       In DMI Mode, it points to the Vendor Specific Error Capability.
       In PCIe Mode, it points to the ACS Capability.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_EXT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPREUT_HDR_CAP_IIO_PCIENTB_REG supported on:                               */
/*       IVT_EP (0x40018104)                                                  */
/*       IVT_EX (0x40018104)                                                  */
/*       HSX (0x40018104)                                                     */
/*       BDX (0x40018104)                                                     */
/* Register default value:              0x00C00002                            */
#define XPREUT_HDR_CAP_IIO_PCIENTB_REG 0x10004104
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * REUT Header Capability
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000010 
       This field is a Intel-defined ID number that indicates the nature and format of 
       the VSEC structure. Software must qualify the Vendor ID before interpreting this 
       field. 
     */
    UINT32 vsecidrev : 4;
    /* vsecidrev - Bits[19:16], RO, default = 4'b0000 
       This field is defined as the version number that indicates the nature and format 
       of the VSEC structure. Software must quality the Vendor ID before interpreting 
       this field. 
     */
    UINT32 vseclength : 12;
    /* vseclength - Bits[31:20], RO, default = 12'b000000001100 
       This field defines the length of the REUT 'capability body'. The size of the 
       leaf body is 12 bytes including the _EXT, _CAP and _LEF registers. 
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_CAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPREUT_HDR_LEF_IIO_PCIENTB_REG supported on:                               */
/*       IVT_EP (0x40018108)                                                  */
/*       IVT_EX (0x40018108)                                                  */
/*       HSX (0x40018108)                                                     */
/*       BDX (0x40018108)                                                     */
/* Register default value:              0x00003807                            */
#define XPREUT_HDR_LEF_IIO_PCIENTB_REG 0x10004108
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 leafreutengid : 8;
    /* leafreutengid - Bits[7:0], RO_V, default = 8'b00000111 
       This field identifies the REUT engine associated with the link (same as the REUT 
       ID). 
     */
    UINT32 leafreutdevnum : 8;
    /* leafreutdevnum - Bits[15:8], RO_V, default = 8'b00111000 
       This field identifies the PCI Device/Function # where the REUT engine associated 
       with this link resides. 
       Device6 = 00110b & function0 = 000b = 30h
       Device6 = 00110b & function1 = 001b = 31h
       Device6 = 00110b & function2 = 010b = 32h
       Device6 = 00110b & function3 = 011b = 33h
       Device6 = 00110b & function4 = 100b = 34h
       Device6 = 00110b & function5 = 101b = 35h
       Device6 = 00110b & function6 = 110b = 36h
       Device7 = 00111b & function0 = 000b = 38h
       Device7 = 00111b & function1 = 001b = 39h
       Device7 = 00111b & function2 = 010b = 3Ah
       Device7 = 00111b & function3 = 011b = 3Bh
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_LEF_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ACSCAPHDR_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x40018110)                                                  */
/*       IVT_EX (0x40018110)                                                  */
/*       HSX (0x40018110)                                                     */
/*       BDX (0x40018110)                                                     */
/* Register default value:              0x1481000D                            */
#define ACSCAPHDR_IIO_PCIENTB_REG 0x10004110
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Access Control Services Extended Capability Header
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000001101 
       Assigned for Access Control Services capability by PCISIG.
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001 
       Capability version of the PCI Express logic.
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO_V, default = 12'b000101001000 
       This field points to the next Capability in extended configuration space.
     */
  } Bits;
  UINT32 Data;
} ACSCAPHDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ACSCAP_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018114)                                                  */
/*       IVT_EX (0x20018114)                                                  */
/*       HSX (0x20018114)                                                     */
/*       BDX (0x20018114)                                                     */
/* Register default value:              0x001F                                */
#define ACSCAP_IIO_PCIENTB_REG 0x10002114
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x114
 */
typedef union {
  struct {
    UINT16 v : 1;
    /* v - Bits[0:0], RO_V, default = 1'b1  */
    UINT16 b : 1;
    /* b - Bits[1:1], RO_V, default = 1'b1  */
    UINT16 r : 1;
    /* r - Bits[2:2], RO_V, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS P2P 
       Request Redirect. 
     */
    UINT16 c : 1;
    /* c - Bits[3:3], RO_V, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS P2P 
       Completion Redirect. 
     */
    UINT16 u : 1;
    /* u - Bits[4:4], RO_V, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS Upstream 
       Forwarding. 
     */
    UINT16 e : 1;
    /* e - Bits[5:5], RO, default = 1'b0 
       Applies only to root portsIndicates that the component does not implement ACS 
       P2P Egress Control. 
     */
    UINT16 t : 1;
    /* t - Bits[6:6], RO, default = 1'b0 
       Applies only to root portsIndicates that the component does not implement ACS 
       Direct Translated P2P. 
     */
    UINT16 rsvd : 1;
    /* rsvd - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 egress_control_vector_size : 8;
    /* egress_control_vector_size - Bits[15:8], RO, default = 8'b00000000 
       N/A for IIO
     */
  } Bits;
  UINT16 Data;
} ACSCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ACSCTRL_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x20018116)                                                  */
/*       IVT_EX (0x20018116)                                                  */
/*       HSX (0x20018116)                                                     */
/*       BDX (0x20018116)                                                     */
/* Register default value:              0x0000                                */
#define ACSCTRL_IIO_PCIENTB_REG 0x10002116
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x116
 */
typedef union {
  struct {
    UINT16 v : 1;
    /* v - Bits[0:0], RW_L, default = 1'b0 
       Applies only to root portsWhen set, the component validates the Bus Number from 
       the Requester ID of upstream Requests against the secondary / subordinate Bus 
       Numbers. 
     */
    UINT16 b : 1;
    /* b - Bits[1:1], RW_L, default = 1'b0 
       Applies only to root portsWhen set, the component blocks all upstream Memory 
       Requests whose Address Translation (AT) field is not set to the default value. 
     */
    UINT16 r : 1;
    /* r - Bits[2:2], RW_L, default = 1'b0 
       When this bit is set, transactions arriving from a root port that target the 
       same port back down, will be forwarded. Normally such traffic would be aborted. 
       Applies only to root ports. 
     */
    UINT16 c : 1;
    /* c - Bits[3:3], RW_L, default = 1'b0 
       Applies only to root portsDetermines when the component redirects peer-to-peer 
       Completions upstream; applicable only to Read Completions whose Relaxed Ordering 
       Attribute is clear. 
     */
    UINT16 u : 1;
    /* u - Bits[4:4], RW_L, default = 1'b0 
       When this bit is set, transactions arriving from a root port that target the 
       same port back down, will be forwarded. Normally such traffic would be aborted. 
       Applies only to root ports. 
     */
    UINT16 e : 1;
    /* e - Bits[5:5], RO, default = 1'b0 
       Applies only to root portsThe component does not implement ACS P2P Egress 
       Control and hence this bit should not be used by SW. 
     */
    UINT16 t : 1;
    /* t - Bits[6:6], RO, default = 1'b0 
       Applies only to root portsThis is hardwired to 0b as the component does not 
       implement ACS Direct Translated P2P. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[15:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ACSCTRL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* APICBASE_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x20018140)                                                  */
/*       IVT_EX (0x20018140)                                                  */
/*       HSX (0x20018140)                                                     */
/*       BDX (0x20018140)                                                     */
/* Register default value:              0x0000                                */
#define APICBASE_IIO_PCIENTB_REG 0x10002140
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x140
 */
typedef union {
  struct {
    UINT16 en : 1;
    /* en - Bits[0:0], RW, default = 1'b0 
       enables the decode of the APIC window
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       These are addr bits 19:9. Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a 
       don't care for address decode. Address decoding to the APIC range is done as 
       APICBASE.ADDR[31:9] &lt;= A[31:9] &lt;= APICLIMIT.ADDR[31:9]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if bit 0 is set, even if the MSE bit of the root port is clear or the 
       root port itself is in D3hot state. 
     */
    UINT16 rsvd : 4;
    /* rsvd - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICBASE_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* APICLIMIT_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x20018142)                                                  */
/*       IVT_EX (0x20018142)                                                  */
/*       HSX (0x20018142)                                                     */
/*       BDX (0x20018142)                                                     */
/* Register default value:              0x0000                                */
#define APICLIMIT_IIO_PCIENTB_REG 0x10002142
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x142
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Applies only to root ports. These are addr bits 19:9. Bits 31:20 are assumed to 
       be 0xFECh. Bits 8:0 are a don't care for address decode. Address decoding to the 
       APIC range is done as APICBASE.ADDR[31:9] &lt;= A[31:9] &lt;= 
       APICLIMIT.ADDR[31:9]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if the range is enabled, even if the MSE bit of the root port is clear 
       or the root 
       port itself is in D3hot state.
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICLIMIT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* VSECPHDR_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x40018144)                                                  */
/*       IVT_EX (0x40018144)                                                  */
/*       HSX (0x40018144)                                                     */
/*       BDX (0x40018144)                                                     */
/* Register default value:              0x1D01000B                            */
#define VSECPHDR_IIO_PCIENTB_REG 0x10004144
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x144
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000111010000  */
  } Bits;
  UINT32 Data;
} VSECPHDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* VSHDR_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x40018148)                                                  */
/*       IVT_EX (0x40018148)                                                  */
/*       HSX (0x40018148)                                                     */
/*       BDX (0x40018148)                                                     */
/* Register default value:              0x03C10004                            */
#define VSHDR_IIO_PCIENTB_REG 0x10004148
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x148
 */
typedef union {
  struct {
    UINT32 vsec_id : 16;
    /* vsec_id - Bits[15:0], RO, default = 16'b0000000000000100  */
    UINT32 vsec_version : 4;
    /* vsec_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 vsec_length : 12;
    /* vsec_length - Bits[31:20], RO, default = 12'b000000111100  */
  } Bits;
  UINT32 Data;
} VSHDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* UNCERRSTS_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x4001814C)                                                  */
/*       IVT_EX (0x4001814C)                                                  */
/*       HSX (0x4001814C)                                                     */
/*       BDX (0x4001814C)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRSTS_IIO_PCIENTB_REG 0x1000414C
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x14c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 ecrc_error_status : 1;
    /* ecrc_error_status - Bits[19:19], RW1CS, default = 1'b0  */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* UNCERRMSK_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x40018150)                                                  */
/*       IVT_EX (0x40018150)                                                  */
/*       HSX (0x40018150)                                                     */
/*       BDX (0x40018150)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRMSK_IIO_PCIENTB_REG 0x10004150
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x150
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_mask : 1;
    /* ecrc_error_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* UNCERRSEV_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x40018154)                                                  */
/*       IVT_EX (0x40018154)                                                  */
/*       HSX (0x40018154)                                                     */
/*       BDX (0x40018154)                                                     */
/* Register default value:              0x00062030                            */
#define UNCERRSEV_IIO_PCIENTB_REG 0x10004154
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x154
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 ecrc_error_severity : 1;
    /* ecrc_error_severity - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* CORERRSTS_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x40018158)                                                  */
/*       IVT_EX (0x40018158)                                                  */
/*       HSX (0x40018158)                                                     */
/*       BDX (0x40018158)                                                     */
/* Register default value:              0x00000000                            */
#define CORERRSTS_IIO_PCIENTB_REG 0x10004158
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x158
 */
typedef union {
  struct {
    UINT32 receiver_error_status : 1;
    /* receiver_error_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_status : 1;
    /* bad_tlp_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 bad_dllp_status : 1;
    /* bad_dllp_status - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 replay_num_rollover_status : 1;
    /* replay_num_rollover_status - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_status : 1;
    /* replay_timer_time_out_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_status : 1;
    /* advisory_non_fatal_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* CORERRMSK_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x4001815C)                                                  */
/*       IVT_EX (0x4001815C)                                                  */
/*       HSX (0x4001815C)                                                     */
/*       BDX (0x4001815C)                                                     */
/* Register default value:              0x00002000                            */
#define CORERRMSK_IIO_PCIENTB_REG 0x1000415C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x15c
 */
typedef union {
  struct {
    UINT32 receiver_error_mask : 1;
    /* receiver_error_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_mask : 1;
    /* bad_tlp_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_mask : 1;
    /* bad_dllp_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_mask : 1;
    /* replay_num_rollover_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_mask : 1;
    /* replay_timer_time_out_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_mask : 1;
    /* advisory_non_fatal_error_mask - Bits[13:13], RWS, default = 1'b1  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRMSK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ERRCAP_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x40018160)                                                  */
/*       IVT_EX (0x40018160)                                                  */
/*       HSX (0x40018160)                                                     */
/*       BDX (0x40018160)                                                     */
/* Register default value on IVT_EP:    0x00000000                            */
/* Register default value on IVT_EX:    0x00000000                            */
/* Register default value on HSX:       0x00000000                            */
/* Register default value on BDX:       0x000000A0                            */
#define ERRCAP_IIO_PCIENTB_REG 0x10004160
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 first_error_pointer : 5;
    /* first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000 
       The First Error Pointer is a read-only register that identifies the bit position 
       of the first unmasked error reported in the Uncorrectable Error register. In 
       case of two errors happening at the same time, fatal error gets precedence over 
       non-fatal, in terms of being reported as first error. This field is rearmed to 
       capture new errors when the status bit indicated by this field is cleared by 
       software. 
     */
    UINT32 ecrc_generation_capable : 1;
    /* ecrc_generation_capable - Bits[5:5], RW_O, default = 1'b1  */
    UINT32 ecrc_generation_enable : 1;
    /* ecrc_generation_enable - Bits[6:6], RWS, default = 1'b0  */
    UINT32 ecrc_check_capable : 1;
    /* ecrc_check_capable - Bits[7:7], RW_O, default = 1'b1  */
    UINT32 ecrc_check_enable : 1;
    /* ecrc_check_enable - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd : 23;
    /* rsvd - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ERRCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* HDRLOG0_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018164)                                                  */
/*       IVT_EX (0x40018164)                                                  */
/*       HSX (0x40018164)                                                     */
/*       BDX (0x40018164)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG0_IIO_PCIENTB_REG 0x10004164
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Header Log 0 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 0: Logs the first DWORD of the header on an error condition.
     */
  } Bits;
  UINT32 Data;
} HDRLOG0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* HDRLOG1_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018168)                                                  */
/*       IVT_EX (0x40018168)                                                  */
/*       HSX (0x40018168)                                                     */
/*       BDX (0x40018168)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG1_IIO_PCIENTB_REG 0x10004168
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Header Log 1
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 1: Logs the second DWORD of the header on an error 
       condition. 
     */
  } Bits;
  UINT32 Data;
} HDRLOG1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* HDRLOG2_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x4001816C)                                                  */
/*       IVT_EX (0x4001816C)                                                  */
/*       HSX (0x4001816C)                                                     */
/*       BDX (0x4001816C)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG2_IIO_PCIENTB_REG 0x1000416C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Header Log 2 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 2: Logs the third DWORD of the header on an error condition.
     */
  } Bits;
  UINT32 Data;
} HDRLOG2_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* HDRLOG3_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018170)                                                  */
/*       IVT_EX (0x40018170)                                                  */
/*       HSX (0x40018170)                                                     */
/*       BDX (0x40018170)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG3_IIO_PCIENTB_REG 0x10004170
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Header Log 3 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 3: Logs the fourth DWORD of the header on an error 
       condition. 
     */
  } Bits;
  UINT32 Data;
} HDRLOG3_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* RPERRCMD_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x40018174)                                                  */
/*       IVT_EX (0x40018174)                                                  */
/*       HSX (0x40018174)                                                     */
/*       BDX (0x40018174)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRCMD_IIO_PCIENTB_REG 0x10004174
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x174
 */
typedef union {
  struct {
    UINT32 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on correctable errors when set.
     */
    UINT32 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on a non-fatal error when set.
     */
    UINT32 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Applies to root ports onlyEnable MSI/INTx interrupt on fatal errors when set.
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPERRCMD_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* RPERRSTS_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x40018178)                                                  */
/*       IVT_EX (0x40018178)                                                  */
/*       HSX (0x40018178)                                                     */
/*       BDX (0x40018178)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRSTS_IIO_PCIENTB_REG 0x10004178
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Root Port Error Status
 * The Root Error Status register reports status of error Messages (ERR_COR), 
 * ERR_NONFATAL, and ERR_FATAL) received by the Root Complex in IIO, and errors 
 * detected by the Root Port itself (which are treated conceptually as if the Root 
 * Port had sent an error Message to itself). 
 * The ERR_NONFATAL and ERR_FATAL Messages are grouped together as uncorrectable. 
 * Each correctable and uncorrectable (Non-fatal and Fatal) error source has a 
 * first error bit and a next error bit associated with it respectively. When an 
 * error is received by a Root Complex, the respective first error bit is set and 
 * the Requestor ID is logged in the Error Source Identification register. 
 * A set individual error status bit indicates that a particular error category 
 * occurred; software may clear an error status by writing a 1 to the respective 
 * bit. If software does not clear the first reported error before another error 
 * Message is received of the same category (correctable or uncorrectable), the 
 * corresponding next error status bit will be set but the Requestor ID of the 
 * subsequent error Message is discarded. The next error status bits may be cleared 
 * by software by writing a 1 to the respective bit as well. 
 */
typedef union {
  struct {
    UINT32 correctable_error_received : 1;
    /* correctable_error_received - Bits[0:0], RW1CS, default = 1'b0 
       Set when a correctable error message is received and this bit is already not 
       set. i.e. log the first error message. 
     */
    UINT32 multiple_correctable_error_received : 1;
    /* multiple_correctable_error_received - Bits[1:1], RW1CS, default = 1'b0 
       Set when either a correctable error message is received and Correctable Error 
       Received bit is already set, i.e log from the 2nd Correctable error message 
       onwards. 
     */
    UINT32 error_fatal_nonfatal_received : 1;
    /* error_fatal_nonfatal_received - Bits[2:2], RW1CS, default = 1'b0 
       Set when either a fatal or a non-fatal error message is received and this bit is 
       already not set. i.e. log the first error message. Note that when this bit is 
       set bit 3 could be either set or clear. 
     */
    UINT32 multiple_error_fatal_nonfatal_received : 1;
    /* multiple_error_fatal_nonfatal_received - Bits[3:3], RW1CS, default = 1'b0 
       Set when either a fatal or a non-fatal error message is received and Error 
       Fatal/Nonfatal Received is already set, i.e log from the 2nd Fatal or No fatal 
       error message onwards. 
     */
    UINT32 first_uncorrectable_fatal : 1;
    /* first_uncorrectable_fatal - Bits[4:4], RW1CS, default = 1'b0 
       Set when bit 2 is set (from being clear) and the message causing bit 2 to be set 
       is an ERR_FATAL message. 
     */
    UINT32 non_fatal_error_messages_received : 1;
    /* non_fatal_error_messages_received - Bits[5:5], RW1CS, default = 1'b0 
       Set when one or more Non-Fatal Uncorrectable error Messages have been received.
     */
    UINT32 fatal_error_messages_received : 1;
    /* fatal_error_messages_received - Bits[6:6], RW1CS, default = 1'b0 
       Set when one or more Fatal Uncorrectable error Messages have been received.
     */
    UINT32 rsvd : 20;
    /* rsvd - Bits[26:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 advanced_error_interrupt_message_number : 5;
    /* advanced_error_interrupt_message_number - Bits[31:27], RO, default = 5'b00000 
       Advanced Error Interrupt Message Number offset between base message data an the 
       MSI message if assigned more than one message number. IIO hardware automatically 
       updates this register to 0x1h if the number of messages allocated to the root 
       port is 2. 
     */
  } Bits;
  UINT32 Data;
} RPERRSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ERRSID_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x4001817C)                                                  */
/*       IVT_EX (0x4001817C)                                                  */
/*       HSX (0x4001817C)                                                     */
/*       BDX (0x4001817C)                                                     */
/* Register default value:              0x00000000                            */
#define ERRSID_IIO_PCIENTB_REG 0x1000417C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Error Source Identification
 */
typedef union {
  struct {
    UINT32 correctable_error_source_id : 16;
    /* correctable_error_source_id - Bits[15:0], ROS_V, default = 16'b0000000000000000 
       Requestor ID of the source when a correctable error message is received and the 
       Correctable Error Received bit is not already set. i.e log ID of the first 
       correctable error message. Note that when the root port itself is the cause of 
       the received message (virtual message), then a Source ID of CPUBUSNO0:DevNo:0 is 
       logged into this register. 
     */
    UINT32 fatal_non_fatal_error_source_id : 16;
    /* fatal_non_fatal_error_source_id - Bits[31:16], ROS_V, default = 16'b0000000000000000 
       Requestor ID of the source when an Fatal or Non Fatal error message is received 
       and the Error Fatal/Nonfatal Received bit is not already set. i.e log ID of the 
       first Fatal or Non Fatal error message. Note that when the root port itself is 
       the cause of the received message (virtual message), then a Source ID of 
       CPUBUSNO0:DevNo:0 is logged into this register. 
     */
  } Bits;
  UINT32 Data;
} ERRSID_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PERFCTRLSTS_0_IIO_PCIENTB_REG supported on:                                */
/*       IVT_EP (0x40018180)                                                  */
/*       IVT_EX (0x40018180)                                                  */
/*       HSX (0x40018180)                                                     */
/*       BDX (0x40018180)                                                     */
/* Register default value:              0x00183091                            */
#define PERFCTRLSTS_0_IIO_PCIENTB_REG 0x10004180
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 read_stream_policy : 1;
    /* read_stream_policy - Bits[0:0], RW, default = 1'b1  */
    UINT32 read_passing_read_disable : 1;
    /* read_passing_read_disable - Bits[1:1], RW, default = 1'b0 
       Disable reads bypassing other reads.
     */
    UINT32 nosnoopoprden : 1;
    /* nosnoopoprden - Bits[2:2], RW, default = 1'b0  */
    UINT32 nosnoopopwren : 1;
    /* nosnoopopwren - Bits[3:3], RW, default = 1'b0  */
    UINT32 read_stream_interleave_size : 1;
    /* read_stream_interleave_size - Bits[4:4], RW, default = 1'b1  */
    UINT32 rsvd_5 : 2;
    /* rsvd_5 - Bits[6:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 use_allocating_flow_wr : 1;
    /* use_allocating_flow_wr - Bits[7:7], RW, default = 1'b1  */
    UINT32 outstanding_requests_gen2 : 6;
    /* outstanding_requests_gen2 - Bits[13:8], RW, default = 6'b110000 
       Number of outstanding RFOs and non-posted requests from a given PCIe port.
       This register controls the number of outstanding inbound non-posted requests - 
       I/O, Config, Memory - (maximum length of these requests is a single 64B 
       cacheline) that a Gen2 PCI Express downstream port can have. This register 
       provides the value for the port when it is operating in Gen2 mode and for a link 
       width of x4. BIOS programs this register based on the read latency to main 
       memory. 
       This register also specifies the number of RFOs that can be kept outstanding on 
       IDI for a given port. 
       The link speed of the port can change during a PCI Express hotplug event and the 
       port must use the appropriate multiplier. 
       A value of 1 indicates one outstanding pre-allocated request, 2 indicates two 
       outstanding pre-allocated requests, and so on. If software programs a value 
       greater than the buffer size the DMA engine supports, then the maximum hardware 
       supported value is used. 
       Current BIOS recommendation is to leave this field at it's default value.
     */
    UINT32 rsvd_14 : 2;
    /* rsvd_14 - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outstanding_requests_gen1 : 5;
    /* outstanding_requests_gen1 - Bits[20:16], RW, default = 5'b11000 
       Number of outstanding RFOs and non-posted requests from a given PCIe port.
       This register controls the number of outstanding inbound non-posted requests - 
       I/O, Config, Memory - (maximum length of these requests is a single 64B 
       cacheline) that a Gen1 PCI Express downstream port can have. This register 
       provides the value for the port when it is operating in Gen1 mode and for a link 
       width of x4. BIOS programs this register based on the read latency to main 
       memory. 
       This register also specifies the number of RFOs that can be kept outstanding on 
       IDI for a given port. 
       The link speed of the port can change during a PCI Express hotplug event and the 
       port must use the appropriate multiplier. 
       A value of 1 indicates one outstanding pre-allocated request, 2 indicates two 
       outstanding pre-allocated requests, and so on. If software programs a value 
       greater than the buffer size the DMA engine supports, then the maximum hardware 
       supported value is used. 
       Current BIOS recommendation is to leave this field at it's default value.
     */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PERFCTRLSTS_1_IIO_PCIENTB_REG supported on:                                */
/*       IVT_EP (0x40018184)                                                  */
/*       IVT_EX (0x40018184)                                                  */
/*       HSX (0x40018184)                                                     */
/*       BDX (0x40018184)                                                     */
/* Register default value:              0x00000000                            */
#define PERFCTRLSTS_1_IIO_PCIENTB_REG 0x10004184


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x184
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[3:3], RW, default = 1'b0  */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dca_reqid_override : 1;
    /* dca_reqid_override - Bits[8:8], RW, default = 1'b0  */
    UINT32 tphdis : 1;
    /* tphdis - Bits[9:9], RW, default = 1'b0  */
    UINT32 partial_cohrd_op : 2;
    /* partial_cohrd_op - Bits[11:10], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need less than 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 full_cohrd_op : 2;
    /* full_cohrd_op - Bits[13:12], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need all 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_1_IIO_PCIENTB_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* MISCCTRLSTS_0_IIO_PCIENTB_REG supported on:                                */
/*       IVT_EP (0x40018188)                                                  */
/*       IVT_EX (0x40018188)                                                  */
/*       HSX (0x40018188)                                                     */
/*       BDX (0x40018188)                                                     */
/* Register default value:              0x60101000                            */
#define MISCCTRLSTS_0_IIO_PCIENTB_REG 0x10004188
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Miscellaneous Control and Status 0
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 inbound_configuration_enable : 1;
    /* inbound_configuration_enable - Bits[1:1], RW_O, default = 1'b0 
       Enable Inbound Configuration Requests.
     */
    UINT32 enable_acpi_mode_for_pm : 1;
    /* enable_acpi_mode_for_pm - Bits[2:2], RW, default = 1'b0 
       Applies only to root ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, all PM events at the PCI Express 
       port are handled via _PMEGPE messages to the PCH, and no MSI interrupts are ever 
       generated for PM events at the root port (regardless of whether MSI is enabled 
       at the root port or not). When clear, _PMEGPE message generation for PM events 
       is disabled and OS can chose to generate MSI interrupts for delivering PM events 
       by setting the MSI enable bit in root ports. This bit does not apply to the DMI 
       ports. Refer to PCI Express Base Specification, Revision 2.0 for details of MSI 
       and GPE Clearing this bit (from being 1) schedules a Deassert_PMEGPE event on 
       behalf of the root port, provided there was any previous Assert_PMEGPE message 
       that was sent without an associated Deassert message. Note that this bit applies 
       to Dev#3/Fn#0 in NTB mode as well and BIOS needs to set it up appropriately in 
       that mode. 
     */
    UINT32 enable_acpi_mode_for_hotplug : 1;
    /* enable_acpi_mode_for_hotplug - Bits[3:3], RW, default = 1'b0 
       Applies only to root ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, all hotplug events from the PCI 
       Express port are handled via _HPGPE messages to the PCH and no MSI/INTx messages 
       are ever generated for hotplug events (regardless of whether MSI or INTx is 
       enabled at the root port or not) at the root port. When this bit is clear, 
       _HPGPE message generation on behalf of root port hotplug events is disabled and 
       OS can chose to generate MSI or INTx interrupt for hotplug events, by setting 
       the MSI enable bit in root ports. This bit does not apply to the DMI ports. 
       Refer to PCI Express Base Specification, Revision 2.0 for details of MSI and GPE 
       message generation for hotplug events. Clearing this bit (from being 1) 
       schedules a Deassert_HPGPE event on behalf of the root port, provided there was 
       any previous Assert_HPGPE message that was sent without an associated Deassert 
       message. Note that this bit applies to Dev#3/Fn#0 in NTB mode as well and BIOS 
       needs to set it up appropriately in that mode. 
     */
    UINT32 enable_system_error_only_for_aer : 1;
    /* enable_system_error_only_for_aer - Bits[4:4], RW, default = 1'b0 
       Applies only to root/NTB ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, the PCI Express errors do not 
       trigger an MSI or Intx interrupt, regardless of the whether MSI or INTx is 
       enabled or not. Whether or not PCI Express errors result in a system event like 
       NMI/SMI/PMI/CPEI is dependent on whether the appropriate system error or 
       override system error enable bits are set or not. When this bit is clear, PCI 
       Express errors are reported via MSI or INTx and/or NMI/SMI/MCA/CPEI. When this 
       bit is clear and if MSI enable bit in the MSI Control Register (MSICTRL)is set 
       (clear), then an MSI (INTx) interrupt is generated for PCI Express errors. When 
       this bit is clear, and 'System Error on Fatal Error Enable' bit in ROOTCON 
       register is set, then NMI/SMI/MCA is (also) generated for a PCI Express fatal 
       error. Similar behavior for non-fatal and corrected errors. Note that this bit 
       applies to Dev#3/Fn#0 in NTB mode as well and BIOS needs to set it up 
       appropriately in that mode. 
     */
    UINT32 send_pme_turn_off_message : 1;
    /* send_pme_turn_off_message - Bits[5:5], RW_V, default = 1'b0 
       When this bit is written with a 1b, IIO sends a PME_TURN_OFF message to the PCIE 
       link. Hardware clears this bit when the message has been sent on the link. 
     */
    UINT32 enable_timeout_for_receiving_pme_to_ack : 1;
    /* enable_timeout_for_receiving_pme_to_ack - Bits[6:6], RW, default = 1'b0 
       Enable timeout for receiving PME_TO_ACK.
       When set, IIO enables the timeout to receiving the PME_TO_ACK.
     */
    UINT32 pme2acktoctrl : 2;
    /* pme2acktoctrl - Bits[8:7], RW, default = 2'b00  */
    UINT32 dispdspolling : 1;
    /* dispdspolling - Bits[9:9], RWS, default = 1'b0 
       Disables gen2 if timeout happens in polling.cfg.
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_ob_parity_check : 1;
    /* disable_ob_parity_check - Bits[12:12], RWS, default = 1'b1  */
    UINT32 tlp_on_any_lane : 1;
    /* tlp_on_any_lane - Bits[13:13], RWS, default = 1'b0  */
    UINT32 allow_one_np_os : 1;
    /* allow_one_np_os - Bits[14:14], RWS, default = 1'b0  */
    UINT32 dis_hdr_storage : 1;
    /* dis_hdr_storage - Bits[15:15], RWS, default = 1'b0  */
    UINT32 force_ep_biterr : 1;
    /* force_ep_biterr - Bits[16:16], RO, default = 1'b0 
       Force EP Bit Error (Poison Bit).
     */
    UINT32 force_data_perr : 1;
    /* force_data_perr - Bits[17:17], RO, default = 1'b0 
       Force Data Parity Error.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[18:18], RWS, default = 1'b0 
       Disable Read Completion Combining
       When set, all completions are returned without combining. Completions are 
       naturally broken on cacheline boundaries, so all completions will be 64B or 
       less. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maltlp_32baddr64bhdr_en : 1;
    /* maltlp_32baddr64bhdr_en - Bits[20:20], RW, default = 1'b1 
       Malformed TLP 32b address in 64b header Enable
       When set, enables reporting a Malformed packet when the TLP is a 32 bit address 
       in a 4DW header. PCI Express forbids using 4DW header sizes when the address is 
       less than 4GB, but some cards may use the 4DW header anyway. In these cases, the 
       upper 32 bits of address are all 0. 
     */
    UINT32 zero_ob_tc : 1;
    /* zero_ob_tc - Bits[21:21], RW_O, default = 1'b0 
       Force Outbound TC to Zero
       Forces the TC field to zero for outbound requests.
       1: TC is forced to zero on all outbound transactions regardless of the source TC 
       value 
       0: TC is not altered
       In DMI mode, TC is always forced to zero and this bit has no effect.
       
     */
    UINT32 check_cpl_tc : 1;
    /* check_cpl_tc - Bits[22:22], RWS, default = 1'b0  */
    UINT32 phold_disable : 1;
    /* phold_disable - Bits[23:23], RW, default = 1'b0 
       Applies only to Dev#0
       When set, the IIO responds with Unsupported request on receiving assert_phold 
       message from ICH and results in generating a fatal error. 
     */
    UINT32 peer2peer_memory_read_disable : 1;
    /* peer2peer_memory_read_disable - Bits[24:24], RW, default = 1'b0 
       When set, peer2peer memory reads are master aborted otherwise they are allowed 
       to progress per the peer2peer decoding rules. 
     */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 eoifd : 1;
    /* eoifd - Bits[26:26], RW_LV, default = 1'b0 
       EOI Forwarding Disable - Disable EOI broadcast to this PCIE link
       When set, EOI message will not be broadcast down this PCIE link. When clear, the 
       port is a valid target for EOI broadcast. BIOS must set this bit on a port if it 
       is connected to a another processor NTB or root port on other end of the link. 
     */
    UINT32 system_interrupt_only_on_link_bw_management_status : 1;
    /* system_interrupt_only_on_link_bw_management_status - Bits[27:27], RWS, default = 1'b0  */
    UINT32 to_dis : 1;
    /* to_dis - Bits[28:28], RW, default = 1'b0 
       Disables timeouts completely.
     */
    UINT32 cfg_to_en : 1;
    /* cfg_to_en - Bits[29:29], RW, default = 1'b1 
       Disables/enables config timeouts, independently of other timeouts.
     */
    UINT32 inbound_io_disable : 1;
    /* inbound_io_disable - Bits[30:30], RW_O, default = 1'b1 
       Disable Inbound IO Requests.
     */
    UINT32 disable_l0s_on_transmitter : 1;
    /* disable_l0s_on_transmitter - Bits[31:31], RW, default = 1'b0 
       When set, IIO never puts its tx in L0s state, even if OS enables it via the Link 
       Control register. L0s is not supported on the processor. 
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* MISCCTRLSTS_1_IIO_PCIENTB_REG supported on:                                */
/*       IVT_EP (0x4001818C)                                                  */
/*       IVT_EX (0x4001818C)                                                  */
/*       HSX (0x4001818C)                                                     */
/*       BDX (0x4001818C)                                                     */
/* Register default value:              0x00000000                            */
#define MISCCTRLSTS_1_IIO_PCIENTB_REG 0x1000418C
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0  */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 rsvd_5 : 1;
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0  */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0  */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 rsvd_18 : 14;
    /* rsvd_18 - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Miscellaneous Control and Status 1
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0 
       When set, correctable errors on PCI Express (that have been successfully 
       propagated to the primary interface of the port) are sent to the IIO core error 
       logic (for further escalation) regardless of the setting of the equivalent bit 
       in the ROOTCTRL register. When clear, the correctable errors are only propagated 
       to the IIO core error logic if the equivalent bit in ROOTCTRL register is set. 
       For Dev#0 in DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link 
       related correctable errors will never be notified to system software. 
     */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0 
       When set, non-fatal errors on PCI Express (that have been successfully 
       propagated to the primary interface of the port) are sent to the IIO core error 
       logic (for further escalation) regardless of the setting of the equivalent bit 
       in the ROOTCTRL register. When clear, the non-fatal errors are only propagated 
       to the IIO core error logic if the equivalent bit in ROOTCTRL register is set. 
       For Dev#0 in DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link 
       related non-fatal errors will never be notified to system software. 
     */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0 
       When set, fatal errors on PCI Express (that have been successfully propagated to 
       the primary interface of the port) are sent to the IIO core error logic (for 
       further escalation) regardless of the setting of the equivalent bit in the 
       ROOTCTRL register. When clear, the fatal errors are only propagated to the IIO 
       core error logic if the equivalent bit in ROOTCTRL register is set. For Dev#0 in 
       DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link related fatal 
       errors will never be notified to system software. 
     */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 disable_mctp_broadcast_to_this_link : 1;
    /* disable_mctp_broadcast_to_this_link - Bits[5:5], RW, default = 1'b0  */
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0 
       This bit is set by BIOS when it knows that this port is connected to a device 
       that creates Posted-Posted dependency on its In-Out queues. 
       Briefly, this bit is set on a link if:
       This link is connected to a processor RP or processor NTB port on the other side 
       of the link. 
       This link is connected to a port or device that creates Posted-Posted dependency 
       on its In-Out queues. 
       IIO lock flows depend on the setting of this bit to treat this port in a special 
       way during the flows. Note that if BIOS is setting up the lock flow to be in the 
       'QPI compatible' mode then this bit must be set to 0. 
       An inbound MSI request can block the posted channel until EOI's are posted to 
       all outbound queues enabled to receive EOI. Because of this, this bit cannot be 
       set unless EOIFD is also set. 
     */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0 
       For TPH/DCA requests, the Completer ID can be returned with SocketID when this 
       bit is set. 
     */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0 
       Indicates that IIO received a PME turn off ack packet or it timed out waiting 
       for the packet. 
     */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0 
       Indicates that a locked read request incurred a completion time-out on PCI 
       Express/DMI. 
     */
    UINT32 rsvd_18 : 12;
    /* rsvd_18 - Bits[29:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_sending_pme_to_port : 1;
    /* disable_sending_pme_to_port - Bits[30:30], RW, default = 1'b0  */
    UINT32 mimic_pme_to_ack_received : 1;
    /* mimic_pme_to_ack_received - Bits[31:31], RW, default = 1'b0  */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* PCIE_IOU_BIF_CTRL_IIO_PCIENTB_REG supported on:                            */
/*       IVT_EP (0x20018190)                                                  */
/*       IVT_EX (0x20018190)                                                  */
/*       HSX (0x20018190)                                                     */
/*       BDX (0x20018190)                                                     */
/* Register default value:              0x0004                                */
#define PCIE_IOU_BIF_CTRL_IIO_PCIENTB_REG 0x10002190
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU.  
 */
typedef union {
  struct {
    UINT16 iou_bifurcation_control : 3;
    /* iou_bifurcation_control - Bits[2:0], RWS, default = 3'b100 
       To select a IOU bifurcation, software sets this field and then either:
       a) sets bit 3 in this register to initiate training OR
       b) resets the entire processor and on exit from that reset
       
       The processor will bifurcate the ports per the setting in this field.
       
       For x8 ports:
       000: x4x4 (operate lanes 7:4 as x4, 3:0 as x4)
       001: x8
       others: Reserved
       
       For x16 ports:
       000: x4x4x4x4 (operate lanes 15:12 as x4, 11:8 as x4, 7:4 as x4 and 3:0 as x4)
       001: x4x4x8 (operate lanes 15:12 as x4, 11:8 as x4 and 7:0 as x8)
       010: x8x4x4 (operate lanes 15:8 as x8, 7:4 as x4 and 3:0 as x4)
       011: x8x8 (operate lanes 15:8 as x8, 7:0 as x8)
       100: x16
       others: Reserved
     */
    UINT16 iou_start_bifurcation : 1;
    /* iou_start_bifurcation - Bits[3:3], WO, default = 1'b0 
       When software writes a 1 to this bit, IIO starts the port 0 bifurcation process. 
       After writing to this bit, software can poll the Data Link Layer link active bit 
       in the LNKSTS register to determine if a port is up and running. Once a port 
       bifurcation has been initiated by writing a 1 to this bit, software cannot 
       initiate any more write-1 to this bit (write of 0 is ok). 
       Notes:
       That this bit can be written to a 1 in the same write that changes values for 
       bits 2:0 in this register and in that case, the new value from the write to bits 
       2:0 take effect. 
       This bit always reads a 0b.
     */
    UINT16 rsvd : 12;
    /* rsvd - Bits[15:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCIE_IOU_BIF_CTRL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* NTBDEVCAP_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x40018194)                                                  */
/*       IVT_EX (0x40018194)                                                  */
/*       HSX (0x40018194)                                                     */
/*       BDX (0x40018194)                                                     */
/* Register default value:              0x00008C21                            */
#define NTBDEVCAP_IIO_PCIENTB_REG 0x10004194
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x194
 */
typedef union {
  struct {
    UINT32 max_payload_size_supported : 3;
    /* max_payload_size_supported - Bits[2:0], RO, default = 3'b001  */
    UINT32 phantom_functions_supported : 2;
    /* phantom_functions_supported - Bits[4:3], RO, default = 2'b00  */
    UINT32 extended_tag_field_supported : 1;
    /* extended_tag_field_supported - Bits[5:5], RW_O, default = 1'b1  */
    UINT32 endpoint_l0s_acceptable_latency : 3;
    /* endpoint_l0s_acceptable_latency - Bits[8:6], RW_O, default = 3'b000 
       L0s is not supported on the processor.
     */
    UINT32 endpoint_l1_acceptable_latency : 3;
    /* endpoint_l1_acceptable_latency - Bits[11:9], RW_O, default = 3'b110  */
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[12:12], RO, default = 1'b0  */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[13:13], RO, default = 1'b0  */
    UINT32 power_indicator_present_on_device : 1;
    /* power_indicator_present_on_device - Bits[14:14], RO, default = 1'b0  */
    UINT32 role_based_error_reporting : 1;
    /* role_based_error_reporting - Bits[15:15], RO, default = 1'b1  */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 captured_slot_power_limit_value : 8;
    /* captured_slot_power_limit_value - Bits[25:18], RO, default = 8'b00000000  */
    UINT32 captured_slot_power_limit_scale : 2;
    /* captured_slot_power_limit_scale - Bits[27:26], RO, default = 2'b00  */
    UINT32 function_level_reset_capability : 1;
    /* function_level_reset_capability - Bits[28:28], RO, default = 1'b0  */
    UINT32 rsvd_29 : 3;
    /* rsvd_29 - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} NTBDEVCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNKCAP_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x4001819C)                                                  */
/*       IVT_EX (0x4001819C)                                                  */
/*       HSX (0x4001819C)                                                     */
/*       BDX (0x4001819C)                                                     */
/* Register default value:              0x00793843                            */
#define LNKCAP_IIO_PCIENTB_REG 0x1000419C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The Link Capabilities register identifies the PCI Express specific link 
 * capabilities. The link capabilities register needs some default values setup by 
 * the local host. This register is relocated to the enhanced configuration space 
 * region in while in NTB mode. 
 */
typedef union {
  struct {
    UINT32 maxlnkspd : 4;
    /* maxlnkspd - Bits[3:0], RW_O, default = 4'b0011 
       This field indicates the maximum link speed of this Port.
       The encoding is the binary value of the bit location in the Supported Link 
       Speeds Vector (in LNKCAP2) that corresponds to the maximum link speed. 
       0001b = (2.5Gbps)
       0010b = (5Gbps)
       0011b = (8Gbps)
     */
    UINT32 maximum_link_width : 6;
    /* maximum_link_width - Bits[9:4], RW_O, default = 6'b000100 
       This field indicates the maximum width of the given PCI Express Link attached to 
       the port. 
       000001: x1
       000010: x2
       000100: x4
       001000: x8
       010000: x16
       Others: Reserved
       
       This is left as a RW-O register for bios to update based on the platform usage 
       of the links. 
     */
    UINT32 active_state_link_pm_support : 2;
    /* active_state_link_pm_support - Bits[11:10], RW_O, default = 2'b10 
       This field indicates the level of active state power management supported on the 
       given PCI-Express port. 
       00: Disabled
       01: L0s Entry Supported
       10: L1 Entry Supported (Gen3; spec allows 0x2)
       11: L0s and L1 Supported
       L0s is not supported on the processor.
     */
    UINT32 l0s_exit_latency : 3;
    /* l0s_exit_latency - Bits[14:12], RW_O, default = 3'b011 
       This field indicates the L0s exit latency (i.e L0s to L0) for the PCI-Express 
       port. 
       L0s is not supported on the processor.
     */
    UINT32 l1_exit_latency : 3;
    /* l1_exit_latency - Bits[17:15], RW_O, default = 3'b010 
       This field indicates the L1 exit latency for the given PCI-Express port. It 
       indicates the length of time this port requires to complete transition from L1 
       to L0. 
       000: Less than 1us
       001: 1 us to less than 2 us
       010: 2 us to less than 4 us
       011: 4 us to less than 8 us
       100: 8 us to less than 16 us
       101: 16 us to less than 32 us
       110: 32 us to 64 us
       111: More than 64us
       
       This register is made writable once by BIOS so that the value is settable based 
       on experiments post-si. 
     */
    UINT32 clock_power_management : 1;
    /* clock_power_management - Bits[18:18], RO, default = 1'b0 
       Does not apply to processor
     */
    UINT32 surprise_down_error_reporting_capable : 1;
    /* surprise_down_error_reporting_capable - Bits[19:19], RO, default = 1'b1 
       IIO supports reporting a surprise down error condition
     */
    UINT32 data_link_layer_link_active_reporting_capable : 1;
    /* data_link_layer_link_active_reporting_capable - Bits[20:20], RO, default = 1'b1 
       IIO supports reporting status of the data link layer so software knows when it 
       can enumerate a device on the link or otherwise know the status of the link. 
     */
    UINT32 link_bandwidth_notification_capability : 1;
    /* link_bandwidth_notification_capability - Bits[21:21], RO_V, default = 1'b1 
       A value of 1b indicates support for the Link Bandwidth Notification status and 
       interrupt mechanisms. 
     */
    UINT32 aspm_optionality_compliance : 1;
    /* aspm_optionality_compliance - Bits[22:22], RW_O, default = 1'b1  */
    UINT32 rsvd : 1;
    /* rsvd - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 port_number : 8;
    /* port_number - Bits[31:24], RW_O, default = 8'b00000000 
       This field indicates the PCI Express port number for the link and is initialized 
       by software/BIOS. IIO hardware does nothing with this bit. 
     */
  } Bits;
  UINT32 Data;
} LNKCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNKCON_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x200181A0)                                                  */
/*       IVT_EX (0x200181A0)                                                  */
/*       HSX (0x200181A0)                                                     */
/*       BDX (0x200181A0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON_IIO_PCIENTB_REG 0x100021A0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The PCI Express Link Control register controls the PCI Express Link specific 
 * parameters. The link control register needs some default values setup by the 
 * local host. This register is relocated to the enhanced configuration space 
 * region in while in NTB mode. In NTB/RP mode RP will program this register. In 
 * NTB/NTB mode local host BIOS will program this register 
 */
typedef union {
  struct {
    UINT16 active_state_link_pm_control : 2;
    /* active_state_link_pm_control - Bits[1:0], RW_V, default = 2'b00  */
    UINT16 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 read_completion_boundary : 1;
    /* read_completion_boundary - Bits[3:3], RO, default = 1'b0 
       Set to zero to indicate IIO could return read completions at 64B boundaries.
     */
    UINT16 link_disable : 1;
    /* link_disable - Bits[4:4], RW, default = 1'b0  */
    UINT16 retrain_link : 1;
    /* retrain_link - Bits[5:5], WO, default = 1'b0  */
    UINT16 common_clock_configuration : 1;
    /* common_clock_configuration - Bits[6:6], RW_V, default = 1'b0  */
    UINT16 extended_synch : 1;
    /* extended_synch - Bits[7:7], RW, default = 1'b0  */
    UINT16 enable_clock_power_management : 1;
    /* enable_clock_power_management - Bits[8:8], RO, default = 1'b0  */
    UINT16 hardware_autonomous_width_disable : 1;
    /* hardware_autonomous_width_disable - Bits[9:9], RW, default = 1'b0  */
    UINT16 link_bandwidth_management_interrupt_enable : 1;
    /* link_bandwidth_management_interrupt_enable - Bits[10:10], RW, default = 1'b0 
       For root ports, when set to 1b this bit enables the generation of an interrupt 
       to indicate that the Link Bandwidth Management Status bit has been set. For DMI 
       mode on Dev#0, interrupt is not supported and hence this bit is not useful. 
       Expectation is that BIOS will set bit 27 to notify the system of autonomous BW 
       change event on that port per BIOS Writers Guide. 
     */
    UINT16 link_autonomous_bandwidth_interrupt_enable : 1;
    /* link_autonomous_bandwidth_interrupt_enable - Bits[11:11], RW, default = 1'b0 
       For root ports, when set to 1b this bit enables the generation of an interrupt 
       to indicate that the Link Autonomous Bandwidth Status bit has been set. For DMI 
       mode on Dev#0, interrupt is not supported and hence this bit is not useful. 
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKCON_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNKSTS_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x200181A2)                                                  */
/*       IVT_EX (0x200181A2)                                                  */
/*       HSX (0x200181A2)                                                     */
/*       BDX (0x200181A2)                                                     */
/* Register default value:              0x1001                                */
#define LNKSTS_IIO_PCIENTB_REG 0x100021A2
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1a2
 */
typedef union {
  struct {
    UINT16 current_link_speed : 4;
    /* current_link_speed - Bits[3:0], RO_V, default = 4'b0001  */
    UINT16 negotiated_link_width : 6;
    /* negotiated_link_width - Bits[9:4], RO_V, default = 6'b000000  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 link_training : 1;
    /* link_training - Bits[11:11], RO_V, default = 1'b0  */
    UINT16 slot_clock_configuration : 1;
    /* slot_clock_configuration - Bits[12:12], RW_O, default = 1'b1  */
    UINT16 data_link_layer_link_active : 1;
    /* data_link_layer_link_active - Bits[13:13], RO_V, default = 1'b0  */
    UINT16 link_bandwidth_management_status : 1;
    /* link_bandwidth_management_status - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_status : 1;
    /* link_autonomous_bandwidth_status - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} LNKSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SLTCAP_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x400181A4)                                                  */
/*       IVT_EX (0x400181A4)                                                  */
/*       HSX (0x400181A4)                                                     */
/*       BDX (0x400181A4)                                                     */
/* Register default value:              0x00000000                            */
#define SLTCAP_IIO_PCIENTB_REG 0x100041A4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The Slot Capabilities register identifies the PCI Express specific slot 
 * capabilities. 
 */
typedef union {
  struct {
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[0:0], RW_O, default = 1'b0 
       This bit indicates that the Attention Button event signal is routed (from slot 
       or on-board in the chassis) to the IIO's hotplug controller. 
       0: indicates that an Attention Button signal is routed to IIO
       1: indicates that an Attention Button is not routed to IIO
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_controller_present : 1;
    /* power_controller_present - Bits[1:1], RW_O, default = 1'b0 
       This bit indicates that a software controllable power controller is implemented 
       on the chassis for this slot. 
       0: indicates that a software controllable power controller is not present
       1: indicates that a software controllable power controller is present
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 mrl_sensor_present : 1;
    /* mrl_sensor_present - Bits[2:2], RW_O, default = 1'b0 
       This bit indicates that an MRL Sensor is implemented on the chassis for this 
       slot. 
       0: indicates that an MRL Sensor is not present
       1: indicates that an MRL Sensor is present
       BIOS programs this field with a 0 for Express Module FF always. If CEM slot is 
       hotplug capable, BIOS programs this field with either 0 or 1 depending on system 
       design. 
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[3:3], RW_O, default = 1'b0 
       This bit indicates that an Attention Indicator is implemented for this slot and 
       is electrically controlled by the chassis 
       0: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_indicator_present : 1;
    /* power_indicator_present - Bits[4:4], RW_O, default = 1'b0 
       This bit indicates that a Power Indicator is implemented for this slot and is 
       electrically controlled by the chassis. 
       0: indicates that a Power Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that Power Indicator that is electrically controlled by the chassis 
       is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 hot_plug_surprise : 1;
    /* hot_plug_surprise - Bits[5:5], RW_O, default = 1'b0 
       This field indicates that a device in this slot may be removed from the system 
       without prior notification. This field is initialized by BIOS. 
       0: indicates that hot-plug surprise is not supported
       1: indicates that hot-plug surprise is supported
       Generally this bit is not expected to be set because the only know usage case 
       for this is the ExpressCard FF. But that is not really expected usage in the 
       processor context. But this bit is present regardless to allow a usage if it 
       arises. 
       This bit is used by IIO hardware to determine if a transition from DL_active to 
       DL_Inactive is to be treated as a surprise down error or not. If a port is 
       associated with a hotpluggable slot and the hotplug surprise bit is set, then 
       any transition to DL_Inactive is not considered an error. Refer to PCI Express 
       Base Specification, Revision 2.0 for further details. 
     */
    UINT32 hot_plug_capable : 1;
    /* hot_plug_capable - Bits[6:6], RW_O, default = 1'b0 
       This field defines hot-plug support capabilities for the PCI Express port.
       0: indicates that this slot is not capable of supporting Hot-plug operations.
       1: indicates that this slot is capable of supporting Hot-plug operations
       This bit is programed by BIOS based on the system design. This bit must be 
       programmed by bios to be consistent with the VPP enable bit for the port. 
     */
    UINT32 slot_power_limit_value : 8;
    /* slot_power_limit_value - Bits[14:7], RW_O, default = 8'b00000000 
       This field specifies the upper limit on power supplied by slot in conjunction 
       with the Slot Power Limit Scale value. This field is initialized by BIOS. IIO 
       uses this field when it sends a Set_Slot_Power_Limit message on PCI Express. 
       Writes to this register trigger a Set_Slot_Power_Limit message to be sent. The 
       IIO sends the Set_Slot_Power_Limit message on the link at first link up 
       condition (except on the DMI link operating in DMI mode) without regards to 
       whether this register and the Slot Power Limit Scale register are programmed yet 
       by BIOS. 
     */
    UINT32 slot_power_limit_scale : 2;
    /* slot_power_limit_scale - Bits[16:15], RW_O, default = 2'b00 
       This field specifies the scale used for the Slot Power Limit Value and is 
       initialized by BIOS. IIO uses this field when it sends a Set_Slot_Power_Limit 
       message on PCI Express. 
       Range of Values:
       00: 1.0x
       01: 0.1x
       10: 0.01x
       11: 0.001x
       Writes to this register trigger a Set_Slot_Power_Limit message to be sent.
     */
    UINT32 electromechanical_interlock_present : 1;
    /* electromechanical_interlock_present - Bits[17:17], RW_O, default = 1'b0 
       This bit when set indicates that an Electromechanical Interlock is implemented 
       on the chassis for this slot and that lock is controlled by bit 11 in Slot 
       Control register. This field is initialized by BIOS based on the system 
       architecture. 
       BIOS note: this capability is not set if the Electromechanical Interlock control 
       is connected to main slot power control. 
       This is expected to be used only for Express Module hotpluggable slots.
     */
    UINT32 command_complete_not_capable : 1;
    /* command_complete_not_capable - Bits[18:18], RO, default = 1'b0 
       The processor is capable of command complete interrupt.
     */
    UINT32 physical_slot_number : 13;
    /* physical_slot_number - Bits[31:19], RW_O, default = 13'b0000000000000 
       This field indicates the physical slot number of the slot connected to the PCI 
       Express port and is initialized by BIOS. 
     */
  } Bits;
  UINT32 Data;
} SLTCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SLTCON_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x200181A8)                                                  */
/*       IVT_EX (0x200181A8)                                                  */
/*       HSX (0x200181A8)                                                     */
/*       BDX (0x200181A8)                                                     */
/* Register default value:              0x07C0                                */
#define SLTCON_IIO_PCIENTB_REG 0x100021A8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The Slot Control register identifies the PCI Express specific slot control 
 * parameters for operations such as Hot-plug and Power Management. 
 * 
 * Warning: Any write to this register will set the Command Completed bit in the 
 * SLTSTS register, ONLY if the VPP enable bit for the port is set. If the port's 
 * VPP enable bit is set (i.e. hotplug for that slot is enabled), then the required 
 * actions on VPP are completed before the Command Completed bit is set in the 
 * SLTSTS register. If the VPP enable bit for the port is clear, then the write 
 * simply updates this register (see individual bit definitions for details) but 
 * the Command Completed bit in the SLTSTS register is not set 
 */
typedef union {
  struct {
    UINT16 attention_button_pressed_enable : 1;
    /* attention_button_pressed_enable - Bits[0:0], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via an 
       attention button pressed event. 
       0: disables generation of hot-plug interrupts or wake messages when the 
       attention button is pressed. 
       1: Enables generation of hot-plug interrupts or wake messages when the attention 
       button is pressed. 
     */
    UINT16 power_fault_detected_enable : 1;
    /* power_fault_detected_enable - Bits[1:1], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       power fault event. 
       0: disables generation of hot-plug interrupts or wake messages when a power 
       fault event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when a power fault 
       event happens. 
     */
    UINT16 mrl_sensor_changed_enable : 1;
    /* mrl_sensor_changed_enable - Bits[2:2], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       MRL Sensor changed event. 
       0: disables generation of hot-plug interrupts or wake messages when an MRL 
       Sensor changed event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when an MRL Sensor 
       changed event happens. 
     */
    UINT16 presence_detect_changed_enable : 1;
    /* presence_detect_changed_enable - Bits[3:3], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       presence detect changed event. 
       0: disables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
       1- Enables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
     */
    UINT16 command_completed_interrupt_enable : 1;
    /* command_completed_interrupt_enable - Bits[4:4], RW, default = 1'b0 
       This field enables software notification (Interrupt - MSI/INTx or WAKE) when a 
       command is completed by the Hot-plug controller connected to the PCI Express 
       port 
       0: disables hot-plug interrupts on a command completion by a hot-plug Controller
       1: Enables hot-plug interrupts on a command completion by a hot-plug Controller
     */
    UINT16 hot_plug_interrupt_enable : 1;
    /* hot_plug_interrupt_enable - Bits[5:5], RW, default = 1'b0 
       When set to 1b, this bit enables generation of Hot-Plug interrupt (MSI or INTx 
       interrupt depending on the setting of the MSI enable bit on enabled Hot-Plug 
       events, provided ACPI mode for hotplug is disabled. 
       0: disables interrupt generation on Hot-plug events
       1: enables interrupt generation on Hot-plug events
     */
    UINT16 attention_indicator_control : 2;
    /* attention_indicator_control - Bits[7:6], RW, default = 2'b11 
       If an Attention Indicator is implemented, writes to this field will set the 
       Attention Indicator to the written state. Reads of this field reflect the value 
       from the latest write, even if the corresponding hot-plug command is not 
       executed yet at the VPP, unless software issues a write without waiting for the 
       previous command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (Processor drives 1 Hz square wave)
       11: Off
       IIO does not generated the Attention_Indicator_On/Off/Blink messages on PCI 
       Express when this field is written to by software. 
     */
    UINT16 power_indicator_control : 2;
    /* power_indicator_control - Bits[9:8], RW, default = 2'b11 
       If a Power Indicator is implemented, writes to this field will set the Power 
       Indicator to the written state. Reads of this field must reflect the value from 
       the latest write, even if the corresponding hot-plug command is not executed yet 
       at the VPP, unless software issues a write without waiting for the previous 
       command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (IIO drives 1 Hz square wave for Chassis mounted LEDs)
       11: Off
       IIO does not generated the Power_Indicator_On/Off/Blink messages on PCI Express 
       when this field is written to by software. 
     */
    UINT16 power_controller_control : 1;
    /* power_controller_control - Bits[10:10], RWS, default = 1'b1 
       If a power controller is implemented, when writes to this field will set the 
       power state of the slot per the defined encodings. Reads of this field must 
       reflect the value from the latest write, even if the corresponding hot-plug 
       command is not executed yet at the VPP, unless software issues a write without 
       waiting for the previous command to complete in which case the read value is 
       undefined. 
       0: Power On
       1: Power Off
       Note: If the link experiences an unexpected DL_Down condition that is not the 
       result of a Hot Plug removal, the processor follows the PCI Express 
       specification for logging Surprise Link Down. SW is required to set SLTCON[10] 
       to 0 (Power On) in all devices that do not connect to a slot that supports 
       Hot-Plug to enable logging of this error in that device. 
       For devices connected to slots supporting Hot-Plug operations, SLTCON[10] usage 
       to control PWREN# assertion is as described elsewhere. 
     */
    UINT16 electromechanical_interlock_control : 1;
    /* electromechanical_interlock_control - Bits[11:11], RW, default = 1'b0 
       When software writes either a 1 to this bit, IIO pulses the EMIL pin per PCI 
       Express Server/Workstation Module Electromechanical Spec Rev 1.0. Write of 0 has 
       no effect. This bit always returns a 0 when read. If electromechanical lock is 
       not implemented, then either a write of 1 or 0 to this register has no effect. 
     */
    UINT16 data_link_layer_state_changed_enable : 1;
    /* data_link_layer_state_changed_enable - Bits[12:12], RWS, default = 1'b0 
       When set to 1, this field enables software notification when Data Link Layer 
       Link Active bit in the LNKSTS register changes state 
     */
    UINT16 rsvd : 3;
    /* rsvd - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTCON_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* SLTSTS_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x200181AA)                                                  */
/*       IVT_EX (0x200181AA)                                                  */
/*       HSX (0x200181AA)                                                     */
/*       BDX (0x200181AA)                                                     */
/* Register default value:              0x0000                                */
#define SLTSTS_IIO_PCIENTB_REG 0x100021AA
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * The PCI Express Slot Status register defines important status information for 
 * operations such as Hot-plug and Power Management. 
 */
typedef union {
  struct {
    UINT16 attention_button_pressed : 1;
    /* attention_button_pressed - Bits[0:0], RW1C, default = 1'b0 
       This bit is set by IIO when the attention button is pressed. It is subsequently 
       cleared by software after the field has been read and processed.Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
       IIO silently discards the Attention_Button_Pressed message if received from PCI 
       Express link without updating this bit. 
     */
    UINT16 power_fault_detected : 1;
    /* power_fault_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit is set by IIO when a power fault event is detected by the power 
       controller (which is reported via the VPP bit stream). It is subsequently 
       cleared by software after the field has been read and processed. Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
     */
    UINT16 mrl_sensor_changed : 1;
    /* mrl_sensor_changed - Bits[2:2], RW1C, default = 1'b0 
       This bit is set if the value reported in bit 5 changes. It is subsequently 
       cleared by software after the field has been read and processed. 
     */
    UINT16 presence_detect_changed : 1;
    /* presence_detect_changed - Bits[3:3], RW1C, default = 1'b0 
       This bit is set by IIO when the value reported in bit 6 is changes. It is 
       subsequently cleared by software after the field has been read and processed. 
     */
    UINT16 command_completed : 1;
    /* command_completed - Bits[4:4], RW1C, default = 1'b0 
       This bit is set by IIO when the hot-plug command has completed and the hot-plug 
       controller is ready to accept a subsequent command. It is subsequently cleared 
       by software after the field has been read and processed. This bit provides no 
       guarantee that the action corresponding to the command is complete. Any write to 
       SLTCON (regardless of the port is capable or enabled for hot-plug) is considered 
       a 'hot-plug' command. 
       If the port is not hot-plug capable or hot-plug enabled, then the hot-plug 
       command does not trigger any action on the VPP port but the command is still 
       completed via this bit. 
     */
    UINT16 mrl_sensor_state : 1;
    /* mrl_sensor_state - Bits[5:5], RO_V, default = 1'b0 
       This bit reports the status of an MRL sensor if it is implemented.
       0: MRL Closed
       1: MRL Open
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 presence_detect_state : 1;
    /* presence_detect_state - Bits[6:6], RO_V, default = 1'b0 
       For ports with slots (where the Slot Implemented bit of the PCI Express 
       Capabilities Registers is 1b), this field is the logical OR of the Presence 
       Detect status determined via an in-band mechanism and sideband Present Detect 
       pins. Refer to how PCI Express Base Specification, Revision 2.0 for how the 
       inband presence detect mechanism works (certain states in the LTSSM constitute 
       'card present' and others don't). 
       0: Card/Module slot empty
       1: Card/module Present in slot (powered or unpowered)
       For ports with no slots, IIO hardwires this bit to 1b.
       Note: OS could get confused when it sees an empty PCI Express root port i.e. 'no 
       slots + no presence', since this is now disallowed in the spec. So bios must 
       hide all unused root ports devices in IIO config space, via the DEVHIDE 
       register. 
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 electromechanical_latch_status : 1;
    /* electromechanical_latch_status - Bits[7:7], RO_V, default = 1'b0 
       When read this register returns the current state of the Electromechanical 
       Interlock (the EMILS pin) which has the defined encodings as: 
       0: Electromechanical Interlock Disengaged
       1: Electromechanical Interlock Engaged
     */
    UINT16 data_link_layer_state_changed : 1;
    /* data_link_layer_state_changed - Bits[8:8], RW1C, default = 1'b0 
       This bit is set (if it is not already set) when the state of the Data Link Layer 
       Link Active bit in the Link Status register changes. Software must read Data 
       Link Layer Active field to determine the link state before initiating 
       configuration cycles to the hot plugged device. 
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ROOTCON_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x200181AC)                                                  */
/*       IVT_EX (0x200181AC)                                                  */
/*       HSX (0x200181AC)                                                     */
/*       BDX (0x200181AC)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCON_IIO_PCIENTB_REG 0x100021AC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT16 seceen : 1;
    /* seceen - Bits[0:0], RW, default = 1'b0 
       System Error on Correctable Error Enable
       This field controls notifying the internal IIO core error logic of the 
       occurrence of a correctable error in the device or below its hierarchy. The 
       internal core error logic of IIO then decides if/how to escalate the error 
       further (pins/message etc). 
       1: indicates that an internal core error logic notification should be generated 
       if a correctable error (ERR_COR) is reported by any of the devices in the 
       hierarchy associated with and including this port. 
       0: No internal core error logic notification should be generated on a 
       correctable error (ERR_COR) reported by any of the devices in the hierarchy 
       associated with and including this port. 
       Note that generation of system notification on a PCI Express correctable error 
       is orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a correctable error or software 
       can chose one of the two. 
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode correctable errors, BIOS must set MISCCTRLSTS[33] to a 1 to override 
       this bit on Device#0 in DMI mode. 
       
     */
    UINT16 senfeen : 1;
    /* senfeen - Bits[1:1], RW, default = 1'b0 
       System Error on Non-Fatal Error Enable
       This field enables notifying the internal IIO core error logic of occurrence of 
       an uncorrectable non-fatal error at the port or below its hierarchy. The 
       internal IIO core error logic then decides if/how to escalate the error further 
       (pins/message etc). 
       1: indicates that a internal IIO core error logic notification should be 
       generated if a non-fatal error (ERR_NONFATAL) is reported by any of the devices 
       in the hierarchy associated with and including this port. 
       0: No internal core error logic notification should be generated on a non-fatal 
       error (ERR_NONFATAL) reported by any of the devices in the hierarchy associated 
       with and including this port. 
       Note that generation of system notification on a PCI Express non-fatal error is 
       orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a non-fatal error or software can 
       chose one of the two. 
       
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode non-fatal errors, BIOS must set MISCCTRLSTS[34] to a 1 to override this 
       bit on Device#0 in DMI mode. 
     */
    UINT16 sefeen : 1;
    /* sefeen - Bits[2:2], RW, default = 1'b0 
       System Error on Fatal Error Enable
       This field enables notifying the internal IIO core error logic of occurrence of 
       an uncorrectable fatal error at the port or below its hierarchy. The internal 
       core error logic of IIO then decides if/how to escalate the error further 
       (pins/message etc). Refer to RAS Chapter for details of how/which system 
       notification is generated for a PCI Express fatal error. 
       1: indicates that an internal IIO core error logic notification should be 
       generated if a fatal error (ERR_FATAL) is reported by any of the devices in the 
       hierarchy associated with and including this port. 
       0: No internal IIO core error logic notification should be generated on a fatal 
       error (ERR_FATAL) reported by any of the devices in the hierarchy associated 
       with and including this port. 
       Note that generation of system notification on a PCI Express fatal error is 
       orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a fatal error or software can 
       chose one of the two. 
       Refer to PCI Express Base Specification, Revision 2.0 for details of how this 
       bit is used in conjunction with other error control bits to generate core logic 
       notification of error events in a PCI Express port. 
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode fatal errors, BIOS must set bit MISCCTRLSTS[35] to a 1 to override this 
       bit in DMI mode. 
     */
    UINT16 pmeinten : 1;
    /* pmeinten - Bits[3:3], RW_L, default = 1'b0 
       This field controls the generation of MSI interrupts/INTx interrupts for PME 
       messages. 
       
       1: Enables interrupt generation upon receipt of a PME message
       0: Disables interrupt generation for PME messages
     */
    UINT16 crsswvisen : 1;
    /* crsswvisen - Bits[4:4], RW, default = 1'b0 
       CRS software visibility Enable
       1: The Root Port to returns Configuration Request Retry Status (CRS) Completion 
       Status to software by returning data of 0x01 when a configuration retry is 
       returned by the connected device. 
       0: Retry status cannot be returned to software so the Configuration Request is 
       re-issued to the connected device, unless the Configuration Retry Timer expires. 
       If the timer expires, then a master abort response is returned to software. 
     */
    UINT16 rsvd : 11;
    /* rsvd - Bits[15:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCON_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ROOTCAP_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x200181AE)                                                  */
/*       IVT_EX (0x200181AE)                                                  */
/*       HSX (0x200181AE)                                                     */
/*       BDX (0x200181AE)                                                     */
/* Register default value:              0x0001                                */
#define ROOTCAP_IIO_PCIENTB_REG 0x100021AE
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1ae
 */
typedef union {
  struct {
    UINT16 crs_software_visibility : 1;
    /* crs_software_visibility - Bits[0:0], RO, default = 1'b1 
       This bit, when set, indicates that the Root Port is capable of returning 
       Configuration Request Retry Status (CRS) Completion Status to software. The 
       processor supports this capability. 
     */
    UINT16 rsvd : 15;
    /* rsvd - Bits[15:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ROOTSTS_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x400181B0)                                                  */
/*       IVT_EX (0x400181B0)                                                  */
/*       HSX (0x400181B0)                                                     */
/*       BDX (0x400181B0)                                                     */
/* Register default value:              0x00000000                            */
#define ROOTSTS_IIO_PCIENTB_REG 0x100041B0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1b0
 */
typedef union {
  struct {
    UINT32 pme_requester_id : 16;
    /* pme_requester_id - Bits[15:0], RO_V, default = 16'b0000000000000000 
       This field indicates the PCI requester ID of the last PME requestor. If the root 
       port itself was the source of the (virtual) PME message, then a RequesterID of 
       CPUBUSNO0:DevNo:FunctionNo is logged in this field. 
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[16:16], RW1C, default = 1'b0 
       This field indicates a PM_PME message (either from the link or internally from 
       within that root port) was received at the port.1: PME was asserted by a 
       requester as indicated by the PME Requester ID field 
       This bit is cleared by software by writing a '1'. Note that the root port itself 
       could be the source of a PME event when a hotplug event is observed when the 
       port is in D3hot state. 
     */
    UINT32 pme_pending : 1;
    /* pme_pending - Bits[17:17], RO_V, default = 1'b0 
       This field indicates that another PME is pending when the PME Status bit is set. 
       When the PME Status bit is cleared by software; the pending PME is delivered by 
       hardware by setting the PME Status bit again and updating the Requestor ID 
       appropriately. The PME pending bit is cleared by hardware if no more PMEs are 
       pending. 
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ROOTSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* DEVCAP2_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x400181B4)                                                  */
/*       IVT_EX (0x400181B4)                                                  */
/*       HSX (0x400181B4)                                                     */
/*       BDX (0x400181B4)                                                     */
/* Register default value:              0x000013BE                            */
#define DEVCAP2_IIO_PCIENTB_REG 0x100041B4


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1b4
 */
typedef union {
  struct {
    UINT32 cmpltovalsup : 4;
    /* cmpltovalsup - Bits[3:0], RO, default = 4'b1110  */
    UINT32 cmpltodissup : 1;
    /* cmpltodissup - Bits[4:4], RO, default = 1'b1  */
    UINT32 ari_en : 1;
    /* ari_en - Bits[5:5], RW_LB, default = 1'b1 
       1
     */
    UINT32 atomicroutsup : 1;
    /* atomicroutsup - Bits[6:6], RO, default = 1'b0  */
    UINT32 atomic32bcompsup : 1;
    /* atomic32bcompsup - Bits[7:7], RO, default = 1'b1  */
    UINT32 atomic64bcompsup : 1;
    /* atomic64bcompsup - Bits[8:8], RO, default = 1'b1  */
    UINT32 atomic128bcascompsup : 1;
    /* atomic128bcascompsup - Bits[9:9], RO, default = 1'b1  */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ltr_en : 1;
    /* ltr_en - Bits[11:11], RW_LB, default = 1'b0  */
    UINT32 tph_completer_supported : 2;
    /* tph_completer_supported - Bits[13:12], RW_LB, default = 2'b01 
       1
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP2_IIO_PCIENTB_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* DEVCTRL2_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x200181B8)                                                  */
/*       IVT_EX (0x200181B8)                                                  */
/*       HSX (0x200181B8)                                                     */
/*       BDX (0x200181B8)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL2_IIO_PCIENTB_REG 0x100021B8


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1b8
 */
typedef union {
  struct {
    UINT16 compltoval : 4;
    /* compltoval - Bits[3:0], RW_V, default = 4'b0000  */
    UINT16 compltodis : 1;
    /* compltodis - Bits[4:4], RW_V, default = 1'b0  */
    UINT16 ari : 1;
    /* ari - Bits[5:5], RW_L, default = 1'b0 
       Alternative RID InterpretationEnable
       Applies only to root ports. When set to 1b, ARI is enabled for the Root Port. 
       For Device#0 in DMI mode, this bit is ignored. 
     */
    UINT16 atomicreqen : 1;
    /* atomicreqen - Bits[6:6], RO, default = 1'b0  */
    UINT16 atomicegressblock : 1;
    /* atomicegressblock - Bits[7:7], RO, default = 1'b0  */
    UINT16 rsvd_8 : 2;
    /* rsvd_8 - Bits[9:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 ltr_en : 1;
    /* ltr_en - Bits[10:10], RW_LV, default = 1'b0  */
    UINT16 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL2_IIO_PCIENTB_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* LNKCAP2_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x400181BC)                                                  */
/*       IVT_EX (0x400181BC)                                                  */
/*       HSX (0x400181BC)                                                     */
/*       BDX (0x400181BC)                                                     */
/* Register default value:              0x0000000E                            */
#define LNKCAP2_IIO_PCIENTB_REG 0x100041BC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1bc
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lnkspdvec : 7;
    /* lnkspdvec - Bits[7:1], RW_O, default = 7'b0000111 
       Supported Link Speeds Vector - This field indicates the supported Link speed(s) 
       of the associated Port. For each bit, a value of 1b indicates that the 
       corresponding Link speed is supported; otherwise, the Link speed is not 
       supported. 
       Bit definitions are:
       Bit 1 2.5 GT/s
       Bit 2 5.0 GT/s
       Bit 3 8.0 GT/s
       Bits 7:4 reserved
     */
    UINT32 rsvd_8 : 24;
    /* rsvd_8 - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCAP2_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNKCON2_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x200181C0)                                                  */
/*       IVT_EX (0x200181C0)                                                  */
/*       HSX (0x200181C0)                                                     */
/*       BDX (0x200181C0)                                                     */
/* Register default value:              0x0003                                */
#define LNKCON2_IIO_PCIENTB_REG 0x100021C0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1c0
 */
typedef union {
  struct {
    UINT16 target_link_speed : 4;
    /* target_link_speed - Bits[3:0], RWS_V, default = 4'b0011 
       This field sets an upper limit on link operational speed by restricting the 
       values advertised by the upstream component in its training sequences. Defined 
       encodings are: 
       0001b 2.5Gb/s Target Link Speed
       0010b 5Gb/s Target Link Speed
       Reserved (Dev#0)/0011b (others) 8Gb/s Target Link Speed
       All other encodings are reserved.
       If a value is written to this field that does not correspond to a speed included 
       in the Supported Link Speeds field, IIO will default to Gen1 speed. 
       This field is also used to set the target compliance mode speed when software is 
       using the Enter Compliance bit to force a link into compliance mode. 
     */
    UINT16 enter_compliance : 1;
    /* enter_compliance - Bits[4:4], RWS_V, default = 1'b0 
       Software is permitted to force a link to enter Compliance mode at the speed 
       indicated in the Target Link Speed field by setting this bit to 1b in both 
       components on a link and then initiating a hot reset on the link. 
     */
    UINT16 hardware_autonomous_speed_disable : 1;
    /* hardware_autonomous_speed_disable - Bits[5:5], RWS, default = 1'b0 
       When Set, this bit disables hardware from changing the Link speed for device 
       specific reasons other than attempting to correct unreliable Link operation by 
       reducing Link speed. 
     */
    UINT16 selectable_de_emphasis : 1;
    /* selectable_de_emphasis - Bits[6:6], RW_O, default = 1'b0 
       When the Link is operating at 5.0 GT/s speed, this bit selects the level of 
       de-emphasis for an Upstream component.Encodings: 
       1b -3.5 dB
       0b -6 dB
       When the Link is operating at 2.5 GT/s speed, the setting of this bit has no 
       effect. 
     */
    UINT16 transmit_margin : 3;
    /* transmit_margin - Bits[9:7], RWS_V, default = 3'b000 
       This field controls the value of the nondeemphasized voltage level at the 
       Transmitter pins. 
     */
    UINT16 enter_modified_compliance : 1;
    /* enter_modified_compliance - Bits[10:10], RWS, default = 1'b0 
       When this bit is set to 1b, the device transmits Modified Compliance Pattern if 
       the LTSSM enters Polling.Compliance substate. 
     */
    UINT16 compliance_sos : 1;
    /* compliance_sos - Bits[11:11], RWS, default = 1'b0 
       When set to 1b, the LTSSM is required to send SKP Ordered Sets periodically in 
       between the (modified) compliance patterns. 
     */
    UINT16 compliance_de_emphasis : 4;
    /* compliance_de_emphasis - Bits[15:12], RWS, default = 4'b0000 
       For 8GT/s Data Rate:
       This bit sets the Transmitter Preset level in Polling.Compliance state if the 
       entry occurred due to the Enter Compliance bit being 1b. The Encodings are 
       defined as follows: 
       
       0000b: -6 dB for de-emphasis, 0 dB for preshoot
       0001b: -3.5 dB for de-emphasis, 0 dB for preshoot
       0010b: -4.5 dB for de-emphasis, 0 dB for preshoot
       0011b: -2.5 dB for de-emphasis, 0 dB for preshoot
       0100b: 0 dB for de-emphasis, 0 dB for preshoot
       0101b: 0 dB for de-emphasis, 2 dB for preshoot
       0110b: 0 dB for de-emphasis, 2.5 dB for preshoot
       0111b: -6 dB for de-emphasis, 3.5 dB for preshoot
       1000b: -3.5 dB for de-emphasis, 3.5 dB for preshoot
       1001b: 0 dB for de-emphasis, 3.5 dB for preshoot
       Others: reserved
       
       For 5GT/s Data Rate:
       This bit sets the de-emphasis level in Polling.Compliance state if the entry 
       occurred due to the Enter Compliance bit being 1b. Encodings: 
       
       0001b: -3.5 dB
       0000b: -6 dB
       
       For 2.5GT/s Data Rate:
       The setting of this field has no effect. Components that support only 2.5 GT/s 
       speed are permitted to hardwire this field to 0h. 
       
       Notes:
       This bit is intended for debug, compliance testing purposes. System firmware and 
       software is allowed to modify this bit only during debug or compliance testing. 
     */
  } Bits;
  UINT16 Data;
} LNKCON2_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNKSTS2_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x200181C2)                                                  */
/*       IVT_EX (0x200181C2)                                                  */
/*       HSX (0x200181C2)                                                     */
/*       BDX (0x200181C2)                                                     */
/* Register default value:              0x0000                                */
#define LNKSTS2_IIO_PCIENTB_REG 0x100021C2
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1c2
 */
typedef union {
  struct {
    UINT16 current_de_emphasis_level : 1;
    /* current_de_emphasis_level - Bits[0:0], RO_V, default = 1'b0 
       When operating at Gen2 speed, this reports the current de-emphasis level. This 
       field is Unused for Gen1 speeds 
       
       1b: -3.5 dB
       0b: -6 dB
     */
    UINT16 eqcmp : 1;
    /* eqcmp - Bits[1:1], RO_V, default = 1'b0 
       When set to 1b, this indicates that the Transmitter Equalization procedure has 
       completed. 
     */
    UINT16 eqph1_succ : 1;
    /* eqph1_succ - Bits[2:2], RO_V, default = 1'b0 
       When set to 1b, this indicates that Phase 1 of the Transmitter Equalization 
       procedure has successfully completed. 
     */
    UINT16 eqph2_succ : 1;
    /* eqph2_succ - Bits[3:3], RO_V, default = 1'b0 
       When set to 1b, this indicates that Phase 2 of the Transmitter Equalization 
       procedure has successfully completed. 
     */
    UINT16 eqph3_succ : 1;
    /* eqph3_succ - Bits[4:4], RO_V, default = 1'b0 
       When set to 1b, this indicates that Phase 3 of the Transmitter Equalization 
       procedure has successfully completed. 
     */
    UINT16 lnkeqreq : 1;
    /* lnkeqreq - Bits[5:5], RW1CS, default = 1'b0 
       This bit is Set by hardware to request Link equalization process to be performed 
       on the link. 
     */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKSTS2_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ERRINJCAP_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x400181D0)                                                  */
/*       IVT_EX (0x400181D0)                                                  */
/*       HSX (0x400181D0)                                                     */
/*       BDX (0x400181D0)                                                     */
/* Register default value:              0x2501000B                            */
#define ERRINJCAP_IIO_PCIENTB_REG 0x100041D0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCI Express Error Injection
 */
typedef union {
  struct {
    UINT32 extcapid : 16;
    /* extcapid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCI Express Extended CAP ID
       Vendor Specific Capability
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability Version
       Set to 1h for this version of the PCI Express logic
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001001010000 
       Next Capability Offset
       This field points to the next capability or 0 if there isn't a next capability.
       For non-DMI (x4) port next capability is at 0x250.
       For DMI port next capability is at 0x280.
     */
  } Bits;
  UINT32 Data;
} ERRINJCAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ERRINJHDR_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x400181D4)                                                  */
/*       IVT_EX (0x400181D4)                                                  */
/*       HSX (0x400181D4)                                                     */
/*       BDX (0x400181D4)                                                     */
/* Register default value:              0x00A10003                            */
#define ERRINJHDR_IIO_PCIENTB_REG 0x100041D4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCI Express Error Injection
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000011 
       Vendor Specific ID
       Assigned for WHEA Error Injection
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0001 
       Vendor Specific Capability Revision
       Set to 1h for this version of the WHEA Error Injection logic
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000001010 
       Vendor Specific Capability Length
       Indicates the length of the capability structure, including header bytes.
     */
  } Bits;
  UINT32 Data;
} ERRINJHDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* ERRINJCON_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x200181D8)                                                  */
/*       IVT_EX (0x200181D8)                                                  */
/*       HSX (0x200181D8)                                                     */
/*       BDX (0x200181D8)                                                     */
/* Register default value:              0x0000                                */
#define ERRINJCON_IIO_PCIENTB_REG 0x100021D8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCI Express Error Injection Control Register
 */
typedef union {
  struct {
    UINT16 errinjdis : 1;
    /* errinjdis - Bits[0:0], RW_O, default = 1'b0 
       Error Injection Disable
       This bit disables the use of the PCIe error injection bits.
     */
    UINT16 cause_rcverr : 1;
    /* cause_rcverr - Bits[1:1], RW, default = 1'b0 
       Cause a Receiver Error
       When this bit is written to transition from 0 to 1, one and only one error 
       assertion pulse is produced on the error source signal for the given port. This 
       error will appear equivalent to an actual error assertion because this event is 
       OR'd into the existing error reporting structure. To log another error, this bit 
       must be cleared first, before setting again. Leaving this bit in a 1 state does 
       not produce a persistent error condition. 
       This bit is used for an correctable error test.
       This bit must be cleared by software before creating another event.
       This bit is disabled by bit 0 of this register.
     */
    UINT16 cause_ctoerr : 1;
    /* cause_ctoerr - Bits[2:2], RW, default = 1'b0 
       Cause a Completion Timeout Error
       When this bit is written to transition from 0 to 1, one and only one error 
       assertion pulse is produced on the error source signal for the given port. This 
       error will appear equivalent to an actual error assertion because this event is 
       OR'd into the existing error reporting structure. To log another error, this bit 
       must be cleared first, before setting again. Leaving this bit in a 1 state does 
       not produce a persistent error condition. 
       This bit is used for an uncorrectable error test.
       This bit must be cleared by software before creating another event.
       This bit is disabled by bit 0 of this register.
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ERRINJCON_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* CTOCTRL_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x400181E0)                                                  */
/*       IVT_EX (0x400181E0)                                                  */
/*       HSX (0x400181E0)                                                     */
/*       BDX (0x400181E0)                                                     */
/* Register default value:              0x00000000                            */
#define CTOCTRL_IIO_PCIENTB_REG 0x100041E0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Completion Timeout Control
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    /* rsvd_0 - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 xp_to_pcie_timeout_select : 2;
    /* xp_to_pcie_timeout_select - Bits[9:8], RW, default = 2'b00 
       When OS selects a timeout range of 17s to 64s for XP (that affect NP tx issued 
       to the PCIE/DMI) using the root port's DEVCTRL2 register, this field selects the 
       sub-range within that larger range, for additional controllability. 
       00: 17s-30s
       01: 31s-45s
       10: 46s-64s
       11: Reserved
       This field is not used at all when NTB is enabled on Dev#3/Fn#0 since there is 
       no programmability of completion timeout in that mode. 
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CTOCTRL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PCIE_LER_SS_CTRLSTS_IIO_PCIENTB_REG supported on:                          */
/*       IVT_EP (0x400181E4)                                                  */
/*       IVT_EX (0x400181E4)                                                  */
/*       HSX (0x400181E4)                                                     */
/*       BDX (0x400181E4)                                                     */
/* Register default value:              0x00000000                            */
#define PCIE_LER_SS_CTRLSTS_IIO_PCIENTB_REG 0x100041E4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x1e4
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PCIE_LER_SS_CTRLSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPCORERRSTS_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018200)                                                  */
/*       IVT_EX (0x40018200)                                                  */
/*       HSX (0x40018200)                                                     */
/*       BDX (0x40018200)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRSTS_IIO_PCIENTB_REG 0x10004200
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * XP Correctable Error Status
 * The architecture model for error logging and escalation of internal errors is 
 * similar to that of PCI Express AER, except that these internal errors never 
 * trigger an MSI and are always reported to the system software. Mask bits mask 
 * the reporting of an error and severity bit controls escalation to either fatal 
 * or non-fatal error to the internal core error logic. Note that internal errors 
 * detected in the PCI Express cluster are not dependent on any other control bits 
 * for error escalation other than the mask bit defined in these registers. All 
 * these registers are sticky 
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0 
       This bit is set when:
       (LNKSTS[15] and LNKCON[11])=1 or
       LNKSTS[14]=1 or
       (LNKSTS[5] and LNKCON[1])=1
       This bit is cleared by software.
     */
    UINT32 msgd_gt_16dw : 1;
    /* msgd_gt_16dw - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* XPCORERRMSK_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018204)                                                  */
/*       IVT_EX (0x40018204)                                                  */
/*       HSX (0x40018204)                                                     */
/*       BDX (0x40018204)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRMSK_IIO_PCIENTB_REG 0x10004204
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * XP Correctable Error Mask
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 msgd_gt_16dw_errmask : 1;
    /* msgd_gt_16dw_errmask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* XPUNCERRSTS_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018208)                                                  */
/*       IVT_EX (0x40018208)                                                  */
/*       HSX (0x40018208)                                                     */
/*       BDX (0x40018208)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRSTS_IIO_PCIENTB_REG 0x10004208
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x208
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected : 1;
    /* outbound_switch_fifo_data_parity_error_detected - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort : 1;
    /* sent_completion_with_completer_abort - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request : 1;
    /* sent_completion_with_unsupported_request - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status : 1;
    /* received_pcie_completion_with_ca_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status : 1;
    /* received_pcie_completion_with_ur_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data : 1;
    /* received_msi_writes_greater_than_a_dword_data - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 outbound_poisoned_data : 1;
    /* outbound_poisoned_data - Bits[9:9], RW1CS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPUNCERRMSK_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x4001820C)                                                  */
/*       IVT_EX (0x4001820C)                                                  */
/*       HSX (0x4001820C)                                                     */
/*       BDX (0x4001820C)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRMSK_IIO_PCIENTB_REG 0x1000420C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x20c
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detected_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_mask : 1;
    /* sent_completion_with_completer_abort_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_mask : 1;
    /* sent_completion_with_unsupported_request_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRMSK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPUNCERRSEV_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018210)                                                  */
/*       IVT_EX (0x40018210)                                                  */
/*       HSX (0x40018210)                                                     */
/*       BDX (0x40018210)                                                     */
/* Register default value:              0x00000002                            */
#define XPUNCERRSEV_IIO_PCIENTB_REG 0x10004210
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x210
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_severity : 1;
    /* outbound_switch_fifo_data_parity_error_detected_severity - Bits[1:1], RWS, default = 1'b1  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_severity : 1;
    /* sent_completion_with_completer_abort_severity - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_severity : 1;
    /* sent_completion_with_unsupported_request_severity - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_severity : 1;
    /* received_pcie_completion_with_ca_status_severity - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_severity : 1;
    /* received_pcie_completion_with_ur_status_severity - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_severity : 1;
    /* received_msi_writes_greater_than_a_dword_data_severity - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_severity : 1;
    /* outbound_poisoned_data_severity - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSEV_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPUNCERRPTR_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x10018214)                                                  */
/*       IVT_EX (0x10018214)                                                  */
/*       HSX (0x10018214)                                                     */
/*       BDX (0x10018214)                                                     */
/* Register default value:              0x00                                  */
#define XPUNCERRPTR_IIO_PCIENTB_REG 0x10001214
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * XP Uncorrectable Error Pointer
 */
typedef union {
  struct {
    UINT8 xp_uncorrectable_first_error_pointer : 5;
    /* xp_uncorrectable_first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000 
       This field points to which of the unmasked uncorrectable errors happened first. 
       This field is only valid when the corresponding error is unmasked and the status 
       bit is set and this field is rearmed to load again when the status bit indicated 
       to by this pointer is cleared by software from 1 to 0. Value of 0x0 corresponds 
       to bit 0 in XPUNCERRSTS register, value of 0x1 corresponds to bit 1 etc. 
     */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} XPUNCERRPTR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* UNCEDMASK_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x40018218)                                                  */
/*       IVT_EX (0x40018218)                                                  */
/*       HSX (0x40018218)                                                     */
/*       BDX (0x40018218)                                                     */
/* Register default value:              0x00000000                            */
#define UNCEDMASK_IIO_PCIENTB_REG 0x10004218
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x218
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_detect_mask : 1;
    /* ecrc_error_detect_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* COREDMASK_IIO_PCIENTB_REG supported on:                                    */
/*       IVT_EP (0x4001821C)                                                  */
/*       IVT_EX (0x4001821C)                                                  */
/*       HSX (0x4001821C)                                                     */
/*       BDX (0x4001821C)                                                     */
/* Register default value:              0x00000000                            */
#define COREDMASK_IIO_PCIENTB_REG 0x1000421C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x21c
 */
typedef union {
  struct {
    UINT32 receiver_error_detect_mask : 1;
    /* receiver_error_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_detect_mask : 1;
    /* bad_tlp_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_detect_mask : 1;
    /* bad_dllp_detect_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_detect_mask : 1;
    /* replay_num_rollover_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_detect_mask : 1;
    /* replay_timer_time_out_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_detect_mask : 1;
    /* advisory_non_fatal_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} COREDMASK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* RPEDMASK_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x40018220)                                                  */
/*       IVT_EX (0x40018220)                                                  */
/*       HSX (0x40018220)                                                     */
/*       BDX (0x40018220)                                                     */
/* Register default value:              0x00000000                            */
#define RPEDMASK_IIO_PCIENTB_REG 0x10004220
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x220
 */
typedef union {
  struct {
    UINT32 correctable_error_detected_status_mask : 1;
    /* correctable_error_detected_status_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 non_fatal_error_detected_status_mask : 1;
    /* non_fatal_error_detected_status_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 fatal_error_detected_status_mask : 1;
    /* fatal_error_detected_status_mask - Bits[2:2], RWS, default = 1'b0  */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPEDMASK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPUNCEDMASK_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018224)                                                  */
/*       IVT_EX (0x40018224)                                                  */
/*       HSX (0x40018224)                                                     */
/*       BDX (0x40018224)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCEDMASK_IIO_PCIENTB_REG 0x10004224
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x224
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detect_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detect_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_detect_mask : 1;
    /* sent_completion_with_completer_abort_detect_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_detect_mask : 1;
    /* sent_completion_with_unsupported_request_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_detect_mask : 1;
    /* received_pcie_completion_with_ca_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_detect_mask : 1;
    /* received_pcie_completion_with_ur_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_detect_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_detect_mask : 1;
    /* outbound_poisoned_data_detect_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCEDMASK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPCOREDMASK_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018228)                                                  */
/*       IVT_EX (0x40018228)                                                  */
/*       HSX (0x40018228)                                                     */
/*       BDX (0x40018228)                                                     */
/* Register default value:              0x00000000                            */
#define XPCOREDMASK_IIO_PCIENTB_REG 0x10004228
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * XP Correctable Error Mask
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0 
       Masks the BW change event from being propagated to the IIO core error logic as a 
       correctable error. 
     */
    UINT32 msgd_gt_16dw_detmask : 1;
    /* msgd_gt_16dw_detmask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* XPGLBERRSTS_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x20018230)                                                  */
/*       IVT_EX (0x20018230)                                                  */
/*       HSX (0x20018230)                                                     */
/*       BDX (0x20018230)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRSTS_IIO_PCIENTB_REG 0x10002230
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * XP Global Error Status
 */
typedef union {
  struct {
    UINT16 pcie_aer_fatal_error : 1;
    /* pcie_aer_fatal_error - Bits[0:0], RW1CS, default = 1'b0 
       A PCIE fatal error (ERR_FATAL message received from externally or through a 
       virtual ERR_FATAL message generated internally) was detected anew. Note that if 
       that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage, only 'subsequent' 
       PCIE unmasked fatal errors will set this bit.See section titled PCI Express 
       Error Reporting Specifics in the RAS chapter for details of how this bit 
       interacts with other control/status bits in signalling errors to the IIO global 
       error reporting logic. 
     */
    UINT16 pcie_aer_non_fatal_error : 1;
    /* pcie_aer_non_fatal_error - Bits[1:1], RW1CS, default = 1'b0 
       A PCIE non-fatal error (ERR_NONFATAL message received from externally or through 
       a virtual ERR_NONFATAL message generated internally) was detected anew. Note 
       that if that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage only 'subsequent' PCIE 
       unmasked non-fatal errors will set this bit again.See section titled PCI Express 
       Error Reporting Specifics in the RAS chapter for details of how this bit 
       interacts with other control/status bits in signalling errors to the IIO global 
       error reporting logic. 
     */
    UINT16 pcie_aer_correctable_error : 1;
    /* pcie_aer_correctable_error - Bits[2:2], RW1CS, default = 1'b0 
       A PCIE correctable error (ERR_COR message received from externally or through a 
       virtual ERR_COR message generated internally) was detected anew. Note that if 
       that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage, only 'subsequent' 
       PCIE unmasked correctable errors will set this bit.Conceptually, per the flow of 
       PCI Express Base Spec 2.0 defined Error message control, this bit is set by the 
       ERR_COR message that is enabled to cause a System Error notification. See 
       section titled PCI Express Error Reporting Specifics in the RAS chapter for 
       details of how this bit interacts with other control/status bits in signalling 
       errors to the IIO global error reporting logic. 
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* XPGLBERRPTR_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x20018232)                                                  */
/*       IVT_EX (0x20018232)                                                  */
/*       HSX (0x20018232)                                                     */
/*       BDX (0x20018232)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRPTR_IIO_PCIENTB_REG 0x10002232
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * XP Global Error Pointer
 */
typedef union {
  struct {
    UINT16 xp_cluster_global_first_error_pointer : 3;
    /* xp_cluster_global_first_error_pointer - Bits[2:0], ROS_V, default = 3'b000 
       This field points to which of the 3 errors indicated in the XPGLBERRSTS register 
       happened first. This field is only valid when the corresponding status bit is 
       set and this field is rearmed to load again when the status bit indicated to by 
       this pointer is cleared by software from 1 to 0.Value of 0x0 corresponds to bit 
       0 in XPGLBERRSTS register, value of 0x1 corresponds to bit 1 etc. 
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRPTR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* PXP2CAP_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018250)                                                  */
/*       IVT_EX (0x40018250)                                                  */
/*       HSX (0x40018250)                                                     */
/*       BDX (0x40018250)                                                     */
/* Register default value:              0x28010019                            */
#define PXP2CAP_IIO_PCIENTB_REG 0x10004250
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x250
 */
typedef union {
  struct {
    UINT32 id : 16;
    /* id - Bits[15:0], RW_O, default = 16'b0000000000011001 
       This field is a PCI SIG defined ID number that indicates the nature and format 
       of the Extended Capability. PCI Express Extended Capability ID for the Secondary 
       PCI Expresss Extended Capability is 0019h. 
     */
    UINT32 version : 4;
    /* version - Bits[19:16], RW_O, default = 4'b0001 
       This field is a PCI-SIG defined version number that indicates the version of the 
       Capability structure present. 
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001010000000 
       This field contains the offset to the next PCI Express Extended Capability 
       structure or 000h if no other items exist in the linked list of capabilities. 
     */
  } Bits;
  UINT32 Data;
} PXP2CAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNKCON3_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018254)                                                  */
/*       IVT_EX (0x40018254)                                                  */
/*       HSX (0x40018254)                                                     */
/*       BDX (0x40018254)                                                     */
/* Register default value:              0x00000000                            */
#define LNKCON3_IIO_PCIENTB_REG 0x10004254
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x254
 */
typedef union {
  struct {
    UINT32 perfeq : 1;
    /* perfeq - Bits[0:0], RW, default = 1'b0 
       When this register is 1b and a 1b is written to the 'Link Retrain' register with 
       'Target Link Speed' set to 8GT/s, the Upstream component must perform 
       Transmitter Equalization. 
     */
    UINT32 lnkeqreqinten : 1;
    /* lnkeqreqinten - Bits[1:1], RW, default = 1'b0 
       When Set, this bit enables the generation of interrupt to indicate that the Link 
       Equalization Request bit has been set. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCON3_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LNERRSTS_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x40018258)                                                  */
/*       IVT_EX (0x40018258)                                                  */
/*       HSX (0x40018258)                                                     */
/*       BDX (0x40018258)                                                     */
/* Register default value:              0x00000000                            */
#define LNERRSTS_IIO_PCIENTB_REG 0x10004258
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x258
 */
typedef union {
  struct {
    UINT32 lane : 16;
    /* lane - Bits[15:0], RW1CS, default = 16'b0000000000000000 
       A value of 1b in any bit indicates if the corresponding PCIe Express Lane 
       detected lane based error. 
       A x4 root port supports bits [3:0], a x8 root port supports bits [7:0], and a 
       x16 root port supports bits [15:0]. 
       bit 0 Lane 0 Error Detected
       bit 1 Lane 1 Error Detected
       bit 2 Lane 2 Error Detected
       bit 3 Lane 3 Error Detected
       bit 4 Lane 4 Error Detected (not used when the link is bifurcated as x4)
       bit 5 Lane 5 Error Detected (not used when the link is bifurcated as x4)
       bit 6 Lane 6 Error Detected (not used when the link is bifurcated as x4)
       bit 7 Lane 7 Error Detected (not used when the link is bifurcated as x4)
       bit 8 Lane 8 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 9 Lane 9 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 10 Lane 10 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 11 Lane 11 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 12 Lane 12 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 13 Lane 13 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 14 Lane 14 Error Detected (not used when the link is bifurcated as x4 or x8)
       bit 15 Lane 15 Error Detected (not used when the link is bifurcated as x4 or x8)
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNERRSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN0EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x2001825C)                                                  */
/*       IVT_EX (0x2001825C)                                                  */
/*       HSX (0x2001825C)                                                     */
/*       BDX (0x2001825C)                                                     */
/* Register default value:              0x2878                                */
#define LN0EQ_IIO_PCIENTB_REG 0x1000225C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x25c
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN0EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN1EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x2001825E)                                                  */
/*       IVT_EX (0x2001825E)                                                  */
/*       HSX (0x2001825E)                                                     */
/*       BDX (0x2001825E)                                                     */
/* Register default value:              0x2878                                */
#define LN1EQ_IIO_PCIENTB_REG 0x1000225E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x25e
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN1EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN2EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x20018260)                                                  */
/*       IVT_EX (0x20018260)                                                  */
/*       HSX (0x20018260)                                                     */
/*       BDX (0x20018260)                                                     */
/* Register default value:              0x2878                                */
#define LN2EQ_IIO_PCIENTB_REG 0x10002260
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x260
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN2EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN3EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x20018262)                                                  */
/*       IVT_EX (0x20018262)                                                  */
/*       HSX (0x20018262)                                                     */
/*       BDX (0x20018262)                                                     */
/* Register default value:              0x2878                                */
#define LN3EQ_IIO_PCIENTB_REG 0x10002262
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x262
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN3EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN4EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x20018264)                                                  */
/*       IVT_EX (0x20018264)                                                  */
/*       HSX (0x20018264)                                                     */
/*       BDX (0x20018264)                                                     */
/* Register default value:              0x2878                                */
#define LN4EQ_IIO_PCIENTB_REG 0x10002264
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x264
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN4EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN5EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x20018266)                                                  */
/*       IVT_EX (0x20018266)                                                  */
/*       HSX (0x20018266)                                                     */
/*       BDX (0x20018266)                                                     */
/* Register default value:              0x2878                                */
#define LN5EQ_IIO_PCIENTB_REG 0x10002266
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x266
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN5EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN6EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x20018268)                                                  */
/*       IVT_EX (0x20018268)                                                  */
/*       HSX (0x20018268)                                                     */
/*       BDX (0x20018268)                                                     */
/* Register default value:              0x2878                                */
#define LN6EQ_IIO_PCIENTB_REG 0x10002268
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x268
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN6EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN7EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x2001826A)                                                  */
/*       IVT_EX (0x2001826A)                                                  */
/*       HSX (0x2001826A)                                                     */
/*       BDX (0x2001826A)                                                     */
/* Register default value:              0x2878                                */
#define LN7EQ_IIO_PCIENTB_REG 0x1000226A
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x26a
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN7EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN8EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x2001826C)                                                  */
/*       IVT_EX (0x2001826C)                                                  */
/*       HSX (0x2001826C)                                                     */
/*       BDX (0x2001826C)                                                     */
/* Register default value:              0x2878                                */
#define LN8EQ_IIO_PCIENTB_REG 0x1000226C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x26c
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN8EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN9EQ_IIO_PCIENTB_REG supported on:                                        */
/*       IVT_EP (0x2001826E)                                                  */
/*       IVT_EX (0x2001826E)                                                  */
/*       HSX (0x2001826E)                                                     */
/*       BDX (0x2001826E)                                                     */
/* Register default value:              0x2878                                */
#define LN9EQ_IIO_PCIENTB_REG 0x1000226E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x26e
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN9EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN10EQ_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018270)                                                  */
/*       IVT_EX (0x20018270)                                                  */
/*       HSX (0x20018270)                                                     */
/*       BDX (0x20018270)                                                     */
/* Register default value:              0x2878                                */
#define LN10EQ_IIO_PCIENTB_REG 0x10002270
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x270
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN10EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN11EQ_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018272)                                                  */
/*       IVT_EX (0x20018272)                                                  */
/*       HSX (0x20018272)                                                     */
/*       BDX (0x20018272)                                                     */
/* Register default value:              0x2878                                */
#define LN11EQ_IIO_PCIENTB_REG 0x10002272
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x272
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN11EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN12EQ_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018274)                                                  */
/*       IVT_EX (0x20018274)                                                  */
/*       HSX (0x20018274)                                                     */
/*       BDX (0x20018274)                                                     */
/* Register default value:              0x2878                                */
#define LN12EQ_IIO_PCIENTB_REG 0x10002274
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x274
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN12EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN13EQ_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018276)                                                  */
/*       IVT_EX (0x20018276)                                                  */
/*       HSX (0x20018276)                                                     */
/*       BDX (0x20018276)                                                     */
/* Register default value:              0x2878                                */
#define LN13EQ_IIO_PCIENTB_REG 0x10002276
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x276
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN13EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN14EQ_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018278)                                                  */
/*       IVT_EX (0x20018278)                                                  */
/*       HSX (0x20018278)                                                     */
/*       BDX (0x20018278)                                                     */
/* Register default value:              0x2878                                */
#define LN14EQ_IIO_PCIENTB_REG 0x10002278
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x278
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN14EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LN15EQ_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x2001827A)                                                  */
/*       IVT_EX (0x2001827A)                                                  */
/*       HSX (0x2001827A)                                                     */
/*       BDX (0x2001827A)                                                     */
/* Register default value:              0x2878                                */
#define LN15EQ_IIO_PCIENTB_REG 0x1000227A
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * generated by critter 03_0_0x27a
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN15EQ_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LER_CAP_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018280)                                                  */
/*       IVT_EX (0x40018280)                                                  */
/*       HSX (0x40018280)                                                     */
/*       BDX (0x40018280)                                                     */
/* Register default value on IVT_EP:    0x0001000B                            */
/* Register default value on IVT_EX:    0x0001000B                            */
/* Register default value on HSX:       0x2981000B                            */
/* Register default value on BDX:       0x2981000B                            */
#define LER_CAP_IIO_PCIENTB_REG 0x10004280
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Live Error Recovery Capability
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCI Express Extended CAP ID
       Vendor Specific Capability
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability Version
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001010011000 
       Next Capability Offset
       Default may vary depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} LER_CAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LER_HDR_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018284)                                                  */
/*       IVT_EX (0x40018284)                                                  */
/*       HSX (0x40018284)                                                     */
/*       BDX (0x40018284)                                                     */
/* Register default value:              0x01830005                            */
#define LER_HDR_IIO_PCIENTB_REG 0x10004284
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Live Error Recovery Capability Header
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000101 
       Vendor Specific ID
       Represents the Live Error Recovery capability
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0011 
       Vendor Specific Capability Revision
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000011000 
       Vendor Specific Capability Length
     */
  } Bits;
  UINT32 Data;
} LER_HDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LER_CTRLSTS_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x40018288)                                                  */
/*       IVT_EX (0x40018288)                                                  */
/*       HSX (0x40018288)                                                     */
/*       BDX (0x40018288)                                                     */
/* Register default value:              0x00000000                            */
#define LER_CTRLSTS_IIO_PCIENTB_REG 0x10004288
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0 
       Live Error Recovery Enable
       When set, allows the LER_Status to assert on error. When the status bit is set, 
       the port is in LER mode. When this bit is cleared, the LER_Status bit cannot 
       become set on an error. 
       If this bit is cleared when LER_Status bit is already set, then clearing this 
       bit does not clear the status bit and does not exit LER mode. To exit LER mode, 
       the status bit must be cleared by software. 
       This bit is also used for stop and scream and can be enabled even though LER is 
       not available. 
     */
    UINT32 ler_ss_severity_en : 1;
    /* ler_ss_severity_en - Bits[1:1], RWS, default = 1'b0 
       Live Error Recovery Severity Enable
       If set, forces the errors that trigger LER mode to be signalled as correctable 
       error of Severity 0. If cleared, then errors are signaled as Uncorrectable 
       Non-Fatal Severity 1 or Uncorrectable Fatal Severity 2 as specified for the 
       given error. 
     */
    UINT32 ler_ss_drop_txn : 1;
    /* ler_ss_drop_txn - Bits[2:2], RWS, default = 1'b0 
       Live Error Recovery Drop Transaction
       If set, after entering LER subsequent transactions will be dropped as soon as 
       the port configuration allows. 
     */
    UINT32 ler_ss_inten : 1;
    /* ler_ss_inten - Bits[3:3], RWS, default = 1'b0 
       Live Error Recovery Interrupt Enable
       If set, causes and INTx or MSI interrupt from the root port (if enabled in the 
       root port) to be generated when LER_Status is set. 
     */
    UINT32 rsvd : 26;
    /* rsvd - Bits[29:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ler_ss_lnk_up_ok : 1;
    /* ler_ss_lnk_up_ok - Bits[30:30], ROS_V, default = 1'b0 
       Live Error Recovery Port Quiesced
       Indicates when the port has no more pending inbound or outbound packets after 
       the port has entered LER mode. It is used by software to determine when it is 
       safe to clear the LER_Status bit to bring the port out of LER mode. 
     */
    UINT32 ler_ss_status : 1;
    /* ler_ss_status - Bits[31:31], RW1CS, default = 1'b0 
       Live Error Recovery Status
       Indicates that an error was detected that caused the PCIE port to go into a live 
       error recovery (LER) mode. While in LER mode, the link goes into a LinkDown 
       "Disabled" state and all outbound transactions are aborted (including packets 
       that may have caused the error). 
       This bit cannot be cleared until all the associated unmasked status bits are 
       cleared, or the corresponding LER mask bits are set. Once the unmasked error 
       considtion are cleared, then this bit may be cleared by software writing a '1'. 
       Once this status becomes cleared by clearing the error condition, the link will 
       retrain into LinkUp state and outbound transactions will no longer be aborted. 
       A link that is forced into a LinkDown state due to LER does not trigger a 
       "surprise LinkDown" error in the UNCERRSTS register. 
       It should be noted that many PCIe cards will go into internal reset when they 
       receive training sequences that indicate the "Disabled" state. 
     */
  } Bits;
  UINT32 Data;
} LER_CTRLSTS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LER_UNCERRMSK_IIO_PCIENTB_REG supported on:                                */
/*       IVT_EP (0x4001828C)                                                  */
/*       IVT_EX (0x4001828C)                                                  */
/*       HSX (0x4001828C)                                                     */
/*       BDX (0x4001828C)                                                     */
/* Register default value:              0x00000000                            */
#define LER_UNCERRMSK_IIO_PCIENTB_REG 0x1000428C
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.3.0.Port3_NTB.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIENTB_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Live Error Recovery Uncorrectable Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_err_mask : 1;
    /* ecrc_err_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIENTB_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* LER_XPUNCERRMSK_IIO_PCIENTB_REG supported on:                              */
/*       IVT_EP (0x40018290)                                                  */
/*       IVT_EX (0x40018290)                                                  */
/*       HSX (0x40018290)                                                     */
/*       BDX (0x40018290)                                                     */
/* Register default value:              0x00000000                            */
#define LER_XPUNCERRMSK_IIO_PCIENTB_REG 0x10004290
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Live Error Recovery XP Uncorrectable Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 sent_completion_with_ca_mask : 1;
    /* sent_completion_with_ca_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_ur_mask : 1;
    /* sent_completion_with_ur_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0 
       Masks signaling of stop and scream condition to the core error logic.
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_XPUNCERRMSK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* LER_RPERRMSK_IIO_PCIENTB_REG supported on:                                 */
/*       IVT_EP (0x40018294)                                                  */
/*       IVT_EX (0x40018294)                                                  */
/*       HSX (0x40018294)                                                     */
/*       BDX (0x40018294)                                                     */
/* Register default value:              0x00000000                            */
#define LER_RPERRMSK_IIO_PCIENTB_REG 0x10004294
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Live Error Recovery Root Port Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 non_fatal_error_message_received_mask : 1;
    /* non_fatal_error_message_received_mask - Bits[5:5], RWS, default = 1'b0 
       Masks LER response to Non-Fatal Error Messages received.
     */
    UINT32 fatal_error_message_received_mask : 1;
    /* fatal_error_message_received_mask - Bits[6:6], RWS, default = 1'b0 
       Masks LER response to Fatal Error Messages received
     */
    UINT32 rsvd_7 : 25;
    /* rsvd_7 - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_RPERRMSK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */


/* RPPIOERR_CAP_IIO_PCIENTB_REG supported on:                                 */
/*       HSX (0x40018298)                                                     */
/*       BDX (0x40018298)                                                     */
/* Register default value:              0x3001000B                            */
#define RPPIOERR_CAP_IIO_PCIENTB_REG 0x10004298

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCIe spec-defined capability register for enhanced root port PIO error 
 * reporting. 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe extended capability ID.
       Set to 0xb for vendor-specific capability.
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability version.
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001100000000 
       Next capability pointer.
       May not point to 0x300 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_CAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDR_IIO_PCIENTB_REG supported on:                                 */
/*       HSX (0x4001829C)                                                     */
/*       BDX (0x4001829C)                                                     */
/* Register default value:              0x02400007                            */
#define RPPIOERR_HDR_IIO_PCIENTB_REG 0x1000429C

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * PCIe spec-defined vendor-specific header register for enhanced root port PIO 
 * error reporting. 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000111 
       Vendor-specific capability ID. Intel defines 0x7 as the ID for enhanced root 
       port PIO error reporting. 
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000 
       VSEC revision.
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000100100 
       VSEC length.
       Length of the RP_PIO_ERR capability in bytes, starting from the capability ID.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HF_IIO_PCIENTB_REG supported on:                                  */
/*       HSX (0x400182A0)                                                     */
/*       BDX (0x400182A0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HF_IIO_PCIENTB_REG 0x100042A0

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Register that controls which PIO errors should cause a poison indication.
 */
typedef union {
  struct {
    UINT32 cfg_ur_hf : 1;
    /* cfg_ur_hf - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all configuration requests targeting 
       the PCIe hierarchy below the Root Port will be treated as UR, and will return 
       poison if this bit is set. 
     */
    UINT32 cfg_ca_hf : 1;
    /* cfg_ca_hf - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 cfg_to_hf : 1;
    /* cfg_to_hf - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_hf : 1;
    /* io_ur_hf - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all IO requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 io_ca_hf : 1;
    /* io_ca_hf - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 io_to_hf : 1;
    /* io_to_hf - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_hf : 1;
    /* mem_ur_hf - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all memory requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 mem_ca_hf : 1;
    /* mem_ca_hf - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 mem_to_hf : 1;
    /* mem_to_hf - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HF_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_STATUS_IIO_PCIENTB_REG supported on:                              */
/*       HSX (0x400182A4)                                                     */
/*       BDX (0x400182A4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_STATUS_IIO_PCIENTB_REG 0x100042A4

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Register that logs the PIO errors.  Note that PIO UR errors that occur after LER 
 * has been triggered will not update this register. 
 * If a PIO error is detected and the corresponding RPPIOERR_MASK bit is cleared, 
 * then LER will be triggered if LER is enabled, and pio_err_first_header and 
 * RPPIOERR_HDRLOG[0-3] may update. 
 * Regardless of the state of the corresponding RPPIOERR_MASK bit, a PIO error may 
 * update its status bit in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_err : 1;
    /* cfg_ur_err - Bits[0:0], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ur_mask). 
     */
    UINT32 cfg_ca_err : 1;
    /* cfg_ca_err - Bits[1:1], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ca_mask). 
     */
    UINT32 cfg_to_err : 1;
    /* cfg_to_err - Bits[2:2], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_err : 1;
    /* io_ur_err - Bits[8:8], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ur_mask). 
     */
    UINT32 io_ca_err : 1;
    /* io_ca_err - Bits[9:9], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ca_mask). 
     */
    UINT32 io_to_err : 1;
    /* io_to_err - Bits[10:10], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.io_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_err : 1;
    /* mem_ur_err - Bits[16:16], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ur_mask). 
     */
    UINT32 mem_ca_err : 1;
    /* mem_ca_err - Bits[17:17], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ca_mask). 
     */
    UINT32 mem_to_err : 1;
    /* mem_to_err - Bits[18:18], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 pio_err_first_header : 5;
    /* pio_err_first_header - Bits[23:19], RW1CS, default = 5'b00000 
       These 5 bits identify the first unmasked (by rppioerr_mask) RPPIO error that was 
       observed. The encoding is as follows: 
       00: No Error
       01: CFG_UR_ERR
       02: CFG_CA_ERR
       03: CFG_TO_ERR
       04: IO_UR_ERR
       05: IO_CA_ERR
       06: IO_TO_ERR
       07: MEM_UR_ERR
       08: MEM_CA_ERR
       09: MEM_TO_ERR
       Others: undefined
       Note these bits will not record subsequent errors until the first error is 
       cleared by SW. 
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_STATUS_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_MASK_IIO_PCIENTB_REG supported on:                                */
/*       HSX (0x400182A8)                                                     */
/*       BDX (0x400182A8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_MASK_IIO_PCIENTB_REG 0x100042A8

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Register that masks triggering of LER on PIO errors.  When clear, LER will be 
 * triggered when LER is enabled and an error sets the corresponding bit in the 
 * RPPIOERR_STATUS. 
 * When RPPIOERR_STATUS is used to trigger LER, it is expected the end user will 
 * program the LER_XPUNCERRMSK and XPUNCERRMSK registers correctly so that they do 
 * not trigger a LER event also. 
 * If LER_CTRLSTS.LER_Enable is not set, LER will not be triggered, regardless of 
 * the setting of the RPPIOERR_MASK registers. 
 * Poison may still be returned to the requester, based on the RPPIOERR_HF 
 * register, even when the corresponding error is masked in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_mask : 1;
    /* cfg_ur_mask - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_ca_mask : 1;
    /* cfg_ca_mask - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_to_mask : 1;
    /* cfg_to_mask - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_mask : 1;
    /* io_ur_mask - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_ca_mask : 1;
    /* io_ca_mask - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_to_mask : 1;
    /* io_to_mask - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_mask : 1;
    /* mem_ur_mask - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_ca_mask : 1;
    /* mem_ca_mask - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_to_mask : 1;
    /* mem_to_mask - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_MASK_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG0_IIO_PCIENTB_REG supported on:                             */
/*       HSX (0x400182AC)                                                     */
/*       BDX (0x400182AC)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG0_IIO_PCIENTB_REG 0x100042AC

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 0 ([31:24]), 1 ([23:16]), 2 ([15:8]), and 3 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG1_IIO_PCIENTB_REG supported on:                             */
/*       HSX (0x400182B0)                                                     */
/*       BDX (0x400182B0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG1_IIO_PCIENTB_REG 0x100042B0

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 4 ([31:24]), 5 ([23:16]), 6 ([15:8]), and 7 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG2_IIO_PCIENTB_REG supported on:                             */
/*       HSX (0x400182B4)                                                     */
/*       BDX (0x400182B4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG2_IIO_PCIENTB_REG 0x100042B4

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 8 ([31:24]), 9 ([23:16]), 10 ([15:8]), and 11 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG2_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG3_IIO_PCIENTB_REG supported on:                             */
/*       HSX (0x400182B8)                                                     */
/*       BDX (0x400182B8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG3_IIO_PCIENTB_REG 0x100042B8

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 12 ([31:24]), 13 ([23:16]), 14 ([15:8]), and 15 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG3_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CAP_HDR_IIO_PCIENTB_REG supported on:                                */
/*       HSX (0x40018300)                                                     */
/*       BDX (0x40018300)                                                     */
/* Register default value:              0x0001000B                            */
#define MCAST_CAP_HDR_IIO_PCIENTB_REG 0x10004300

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Capability Header Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_HDR_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CAP_EXT_IIO_PCIENTB_REG supported on:                                */
/*       HSX (0x40018304)                                                     */
/*       BDX (0x40018304)                                                     */
/* Register default value:              0x03800008                            */
#define MCAST_CAP_EXT_IIO_PCIENTB_REG 0x10004304

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Extended Capability Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000001000 
       Vendor-specific capability ID. Intel defines 0x8 as the ID for dualcast.
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000111000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_EXT_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CAP_IIO_PCIENTB_REG supported on:                                    */
/*       HSX (0x2001830C)                                                     */
/*       BDX (0x2001830C)                                                     */
/* Register default value:              0x000F                                */
#define MCAST_CAP_IIO_PCIENTB_REG 0x1000230C

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Capability Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Capability Register (see section 7.21.2 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_max_group : 6;
    /* mc_max_group - Bits[5:0], RO, default = 6'b001111  */
    UINT16 rsvd_6 : 2;
    /* rsvd_6 - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_window_size_req : 6;
    /* mc_window_size_req - Bits[13:8], RO, default = 6'b000000  */
    UINT16 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_ecrc_regen_sup : 1;
    /* mc_ecrc_regen_sup - Bits[15:15], RO, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CAP_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CTRL_IIO_PCIENTB_REG supported on:                                   */
/*       HSX (0x2001830E)                                                     */
/*       BDX (0x2001830E)                                                     */
/* Register default value:              0x0000                                */
#define MCAST_CTRL_IIO_PCIENTB_REG 0x1000230E

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Control Register (Dualcast is a version of PCIe Multicast supported on 
 * the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Control Register (see section 7.21.3 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_num_group : 6;
    /* mc_num_group - Bits[5:0], RW_L, default = 6'b000000 
       This field only supports and implements bits [3:0]. Bits [5:4] are not 
       supported. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[14:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_enable : 1;
    /* mc_enable - Bits[15:15], RW_L, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CTRL_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_BASE_N0_IIO_PCIENTB_REG supported on:                                */
/*       HSX (0x40018310)                                                     */
/*       BDX (0x40018310)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N0_IIO_PCIENTB_REG 0x10004310

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Base Address Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_index_position : 6;
    /* mc_index_position - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 rsvd : 6;
    /* rsvd - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mc_base_address : 20;
    /* mc_base_address - Bits[31:12], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_BASE_N1_IIO_PCIENTB_REG supported on:                                */
/*       HSX (0x40018314)                                                     */
/*       BDX (0x40018314)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N1_IIO_PCIENTB_REG 0x10004314

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Base Address Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_base_address : 32;
    /* mc_base_address - Bits[31:0], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_RCV_N0_IIO_PCIENTB_REG supported on:                                 */
/*       HSX (0x40018318)                                                     */
/*       BDX (0x40018318)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_RCV_N0_IIO_PCIENTB_REG 0x10004318

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Receive Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Receive Register (see section 7.21.5 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_rcv : 16;
    /* mc_rcv - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_RCV_N0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MCAST_BLK_ALL_N0_IIO_PCIENTB_REG supported on:                             */
/*       HSX (0x40018320)                                                     */
/*       BDX (0x40018320)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_ALL_N0_IIO_PCIENTB_REG 0x10004320

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Block All Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_All Register (see section 7.21.6 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_all : 16;
    /* mc_blk_all - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_ALL_N0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MCAST_BLK_UNT_N0_IIO_PCIENTB_REG supported on:                             */
/*       HSX (0x40018328)                                                     */
/*       BDX (0x40018328)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_UNT_N0_IIO_PCIENTB_REG 0x10004328

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Block Untranslated Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_Untranslated Register (see section 7.21.7 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_unt : 16;
    /* mc_blk_unt - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_UNT_N0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MCAST_OVERLAY_BAR_N0_IIO_PCIENTB_REG supported on:                         */
/*       HSX (0x40018330)                                                     */
/*       BDX (0x40018330)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N0_IIO_PCIENTB_REG 0x10004330

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Overlay Bar Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_size : 6;
    /* mc_overlay_size - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 mc_overlay_addr : 26;
    /* mc_overlay_addr - Bits[31:6], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N0_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_OVERLAY_BAR_N1_IIO_PCIENTB_REG supported on:                         */
/*       HSX (0x40018334)                                                     */
/*       BDX (0x40018334)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N1_IIO_PCIENTB_REG 0x10004334

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.3.0.Port3_NTB.xml.
 * Dualcast Overlay Bar Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_addr : 32;
    /* mc_overlay_addr - Bits[31:0], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N1_IIO_PCIENTB_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */








/* RID_IIO_PCIENTB_REG supported on:                                          */
/*       IVT_EP (0x10018008)                                                  */
/*       IVT_EX (0x10018008)                                                  */
/* Register default value:              0x00                                  */
#define RID_IIO_PCIENTB_REG 0x10001008



/* CCR_N0_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x10018009)                                                  */
/*       IVT_EX (0x10018009)                                                  */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_PCIENTB_REG 0x10001009



/* CCR_N1_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x2001800A)                                                  */
/*       IVT_EX (0x2001800A)                                                  */
/* Register default value:              0x0680                                */
#define CCR_N1_IIO_PCIENTB_REG 0x1000200A



/* XPPMDFXMAT0_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x400182F0)                                                  */
/*       IVT_EX (0x400182F0)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMDFXMAT0_IIO_PCIENTB_REG 0x100042F0





/* XPPMDFXMSK0_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x400182F8)                                                  */
/*       IVT_EX (0x400182F8)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMDFXMSK0_IIO_PCIENTB_REG 0x100042F8



/* XPPMDFXMSK1_IIO_PCIENTB_REG supported on:                                  */
/*       IVT_EP (0x400182FC)                                                  */
/*       IVT_EX (0x400182FC)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMDFXMSK1_IIO_PCIENTB_REG 0x100042FC



/* XPPMDL0_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018480)                                                  */
/*       IVT_EX (0x40018480)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMDL0_IIO_PCIENTB_REG 0x10004480



/* XPPMDL1_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018484)                                                  */
/*       IVT_EX (0x40018484)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMDL1_IIO_PCIENTB_REG 0x10004484



/* XPPMCL0_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x40018488)                                                  */
/*       IVT_EX (0x40018488)                                                  */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL0_IIO_PCIENTB_REG 0x10004488



/* XPPMCL1_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x4001848C)                                                  */
/*       IVT_EX (0x4001848C)                                                  */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL1_IIO_PCIENTB_REG 0x1000448C



/* XPPMDH_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018490)                                                  */
/*       IVT_EX (0x20018490)                                                  */
/* Register default value:              0x0000                                */
#define XPPMDH_IIO_PCIENTB_REG 0x10002490



/* XPPMCH_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x20018492)                                                  */
/*       IVT_EX (0x20018492)                                                  */
/* Register default value:              0x0F0F                                */
#define XPPMCH_IIO_PCIENTB_REG 0x10002492



/* XPPMR0_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x40018494)                                                  */
/*       IVT_EX (0x40018494)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMR0_IIO_PCIENTB_REG 0x10004494



/* XPPMR1_IIO_PCIENTB_REG supported on:                                       */
/*       IVT_EP (0x40018498)                                                  */
/*       IVT_EX (0x40018498)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMR1_IIO_PCIENTB_REG 0x10004498



/* XPPMEVL0_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x4001849C)                                                  */
/*       IVT_EX (0x4001849C)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMEVL0_IIO_PCIENTB_REG 0x1000449C



/* XPPMEVL1_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x400184A0)                                                  */
/*       IVT_EX (0x400184A0)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMEVL1_IIO_PCIENTB_REG 0x100044A0



/* XPPMEVH0_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x400184A4)                                                  */
/*       IVT_EX (0x400184A4)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMEVH0_IIO_PCIENTB_REG 0x100044A4



/* XPPMEVH1_IIO_PCIENTB_REG supported on:                                     */
/*       IVT_EP (0x400184A8)                                                  */
/*       IVT_EX (0x400184A8)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMEVH1_IIO_PCIENTB_REG 0x100044A8



/* XPPMER0_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x400184AC)                                                  */
/*       IVT_EX (0x400184AC)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMER0_IIO_PCIENTB_REG 0x100044AC



/* XPPMER1_IIO_PCIENTB_REG supported on:                                      */
/*       IVT_EP (0x400184B0)                                                  */
/*       IVT_EX (0x400184B0)                                                  */
/* Register default value:              0x00000000                            */
#define XPPMER1_IIO_PCIENTB_REG 0x100044B0



#endif /* IIO_PCIENTB_h */
