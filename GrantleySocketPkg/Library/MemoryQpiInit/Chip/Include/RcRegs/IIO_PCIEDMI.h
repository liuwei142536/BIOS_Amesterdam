/* Date Stamp: 8/23/2014 */

#ifndef IIO_PCIEDMI_h
#define IIO_PCIEDMI_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* IIO_PCIEDMI_DEV 0                                                          */
/* IIO_PCIEDMI_FUN 0                                                          */

/* VID_IIO_PCIEDMI_REG supported on:                                          */
/*       IVT_EP (0x20000000)                                                  */
/*       IVT_EX (0x20000000)                                                  */
/*       HSX (0x20000000)                                                     */
/*       BDX (0x20000000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_PCIEDMI_REG 0x0E002000
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DID_IIO_PCIEDMI_REG supported on:                                          */
/*       IVT_EP (0x20000002)                                                  */
/*       IVT_EX (0x20000002)                                                  */
/*       HSX (0x20000002)                                                     */
/*       BDX (0x20000002)                                                     */
/* Register default value on IVT_EP:    0x0E01                                */
/* Register default value on IVT_EX:    0x0E01                                */
/* Register default value on HSX:       0x2F01                                */
/* Register default value on BDX:       0x6F01                                */
#define DID_IIO_PCIEDMI_REG 0x0E002002
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO_V, default = 16'b0110111100000001 
       Device ID values vary from function to function. Bits 15:8 are equal to 0x6F for 
       the processor. The following list is a breakdown of the function groups. 
       0x6F00 - 0x6F1F : PCI Express and DMI ports
       0x6F20 - 0x6F3F : IO Features (Intel QuickData Technology, APIC, VT, RAS, Intel 
       TXT) 
       0x6F40 - 0x6F5F : Performance Monitors
       0x6F60 - 0x6F7F : DFX
       0x6F80 - 0x6F9F : Intel QPI
       0x6FA0 - 0x6FBF : Home Agent/Memory Controller
       0x6FC0 - 0x6FDF : Power Management
       0x6FE0 - 0x6FFF : Cbo/Ring
       
       Hardware sets this field based on the operating mode of this dev/fn:
       DMI => 0x6F00
       PCIe => 0x6F01
       Default value may vary based on bus, device, and function of this CSR location.
     */
  } Bits;
  UINT16 Data;
} DID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PCICMD_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x20000004)                                                  */
/*       IVT_EX (0x20000004)                                                  */
/*       HSX (0x20000004)                                                     */
/*       BDX (0x20000004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_PCIEDMI_REG 0x0E002004
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x004
 */
typedef union {
  struct {
    UINT16 iose : 1;
    /* iose - Bits[0:0], RW_L, default = 1'b0 
       1: Enables the I/O address range, defined in the IOBASE and IOLIM registers of 
       the PCI-to-PCI bridge header, for target decode from primary side. 
       0: Disables the I/O address range, defined in the IOBASE and IOLIM registers of 
       the PCI-to-PCI bridge header, for target decode from primary side. 
       
       Notes:
       Note this bit is not ever used by hardware to decode transactions from the 
       secondary side of the root port. 
       This bit is hardwired to 0 in DMI Mode, since the DMI is not a P2P bridge and 
       does not claim any IO resource on its own. Hardware should not use this bit to 
       determine if it can forward memory requests to DMI while in DMI Mode. 
       NTB does not support I/O space accesses. Hardwired to 0.
     */
    UINT16 mse : 1;
    /* mse - Bits[1:1], RW_L, default = 1'b0 
       1
     */
    UINT16 bme : 1;
    /* bme - Bits[2:2], RW_L, default = 1'b0 
       Bus Master Enable
       Controls the ability of the PCI Express port in generating and also in 
       forwarding memory (including MSI writes) or I/O transactions (and not messages) 
       or configuration transactions from the secondary side to the primary side. 
       1: Enables the PCI Express port to a) generate MSI writes internally for 
       AER/HP/PM events (note: there are several other RP MSI related control/enable 
       bits. See the RAS Chapter and PCI Express Base Specification, Revision 2.0 for 
       complete details) and also to b) forward memory (including MSI writes from 
       devices south of the RP), config or I/O read/write requests from secondary to 
       primary side 
       0: The Bus Master is disabled. When this bit is 0, IIO root ports will a) treat 
       upstream PCI Express memory writes/reads, IO writes/reads, and configuration 
       reads and writes as unsupported requests (and follow the rules for handling 
       unsupported requests). This behavior is also true towards transactions that are 
       already pending in the IIO root port's internal queues when the BME bit is 
       turned off. b) mask the root port from generating MSI writes internally for 
       AER/HP/PM events at the root port. 
     */
    UINT16 sce : 1;
    /* sce - Bits[3:3], RO, default = 1'b0 
       Special Cycle Enable
       Not applicable to DMI/PCI Express devices. Hardwired to 0.
     */
    UINT16 mwie : 1;
    /* mwie - Bits[4:4], RO, default = 1'b0 
       Memory Write and Invalidate Enable
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 perre : 1;
    /* perre - Bits[6:6], RW, default = 1'b0 
       Parity Error Reporting Enable
       For PCI Express ports, IIO ignores this bit and always does parity checking and 
       signaling for data/address of transactions both to and from root port. This bit 
       though affects the setting of bit 8 in the PCISTS register. 
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 serre : 1;
    /* serre - Bits[8:8], RW, default = 1'b0 
       SERR Reporting Enable
       For PCI Express ports, this field enables notifying the internal IIO core error 
       logic of occurrence of an uncorrectable error (fatal or non-fatal) at the port. 
       The internal core error logic of IIO then decides if/how to escalate the error 
       further (pins/message etc.). Note this bit also controls the propagation of PCI 
       Express ERR_FATAL and ERR_NONFATAL messages received from the port to the 
       internal IIO core error logic. 
       1: Fatal and Non-fatal error message generation and Fatal and Non-fatal error 
       message forwarding is enabled 
       0: Fatal and Non-fatal error message generation and Fatal and Non-fatal error 
       message forwarding is disabled 
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0.
     */
    UINT16 interrupt_disable : 1;
    /* interrupt_disable - Bits[10:10], RW, default = 1'b0 
       1
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PCISTS_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x20000006)                                                  */
/*       IVT_EX (0x20000006)                                                  */
/*       HSX (0x20000006)                                                     */
/*       BDX (0x20000006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_PCIEDMI_REG 0x0E002006
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCI Status
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO_V, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure.
     */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0 
       Master Data Parity Error
       This bit is set by a root port if the Parity Error Response bit in the PCI 
       Command register is set and it either receives a completion with poisoned data 
       from the primary side or it forwards a packet with data (including MSI writes) 
       to the primary side with poison. 
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0 
       Signalled Target Abort
       This bit is set when a root port signals a completer abort completion status on 
       the primary side (internal bus of uncore). This condition includes a PCI Express 
       port forwarding a completer abort status received on a completion from the 
       secondary 
     */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0 
       Received Target Abort
       This bit is set when a device experiences a completer abort condition on a 
       transaction it mastered on the primary interface (uncore internal bus). Note 
       that certain errors might be detected right at the PCI Express interface and 
       those transactions might not 'propagate' to the primary interface before the 
       error is detected (e.g. accesses to memory above VTBAR). Such errors do not 
       cause this bit to be set, and are reported via the PCI Express interface error 
       bits (secondary status register). 
       Conditions that cause bit 12 to be set, include:
       - Device receives a completion on the primary interface (internal bus of uncore) 
       with completer abort completion Status. This includes CA status received on the 
       primary side of a PCI Express port on peer-to-peer completions also. 
       - Other completer abort conditions detected on the uncore internal bus.
     */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0 
       Received Master Abort
       This bit is set when a root port experiences a master abort condition on a 
       transaction it mastered on the primary interface (uncore internal bus). 
       Note that certain errors might be detected right at the PCI Express interface 
       and those transactions might not 'propagate' to the primary interface before the 
       error is detected (e.g. accesses to memory above TOCM in cases where the PCIE 
       interface logic itself might have visibility into TOCM). Such errors do not 
       cause this bit to be set, and are reported via the PCI Express interface error 
       bits (secondary status register). 
       Conditions that cause bit 13 to be set, include:
       - Device receives a completion on the primary interface (internal bus of uncore) 
       with Unsupported Request or master abort completion Status. This includes UR 
       status received on the primary side of a PCI Express port on peer-to-peer 
       completions also. 
       - Other master abort conditions detected on the IIO internal bus amongst those 
       listed in the Chapter 5, 'Inbound Address Decoding,' chapter. 
     */
    UINT16 sse : 1;
    /* sse - Bits[14:14], RW1C, default = 1'b0 
       Signalled System Error
       1: The root port reported fatal/non-fatal (and not correctable) errors it 
       detected on its PCI Express (or DMI) interface to the IIO core error logic 
       (which might eventually escalate the error through the ERR[2:0] pins or message 
       to cpu core or message to PCH). Note that the SERRE bit in the PCICMD register 
       must be set for a device to report the error the IIO core error logic.Software 
       clears this bit by writing a '1' to it. This bit is also set (when SERR enable 
       bit is set) when a FATAL/NON-FATAL message is forwarded to the IIO core error 
       logic. Note that IIO internal 'core' errors (like parity error in the internal 
       queues) are not reported via this bit. 
       0: The root port did not report a fatal/non-fatal error
     */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0 
       Detected Parity Error
       This bit is set by a root port when it receives a packet on the primary side 
       with an uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* CLSR_IIO_PCIEDMI_REG supported on:                                         */
/*       IVT_EP (0x1000000C)                                                  */
/*       IVT_EX (0x1000000C)                                                  */
/*       HSX (0x1000000C)                                                     */
/*       BDX (0x1000000C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_PCIEDMI_REG 0x0E00100C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only.
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PLAT_IIO_PCIEDMI_REG supported on:                                         */
/*       IVT_EP (0x1000000D)                                                  */
/*       IVT_EX (0x1000000D)                                                  */
/*       HSX (0x1000000D)                                                     */
/*       BDX (0x1000000D)                                                     */
/* Register default value:              0x00                                  */
#define PLAT_IIO_PCIEDMI_REG 0x0E00100D
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x00d
 */
typedef union {
  struct {
    UINT8 primary_latency_timer : 8;
    /* primary_latency_timer - Bits[7:0], RO, default = 8'b00000000 
       Not applicable to PCI-Express. Hardwired to 00h.
     */
  } Bits;
  UINT8 Data;
} PLAT_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* HDR_IIO_PCIEDMI_REG supported on:                                          */
/*       IVT_EP (0x1000000E)                                                  */
/*       IVT_EX (0x1000000E)                                                  */
/*       HSX (0x1000000E)                                                     */
/*       BDX (0x1000000E)                                                     */
/* Register default value:              0x00                                  */
#define HDR_IIO_PCIEDMI_REG 0x0E00100E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x00e
 */
typedef union {
  struct {
    UINT8 cl : 7;
    /* cl - Bits[6:0], RO_V, default = 7'b0000000 
       This field identifies the format of the configuration header layout.
       In DMI mode, default is 00h indicating a conventional type 00h PCI header.
       In PCIe mode, the default is 01h, corresponding to Type 1 for a PCIe root port.
     */
    UINT8 mfd : 1;
    /* mfd - Bits[7:7], RO, default = 1'b0 
       This bit defaults to 0 for Device 0.
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* BIST_IIO_PCIEDMI_REG supported on:                                         */
/*       IVT_EP (0x1000000F)                                                  */
/*       IVT_EX (0x1000000F)                                                  */
/*       HSX (0x1000000F)                                                     */
/*       BDX (0x1000000F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_IIO_PCIEDMI_REG 0x0E00100F
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x00f
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} BIST_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* SVID_IIO_PCIEDMI_REG supported on:                                         */
/*       IVT_EP (0x2000002C)                                                  */
/*       IVT_EX (0x2000002C)                                                  */
/*       HSX (0x2000002C)                                                     */
/*       BDX (0x2000002C)                                                     */
/* Register default value:              0x8086                                */
#define SVID_IIO_PCIEDMI_REG 0x0E00202C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_id : 16;
    /* subsystem_vendor_id - Bits[15:0], RW_O, default = 16'b1000000010000110  */
  } Bits;
  UINT16 Data;
} SVID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* SDID_IIO_PCIEDMI_REG supported on:                                         */
/*       IVT_EP (0x2000002E)                                                  */
/*       IVT_EX (0x2000002E)                                                  */
/*       HSX (0x2000002E)                                                     */
/*       BDX (0x2000002E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_PCIEDMI_REG 0x0E00202E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_id : 16;
    /* subsystem_device_id - Bits[15:0], RW_O, default = 16'b0000000000000000  */
  } Bits;
  UINT16 Data;
} SDID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* CAPPTR_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x10000034)                                                  */
/*       IVT_EX (0x10000034)                                                  */
/*       HSX (0x10000034)                                                     */
/*       BDX (0x10000034)                                                     */
/* Register default value:              0x90                                  */
#define CAPPTR_IIO_PCIEDMI_REG 0x0E001034
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO_V, default = 8'b10010000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* INTL_IIO_PCIEDMI_REG supported on:                                         */
/*       IVT_EP (0x1000003C)                                                  */
/*       IVT_EX (0x1000003C)                                                  */
/*       HSX (0x1000003C)                                                     */
/*       BDX (0x1000003C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_PCIEDMI_REG 0x0E00103C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* INTPIN_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x1000003D)                                                  */
/*       IVT_EX (0x1000003D)                                                  */
/*       HSX (0x1000003D)                                                     */
/*       BDX (0x1000003D)                                                     */
/* Register default value:              0x01                                  */
#define INTPIN_IIO_PCIEDMI_REG 0x0E00103D
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x03d
 */
typedef union {
  struct {
    UINT8 intp : 8;
    /* intp - Bits[7:0], RW_O, default = 8'b00000001 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DMIRCBAR_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x40000050)                                                  */
/*       IVT_EX (0x40000050)                                                  */
/*       HSX (0x40000050)                                                     */
/*       BDX (0x40000050)                                                     */
/* Register default value:              0x00000000                            */
#define DMIRCBAR_IIO_PCIEDMI_REG 0x0E004050
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x050
 */
typedef union {
  struct {
    UINT32 dmircbaren : 1;
    /* dmircbaren - Bits[0:0], RW_LB, default = 1'b0 
       0: DMIRCBAR is disabled and does not claim any memory
       1: DMIRCBAR memory mapped accesses are claimed and decoded
       
       Notes:
       Accesses to registers pointed to by the DMIRCBAR, via message channel or JTAG 
       mini-port are not gated by this enable bit i.e. accesses these registers are 
       honored regardless of the setting of this bit. 
       
       BIOS sets this bit only when it wishes to update the registers in the DMIRCBAR. 
       It must clear this bit when it has finished changing values. This is required to 
       ensure that the registers cannot be changed during an Intel TXT lock. This bit 
       is protected by Intel TXT mode, but the registers in DMIRCBAR are not protected 
       except by this bit. 
     */
    UINT32 rsvd : 11;
    /* rsvd - Bits[11:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dmircbar : 20;
    /* dmircbar - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       This field corresponds to bits 32 to 12 of the base address DMI Root Complex 
       register space. BIOS will program this register resulting in a base address for 
       a 4KB block of contiguous memory address space. This register ensures that a 
       naturally aligned 4KB space is allocated within the first 64GB of addressable 
       memory space. System Software uses this base address to program the DMI Root 
       Complex register set. 
       
       All the Bits in this register are locked in Intel TXT mode.
     */
  } Bits;
  UINT32 Data;
} DMIRCBAR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSICAPID_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x10000060)                                                  */
/*       IVT_EX (0x10000060)                                                  */
/*       HSX (0x10000060)                                                     */
/*       BDX (0x10000060)                                                     */
/* Register default value:              0x05                                  */
#define MSICAPID_IIO_PCIEDMI_REG 0x0E001060
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x060
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000101 
       Assigned by PCI-SIG for MSI (root ports).
     */
  } Bits;
  UINT8 Data;
} MSICAPID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSINXTPTR_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x10000061)                                                  */
/*       IVT_EX (0x10000061)                                                  */
/*       HSX (0x10000061)                                                     */
/*       BDX (0x10000061)                                                     */
/* Register default value:              0x90                                  */
#define MSINXTPTR_IIO_PCIEDMI_REG 0x0E001061
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x061
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RW_O, default = 8'b10010000 
       This field is set to 90h for the next capability list (PCI Express capability 
       structure) in the chain. 
     */
  } Bits;
  UINT8 Data;
} MSINXTPTR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSIMSGCTL_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x20000062)                                                  */
/*       IVT_EX (0x20000062)                                                  */
/*       HSX (0x20000062)                                                     */
/*       BDX (0x20000062)                                                     */
/* Register default value:              0x0102                                */
#define MSIMSGCTL_IIO_PCIEDMI_REG 0x0E002062
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x062
 */
typedef union {
  struct {
    UINT16 msien : 1;
    /* msien - Bits[0:0], RW, default = 1'b0 
       Software sets this bit to select INTx style interrupt or MSI interrupt for root 
       port generated interrupts. 
       
       0: INTx interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       1: MSI interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       Note there bits 4:2 and bit 2 MISCCTRLSTS can disable both MSI and INTx 
       interrupt from being generated on root port interrupt events. 
     */
    UINT16 mmc : 3;
    /* mmc - Bits[3:1], RO, default = 3'b001 
       Multiple Message Capable
       IIO Root Ports support two messages for all their internal events.
     */
    UINT16 mme : 3;
    /* mme - Bits[6:4], RW, default = 3'b000 
       Applicable only to PCI Express ports. Software writes to this field to indicate 
       the number of allocated messages which is aligned to a power of two. When MSI is 
       enabled, the software will allocate at least one message to the device. A value 
       of 000 indicates 1 message. Any value greater than or equal to 001 indicates a 
       message of 2. 
       
       See MSIDR for discussion on how the interrupts are distributed amongst the 
       various sources of interrupt based on the number of messages allocated by 
       software for the PCI Express ports. 
     */
    UINT16 b64ac : 1;
    /* b64ac - Bits[7:7], RO, default = 1'b0 
       This field is hardwired to 0h since the message addresses are only 32-bit 
       addresses (e.g. FEEx_xxxxh). 
     */
    UINT16 pvmc : 1;
    /* pvmc - Bits[8:8], RO, default = 1'b1 
       This bit indicates that PCI Express ports support MSI per-vector masking.
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} MSIMSGCTL_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSGADR_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x40000064)                                                  */
/*       IVT_EX (0x40000064)                                                  */
/*       HSX (0x40000064)                                                     */
/*       BDX (0x40000064)                                                     */
/* Register default value:              0x00000000                            */
#define MSGADR_IIO_PCIEDMI_REG 0x0E004064
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * The MSI Address Register (MSIAR) contains the system specific address 
 * information to route MSI interrupts from the root ports and is broken into its 
 * constituent fields. 
 */
typedef union {
  struct {
    UINT32 rsvd : 2;
    /* rsvd - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 address_id : 30;
    /* address_id - Bits[31:2], RW, default = 30'b000000000000000000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
  } Bits;
  UINT32 Data;
} MSGADR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSGDAT_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x40000068)                                                  */
/*       IVT_EX (0x40000068)                                                  */
/*       HSX (0x40000068)                                                     */
/*       BDX (0x40000068)                                                     */
/* Register default value:              0x00000000                            */
#define MSGDAT_IIO_PCIEDMI_REG 0x0E004068
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x068
 */
typedef union {
  struct {
    UINT32 data : 16;
    /* data - Bits[15:0], RW, default = 16'b0000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSGDAT_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSIMSK_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x4000006C)                                                  */
/*       IVT_EX (0x4000006C)                                                  */
/*       HSX (0x4000006C)                                                     */
/*       BDX (0x4000006C)                                                     */
/* Register default value:              0x00000000                            */
#define MSIMSK_IIO_PCIEDMI_REG 0x0E00406C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x06c
 */
typedef union {
  struct {
    UINT32 mask_bits : 2;
    /* mask_bits - Bits[1:0], RW, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. For each Mask bit that is set, the PCI Express port is prohibited from 
       sending the associated message. When only one message is allocated to the root 
       port by software, only mask bit 0 is relevant and used by hardware. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIMSK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MSIPENDING_IIO_PCIEDMI_REG supported on:                                   */
/*       IVT_EP (0x40000070)                                                  */
/*       IVT_EX (0x40000070)                                                  */
/*       HSX (0x40000070)                                                     */
/*       BDX (0x40000070)                                                     */
/* Register default value:              0x00000000                            */
#define MSIPENDING_IIO_PCIEDMI_REG 0x0E004070
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x070
 */
typedef union {
  struct {
    UINT32 pending_bits : 2;
    /* pending_bits - Bits[1:0], RO_V, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. When MSI is not enabled or used by the root port, this register always 
       reads a value 0. For each Pending bit that is set, the PCI Express port has a 
       pending associated message. When only one message is allocated to the root port 
       by software, only pending bit 0 is set/cleared by hardware and pending bit 1 
       always reads 0. 
       Hardware sets this bit whenever it has an interrupt pending to be sent. This bit 
       remains set till either the interrupt is sent by hardware or the status bits 
       associated with the interrupt condition are cleared by software. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIPENDING_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PXPCAPID_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x10000090)                                                  */
/*       IVT_EX (0x10000090)                                                  */
/*       HSX (0x10000090)                                                     */
/*       BDX (0x10000090)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_PCIEDMI_REG 0x0E001090
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x090
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PXPNXTPTR_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x10000091)                                                  */
/*       IVT_EX (0x10000091)                                                  */
/*       HSX (0x10000091)                                                     */
/*       BDX (0x10000091)                                                     */
/* Register default value:              0xE0                                  */
#define PXPNXTPTR_IIO_PCIEDMI_REG 0x0E001091
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x091
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b11100000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PXPCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x20000092)                                                  */
/*       IVT_EX (0x20000092)                                                  */
/*       HSX (0x20000092)                                                     */
/*       BDX (0x20000092)                                                     */
/* Register default value:              0x0042                                */
#define PXPCAP_IIO_PCIEDMI_REG 0x0E002092
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x092
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RW_O, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure, which 
       is 2h as of now. This register field is left as RW-O to cover any unknowns with 
       Gen3. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO_V, default = 4'b0100 
       This field identifies the type of device. It is set to 0100 for all the Express 
       ports. 
     */
    UINT16 slot_implemented : 1;
    /* slot_implemented - Bits[8:8], RW_O, default = 1'b0 
       Applies only to the root ports.
       1: indicates that the PCI Express link associated with the port is connected to 
       a slot. 
       0: indicates no slot is connected to this port.
       
       Notes:
       This register bit is of type 'write once' and is set by BIOS.
     */
    UINT16 interrupt_message_number : 5;
    /* interrupt_message_number - Bits[13:9], RO, default = 5'b00000 
       Applies to root ports. This field indicates the interrupt message number that is 
       generated for Power Management/Hot Plug/Bandwidth-change events. When there are 
       more than one MSI interrupt Number allocated for the root port MSI interrupts, 
       this register field is required to contain the offset between the base Message 
       Data and the MSI Message that is generated when there are these change 
       interrupts. IIO assigns the first vector for these change events and so this 
       field is set to 0. 
     */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DEVCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x40000094)                                                  */
/*       IVT_EX (0x40000094)                                                  */
/*       HSX (0x40000094)                                                     */
/*       BDX (0x40000094)                                                     */
/* Register default value:              0x00008000                            */
#define DEVCAP_IIO_PCIEDMI_REG 0x0E004094
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * The PCI Express Device Capabilities register identifies device specific 
 * information for the device. 
 */
typedef union {
  struct {
    UINT32 max_payload_size_supported : 3;
    /* max_payload_size_supported - Bits[2:0], RO, default = 3'b000 
       1
     */
    UINT32 phantom_functions_supported : 2;
    /* phantom_functions_supported - Bits[4:3], RO, default = 2'b00 
       CB DMA does not support phantom functions.
     */
    UINT32 extended_tag_field_supported : 1;
    /* extended_tag_field_supported - Bits[5:5], RW_O, default = 1'b0  */
    UINT32 endpoint_l0s_acceptable_latency : 3;
    /* endpoint_l0s_acceptable_latency - Bits[8:6], RO, default = 3'b000 
       N/A
     */
    UINT32 endpoint_l1_acceptable_latency : 3;
    /* endpoint_l1_acceptable_latency - Bits[11:9], RO, default = 3'b000 
       N/A
     */
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[12:12], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[13:13], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 power_indicator_present_on_device : 1;
    /* power_indicator_present_on_device - Bits[14:14], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 role_based_error_reporting : 1;
    /* role_based_error_reporting - Bits[15:15], RO, default = 1'b1 
       IIO is 1.1 compliant and so supports this feature
     */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 captured_slot_power_limit_value : 8;
    /* captured_slot_power_limit_value - Bits[25:18], RO, default = 8'b00000000 
       Does not apply to CB DMA
     */
    UINT32 captured_slot_power_limit_scale : 2;
    /* captured_slot_power_limit_scale - Bits[27:26], RO, default = 2'b00 
       Does not apply to CB DMA
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LNKCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x4000009C)                                                  */
/*       IVT_EX (0x4000009C)                                                  */
/*       HSX (0x4000009C)                                                     */
/*       BDX (0x4000009C)                                                     */
/* Register default value:              0x00793841                            */
#define LNKCAP_IIO_PCIEDMI_REG 0x0E00409C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x09c
 */
typedef union {
  struct {
    UINT32 maxlnkspd : 4;
    /* maxlnkspd - Bits[3:0], RW_O, default = 4'b0001 
       This field indicates the maximum link speed of this Port.
       The encoding is the binary value of the bit location in the Supported Link 
       Speeds Vector (in LNKCAP2) that corresponds to the maximum link speed. 
       0001b = (2.5Gbps)
       0010b = (5Gbps)
       0011b = (8Gbps)
     */
    UINT32 maximum_link_width : 6;
    /* maximum_link_width - Bits[9:4], RW_O, default = 6'b000100 
       This field indicates the maximum width of the given PCI Express Link attached to 
       the port. 
       000001: x1
       000010: x2
       000100: x4
       001000: x8
       010000: x16
       Others: Reserved
       
       This is left as a RW-O register for bios to update based on the platform usage 
       of the links. 
     */
    UINT32 active_state_link_pm_support : 2;
    /* active_state_link_pm_support - Bits[11:10], RW_O, default = 2'b10 
       This field indicates the level of active state power management supported on the 
       given PCI-Express port. 
       00: Disabled
       01: L0s Entry Supported
       10: L1 Entry Supported (Gen3; spec allows 0x2)
       11: L0s and L1 Supported
       L0s is not supported on the processor.
     */
    UINT32 l0s_exit_latency : 3;
    /* l0s_exit_latency - Bits[14:12], RW_O, default = 3'b011 
       This field indicates the L0s exit latency (i.e L0s to L0) for the PCI-Express 
       port. 
       L0s is not supported on the processor.
     */
    UINT32 l1_exit_latency : 3;
    /* l1_exit_latency - Bits[17:15], RW_O, default = 3'b010 
       This field indicates the L1 exit latency for the given PCI-Express port. It 
       indicates the length of time this port requires to complete transition from L1 
       to L0. 
       000: Less than 1us
       001: 1 us to less than 2 us
       010: 2 us to less than 4 us
       011: 4 us to less than 8 us
       100: 8 us to less than 16 us
       101: 16 us to less than 32 us
       110: 32 us to 64 us
       111: More than 64us
       
       This register is made writable once by BIOS so that the value is settable based 
       on experiments post-si. 
     */
    UINT32 clock_power_management : 1;
    /* clock_power_management - Bits[18:18], RO, default = 1'b0 
       Does not apply to processor
     */
    UINT32 surprise_down_error_reporting_capable : 1;
    /* surprise_down_error_reporting_capable - Bits[19:19], RO, default = 1'b1 
       IIO supports reporting a surprise down error condition
     */
    UINT32 data_link_layer_link_active_reporting_capable : 1;
    /* data_link_layer_link_active_reporting_capable - Bits[20:20], RO, default = 1'b1 
       IIO supports reporting status of the data link layer so software knows when it 
       can enumerate a device on the link or otherwise know the status of the link. 
     */
    UINT32 link_bandwidth_notification_capability : 1;
    /* link_bandwidth_notification_capability - Bits[21:21], RO_V, default = 1'b1 
       A value of 1b indicates support for the Link Bandwidth Notification status and 
       interrupt mechanisms. 
     */
    UINT32 aspm_optionality_compliance : 1;
    /* aspm_optionality_compliance - Bits[22:22], RW_O, default = 1'b1  */
    UINT32 rsvd : 1;
    /* rsvd - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 port_number : 8;
    /* port_number - Bits[31:24], RW_O, default = 8'b00000000 
       This field indicates the PCI Express port number for the link and is initialized 
       by software/BIOS. IIO hardware does nothing with this bit. 
     */
  } Bits;
  UINT32 Data;
} LNKCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ROOTCON_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x200000AC)                                                  */
/*       IVT_EX (0x200000AC)                                                  */
/*       HSX (0x200000AC)                                                     */
/*       BDX (0x200000AC)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCON_IIO_PCIEDMI_REG 0x0E0020AC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT16 seceen : 1;
    /* seceen - Bits[0:0], RW, default = 1'b0 
       System Error on Correctable Error Enable
       This field controls notifying the internal IIO core error logic of the 
       occurrence of a correctable error in the device or below its hierarchy. The 
       internal core error logic of IIO then decides if/how to escalate the error 
       further (pins/message etc). 
       1: indicates that an internal core error logic notification should be generated 
       if a correctable error (ERR_COR) is reported by any of the devices in the 
       hierarchy associated with and including this port. 
       0: No internal core error logic notification should be generated on a 
       correctable error (ERR_COR) reported by any of the devices in the hierarchy 
       associated with and including this port. 
       Note that generation of system notification on a PCI Express correctable error 
       is orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a correctable error or software 
       can chose one of the two. 
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode correctable errors, BIOS must set MISCCTRLSTS[33] to a 1 to override 
       this bit on Device#0 in DMI mode. 
       
     */
    UINT16 senfeen : 1;
    /* senfeen - Bits[1:1], RW, default = 1'b0 
       System Error on Non-Fatal Error Enable
       This field enables notifying the internal IIO core error logic of occurrence of 
       an uncorrectable non-fatal error at the port or below its hierarchy. The 
       internal IIO core error logic then decides if/how to escalate the error further 
       (pins/message etc). 
       1: indicates that a internal IIO core error logic notification should be 
       generated if a non-fatal error (ERR_NONFATAL) is reported by any of the devices 
       in the hierarchy associated with and including this port. 
       0: No internal core error logic notification should be generated on a non-fatal 
       error (ERR_NONFATAL) reported by any of the devices in the hierarchy associated 
       with and including this port. 
       Note that generation of system notification on a PCI Express non-fatal error is 
       orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a non-fatal error or software can 
       chose one of the two. 
       
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode non-fatal errors, BIOS must set MISCCTRLSTS[34] to a 1 to override this 
       bit on Device#0 in DMI mode. 
     */
    UINT16 sefeen : 1;
    /* sefeen - Bits[2:2], RW, default = 1'b0 
       System Error on Fatal Error Enable
       This field enables notifying the internal IIO core error logic of occurrence of 
       an uncorrectable fatal error at the port or below its hierarchy. The internal 
       core error logic of IIO then decides if/how to escalate the error further 
       (pins/message etc). Refer to RAS Chapter for details of how/which system 
       notification is generated for a PCI Express fatal error. 
       1: indicates that an internal IIO core error logic notification should be 
       generated if a fatal error (ERR_FATAL) is reported by any of the devices in the 
       hierarchy associated with and including this port. 
       0: No internal IIO core error logic notification should be generated on a fatal 
       error (ERR_FATAL) reported by any of the devices in the hierarchy associated 
       with and including this port. 
       Note that generation of system notification on a PCI Express fatal error is 
       orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a fatal error or software can 
       chose one of the two. 
       Refer to PCI Express Base Specification, Revision 2.0 for details of how this 
       bit is used in conjunction with other error control bits to generate core logic 
       notification of error events in a PCI Express port. 
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode fatal errors, BIOS must set bit MISCCTRLSTS[35] to a 1 to override this 
       bit in DMI mode. 
     */
    UINT16 pmeinten : 1;
    /* pmeinten - Bits[3:3], RW, default = 1'b0 
       This field controls the generation of MSI interrupts/INTx interrupts for PME 
       messages. 
       
       1: Enables interrupt generation upon receipt of a PME message
       0: Disables interrupt generation for PME messages
     */
    UINT16 crsswvisen : 1;
    /* crsswvisen - Bits[4:4], RW, default = 1'b0 
       CRS software visibility Enable
       1: The Root Port to returns Configuration Request Retry Status (CRS) Completion 
       Status to software by returning data of 0x01 when a configuration retry is 
       returned by the connected device. 
       0: Retry status cannot be returned to software so the Configuration Request is 
       re-issued to the connected device, unless the Configuration Retry Timer expires. 
       If the timer expires, then a master abort response is returned to software. 
     */
    UINT16 rsvd : 11;
    /* rsvd - Bits[15:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCON_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ROOTCAP_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x200000AE)                                                  */
/*       IVT_EX (0x200000AE)                                                  */
/*       HSX (0x200000AE)                                                     */
/*       BDX (0x200000AE)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCAP_IIO_PCIEDMI_REG 0x0E0020AE
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0ae
 */
typedef union {
  struct {
    UINT16 crs_software_visibility : 1;
    /* crs_software_visibility - Bits[0:0], RW_O, default = 1'b0 
       This bit when set, indicates that the Root Port is capable of returning 
       Configuration Request Retry Status (CRS) Completion Status to software. The 
       processor supports this capability. 
     */
    UINT16 rsvd : 15;
    /* rsvd - Bits[15:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DEVCAP2_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x400000B4)                                                  */
/*       IVT_EX (0x400000B4)                                                  */
/*       HSX (0x400000B4)                                                     */
/*       BDX (0x400000B4)                                                     */
/* Register default value:              0x000013BE                            */
#define DEVCAP2_IIO_PCIEDMI_REG 0x0E0040B4


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0b4
 */
typedef union {
  struct {
    UINT32 cmpltovalsup : 4;
    /* cmpltovalsup - Bits[3:0], RO, default = 4'b1110  */
    UINT32 cmpltodissup : 1;
    /* cmpltodissup - Bits[4:4], RO, default = 1'b1 
       1
     */
    UINT32 ari_en : 1;
    /* ari_en - Bits[5:5], RW_LB, default = 1'b1 
       1
     */
    UINT32 atomicroutsup : 1;
    /* atomicroutsup - Bits[6:6], RO, default = 1'b0  */
    UINT32 atomic32bcompsup : 1;
    /* atomic32bcompsup - Bits[7:7], RO, default = 1'b1  */
    UINT32 atomic64bcompsup : 1;
    /* atomic64bcompsup - Bits[8:8], RO, default = 1'b1  */
    UINT32 atomic128bcascompsup : 1;
    /* atomic128bcascompsup - Bits[9:9], RO, default = 1'b1  */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ltr_en : 1;
    /* ltr_en - Bits[11:11], RW_LB, default = 1'b0  */
    UINT32 tph_completer_supported : 2;
    /* tph_completer_supported - Bits[13:12], RW_LB, default = 2'b01 
       1
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP2_IIO_PCIEDMI_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* LNKCAP2_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x400000BC)                                                  */
/*       IVT_EX (0x400000BC)                                                  */
/*       HSX (0x400000BC)                                                     */
/*       BDX (0x400000BC)                                                     */
/* Register default value:              0x00000006                            */
#define LNKCAP2_IIO_PCIEDMI_REG 0x0E0040BC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0bc
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lnkspdvec : 7;
    /* lnkspdvec - Bits[7:1], RW_O, default = 7'b0000011 
       Supported Link Speeds Vector - This field indicates the supported Link speed(s) 
       of the associated Port. For each bit, a value of 1b indicates that the 
       corresponding Link speed is supported; otherwise, the Link speed is not 
       supported. 
       Bit definitions are:
       Bit 1 2.5 GT/s
       Bit 2 5.0 GT/s
       Bit 3 8.0 GT/s
       Bits 7:4 reserved
       
     */
    UINT32 rsvd_8 : 24;
    /* rsvd_8 - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCAP2_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PMCAP_IIO_PCIEDMI_REG supported on:                                        */
/*       IVT_EP (0x400000E0)                                                  */
/*       IVT_EX (0x400000E0)                                                  */
/*       HSX (0x400000E0)                                                     */
/*       BDX (0x400000E0)                                                     */
/* Register default value:              0xC8030001                            */
#define PMCAP_IIO_PCIEDMI_REG 0x0E0040E0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0e0
 */
typedef union {
  struct {
    UINT32 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000001 
       Provides the PM capability ID assigned by PCI-SIG.
     */
    UINT32 next_capability_pointer : 8;
    /* next_capability_pointer - Bits[15:8], RO, default = 8'b00000000 
       This is the last capability in the chain and hence set to 0.
     */
    UINT32 version : 3;
    /* version - Bits[18:16], RO, default = 3'b011 
       This field is set to 3h (PM 1.2 compliant) as version number.
     */
    UINT32 pme_clock : 1;
    /* pme_clock - Bits[19:19], RO, default = 1'b0 
       This field is hardwired to 0h as it does not apply to PCI Express.
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[20:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 device_specific_initialization : 1;
    /* device_specific_initialization - Bits[21:21], RO, default = 1'b0  */
    UINT32 aux_current : 3;
    /* aux_current - Bits[24:22], RO, default = 3'b000  */
    UINT32 d1_support : 1;
    /* d1_support - Bits[25:25], RO, default = 1'b0 
       I/OxAPIC does not support power management state D1.
     */
    UINT32 d2_support : 1;
    /* d2_support - Bits[26:26], RO, default = 1'b0 
       I/OxAPIC does not support power management state D2.
     */
    UINT32 pme_support : 5;
    /* pme_support - Bits[31:27], RO_V, default = 5'b11001 
       Bits 31, 30 and 27 must be set to \q1\q for PCI-PCI bridge structures 
       representing ports on root complexes. 
     */
  } Bits;
  UINT32 Data;
} PMCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PMCSR_IIO_PCIEDMI_REG supported on:                                        */
/*       IVT_EP (0x400000E4)                                                  */
/*       IVT_EX (0x400000E4)                                                  */
/*       HSX (0x400000E4)                                                     */
/*       BDX (0x400000E4)                                                     */
/* Register default value:              0x00000008                            */
#define PMCSR_IIO_PCIEDMI_REG 0x0E0040E4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0e4
 */
typedef union {
  struct {
    UINT32 power_state : 2;
    /* power_state - Bits[1:0], RW_L, default = 2'b00 
       This 2-bit field is used to determine the current power state of the function 
       and to set a new power state as well. 
       00: D0
       01: D1 (not supported by IOAPIC)
       10: D2 (not supported by IOAPIC)
       11: D3_hot
       If Software tries to write 01 or 10 to this field, the power state does not 
       change from the existing power state (which is either D0 or D3hot) and nor do 
       these bits1:0 change value. 
       When in D3hot state, I/OxAPIC will
       a) respond to only Type 0 configuration transactions targeted at the device's 
       configuration space, when in D3hot state 
       c) will not respond to memory (i.e. D3hot state is equivalent to MSE ), accesses 
       to MBAR region (note: ABAR region access still go through in D3hot state, if it 
       enabled) 
       d) will not generate any MSI writes
     */
    UINT32 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 no_soft_reset : 1;
    /* no_soft_reset - Bits[3:3], RW_O, default = 1'b1 
       Indicates I/OxAPIC does not reset its registers when transitioning from D3hot to 
       D0. 
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pme_enable : 1;
    /* pme_enable - Bits[8:8], RWS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data_select : 4;
    /* data_select - Bits[12:9], RO, default = 4'b0000 
       Not relevant for I/OxAPIC
     */
    UINT32 data_scale : 2;
    /* data_scale - Bits[14:13], RO, default = 2'b00 
       Not relevant for I/OxAPIC
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[15:15], RW1CS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 rsvd_16 : 6;
    /* rsvd_16 - Bits[21:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 b2_b3_support : 1;
    /* b2_b3_support - Bits[22:22], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 bus_power_clock_control_enable : 1;
    /* bus_power_clock_control_enable - Bits[23:23], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data : 8;
    /* data - Bits[31:24], RO, default = 8'b00000000 
       Not relevant for I/OxAPIC
     */
  } Bits;
  UINT32 Data;
} PMCSR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DEVCTRL_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x200000F0)                                                  */
/*       IVT_EX (0x200000F0)                                                  */
/*       HSX (0x200000F0)                                                     */
/*       BDX (0x200000F0)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL_IIO_PCIEDMI_REG 0x0E0020F0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0f0
 */
typedef union {
  struct {
    UINT16 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Controls the reporting of correctable errors that IIO detects on the PCI 
       Express/DMI interface 
       0: Reporting of link Correctable error detected by the port is disabled
       1: Reporting of link Correctable error detected by port is enabled
     */
    UINT16 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Controls the reporting of non-fatal errors that IIO detects on the PCI Express 
       interface. 
       0: Reporting of Non Fatal error detected by device is disabled
       1: Reporting of Non Fatal error detected by device is enabled
     */
    UINT16 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Controls the reporting of fatal errors that IIO detects on the PCI Express/DMI 
       interface. 
       0: Reporting of Fatal error detected by device is disabled
       1: Reporting of Fatal error detected by device is enabled
     */
    UINT16 unsupported_request_reporting_enable : 1;
    /* unsupported_request_reporting_enable - Bits[3:3], RW, default = 1'b0 
       This bit controls the reporting of unsupported requests that IIO itself detects 
       on requests its receives from a PCI Express port. 
       0: Reporting of unsupported requests is disabled
       1: Reporting of unsupported requests is enabled.
     */
    UINT16 enable_relaxed_ordering : 1;
    /* enable_relaxed_ordering - Bits[4:4], RO, default = 1'b0 
       Not applicable to root ports since they never set relaxed ordering bit as a 
       requester (this does not include tx forwarded from peer devices). This bit has 
       no impact on forwarding of relaxed ordering attribute on peer requests. 
     */
    UINT16 max_payload_size : 3;
    /* max_payload_size - Bits[7:5], RW, default = 3'b000 
       000: 128B max payload size
       001: 256B max payload size
       others: alias to 128B
       
       IIO can receive packets equal to the size set by this field.
       IIO generate read completions as large as the value set by this field.
       IIO generates memory writes of max 64B.
     */
    UINT16 extended_tag_field_enable : 1;
    /* extended_tag_field_enable - Bits[8:8], RO, default = 1'b0 
       Not applicable, since IIO never generates any requests on its own that uses tags 
       7:5. However, IIO forwards the entire tag field for peer to peer requests, so 
       tag[7:5] could be set. 
     */
    UINT16 phantom_functions_enable : 1;
    /* phantom_functions_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable, since IIO never uses phantom functions as a requestor.
     */
    UINT16 auxiliary_power_management_enable : 1;
    /* auxiliary_power_management_enable - Bits[10:10], RO, default = 1'b0 
       Not applicable
     */
    UINT16 enable_no_snoop : 1;
    /* enable_no_snoop - Bits[11:11], RO, default = 1'b0 
       Not applicable to PCIe root ports since they never set the 'No Snoop' bit for 
       transactions they originate (not forwarded from peer) to PCI Express/DMI. This 
       bit has no impact on forwarding of NoSnoop attribute on peer requests. 
     */
    UINT16 max_read_request_size : 3;
    /* max_read_request_size - Bits[14:12], RO, default = 3'b000 
       PCI Express ports do not generate requests greater than 64B and this field is 
       RO. 
     */
    UINT16 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DEVSTS_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x200000F2)                                                  */
/*       IVT_EX (0x200000F2)                                                  */
/*       HSX (0x200000F2)                                                     */
/*       BDX (0x200000F2)                                                     */
/* Register default value:              0x0000                                */
#define DEVSTS_IIO_PCIEDMI_REG 0x0E0020F2
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCI Express Device Status
 */
typedef union {
  struct {
    UINT16 correctable_error_detected : 1;
    /* correctable_error_detected - Bits[0:0], RW1C, default = 1'b0 
       This bit gets set if a correctable error is detected by the root port. Errors 
       are logged in this register regardless of whether error reporting is enabled or 
       not in the PCI Express Device Control register. 
       1: correctable errors detected
       0: No correctable errors detected
     */
    UINT16 non_fatal_error_detected : 1;
    /* non_fatal_error_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit gets set if a non-fatal uncorrectable error is detected by the root 
       port. Errors are logged in this register regardless of whether error reporting 
       is enabled or not in the Device Control register. 
       1: Non Fatal errors detected
       0: No non-Fatal Errors detected
     */
    UINT16 fatal_error_detected : 1;
    /* fatal_error_detected - Bits[2:2], RW1C, default = 1'b0 
       This bit indicates that a fatal (uncorrectable) error is detected by the root 
       port. Errors are logged in this register regardless of whether error reporting 
       is enabled or not in the Device Control register. 
       1: Fatal errors detected
       0: No Fatal errors detected
     */
    UINT16 unsupported_request_detected : 1;
    /* unsupported_request_detected - Bits[3:3], RW1C, default = 1'b0 
       This bit indicates that the root port port detected an Unsupported Request. 
       Errors are logged in this register regardless of whether error reporting is 
       enabled or not in the Device Control Register. 
       1: Unsupported Request detected at the device/port. These unsupported requests 
       are NP requests inbound that the root port port received and it detected them as 
       unsupported requests (e.g. address decoding failures that the root port detected 
       on a packet, receiving inbound lock reads, BME bit is clear etc.). 
       0: No unsupported request detected by the root port
       
       This bit is not set on peer2peer completions with UR status that are forwarded 
       by the root port to the PCIe link. 
     */
    UINT16 aux_power_detected : 1;
    /* aux_power_detected - Bits[4:4], RO, default = 1'b0 
       Does not apply to IIO
     */
    UINT16 transactions_pending : 1;
    /* transactions_pending - Bits[5:5], RO, default = 1'b0 
       Does not apply to Root/DMI ports, i.e. bit hardwired to 0 for these devices.
     */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DEVCTRL2_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x200000F8)                                                  */
/*       IVT_EX (0x200000F8)                                                  */
/*       HSX (0x200000F8)                                                     */
/*       BDX (0x200000F8)                                                     */
/* Register default value:              0x0010                                */
#define DEVCTRL2_IIO_PCIEDMI_REG 0x0E0020F8


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x0f8
 */
typedef union {
  struct {
    UINT16 compltoval : 4;
    /* compltoval - Bits[3:0], RW, default = 4'b0000  */
    UINT16 compltodis : 1;
    /* compltodis - Bits[4:4], RW, default = 1'b1  */
    UINT16 ari : 1;
    /* ari - Bits[5:5], RW_L, default = 1'b0 
       Alternative RID InterpretationEnable
       Applies only to root ports. When set to 1b, ARI is enabled for the Root Port. 
       For Device#0 in DMI mode, this bit is ignored. 
     */
    UINT16 atomicreqen : 1;
    /* atomicreqen - Bits[6:6], RO, default = 1'b0  */
    UINT16 atomicegressblock : 1;
    /* atomicegressblock - Bits[7:7], RO, default = 1'b0  */
    UINT16 rsvd_8 : 2;
    /* rsvd_8 - Bits[9:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 ltr_en : 1;
    /* ltr_en - Bits[10:10], RW_LV, default = 1'b0  */
    UINT16 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL2_IIO_PCIEDMI_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* XPREUT_HDR_EXT_IIO_PCIEDMI_REG supported on:                               */
/*       IVT_EP (0x40000100)                                                  */
/*       IVT_EX (0x40000100)                                                  */
/*       HSX (0x40000100)                                                     */
/*       BDX (0x40000100)                                                     */
/* Register default value:              0x1101000B                            */
#define XPREUT_HDR_EXT_IIO_PCIEDMI_REG 0x0E004100
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * REUT PCIe Header Extended
 */
typedef union {
  struct {
    UINT32 pciecapid : 16;
    /* pciecapid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe Extended CapID
       This field has the value 0Bh to identify the CAP_ID assigned by the PCI SIG 
       indicating a vendor specific capability. 
     */
    UINT32 pciecapversion : 4;
    /* pciecapversion - Bits[19:16], RO, default = 4'b0001 
       Capability Version
       This field is a PCI-SIG defined version number that indicates the nature and 
       format of the extended capability. This indicates the version of the REUT 
       Capability. 
     */
    UINT32 pcienextptr : 12;
    /* pcienextptr - Bits[31:20], RO_V, default = 12'b000100010000 
       Next Capability Pointer
       This field contains the offset to the next PCI capability structure or 00h if no 
       other items exist in the linked list of capabilities. 
       In DMI Mode, it points to the Vendor Specific Error Capability.
       In PCIe Mode, it points to the ACS Capability.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_EXT_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPREUT_HDR_CAP_IIO_PCIEDMI_REG supported on:                               */
/*       IVT_EP (0x40000104)                                                  */
/*       IVT_EX (0x40000104)                                                  */
/*       HSX (0x40000104)                                                     */
/*       BDX (0x40000104)                                                     */
/* Register default value:              0x00C00002                            */
#define XPREUT_HDR_CAP_IIO_PCIEDMI_REG 0x0E004104
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * REUT Header Capability
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000010 
       This field is a Intel-defined ID number that indicates the nature and format of 
       the VSEC structure. Software must qualify the Vendor ID before interpreting this 
       field. 
     */
    UINT32 vsecidrev : 4;
    /* vsecidrev - Bits[19:16], RO, default = 4'b0000 
       This field is defined as the version number that indicates the nature and format 
       of the VSEC structure. Software must quality the Vendor ID before interpreting 
       this field. 
     */
    UINT32 vseclength : 12;
    /* vseclength - Bits[31:20], RO, default = 12'b000000001100 
       This field defines the length of the REUT 'capability body'. The size of the 
       leaf body is 12 bytes including the _EXT, _CAP and _LEF registers. 
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_CAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPREUT_HDR_LEF_IIO_PCIEDMI_REG supported on:                               */
/*       IVT_EP (0x40000108)                                                  */
/*       IVT_EX (0x40000108)                                                  */
/*       HSX (0x40000108)                                                     */
/*       BDX (0x40000108)                                                     */
/* Register default value:              0x00003007                            */
#define XPREUT_HDR_LEF_IIO_PCIEDMI_REG 0x0E004108
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 leafreutengid : 8;
    /* leafreutengid - Bits[7:0], RO_V, default = 8'b00000111 
       This field identifies the REUT engine associated with the link (same as the REUT 
       ID). 
     */
    UINT32 leafreutdevnum : 8;
    /* leafreutdevnum - Bits[15:8], RO_V, default = 8'b00110000 
       This field identifies the PCI Device/Function # where the REUT engine associated 
       with this link resides. 
       Device6 = 00110b & function0 = 000b = 30h
       Device6 = 00110b & function1 = 001b = 31h
       Device6 = 00110b & function2 = 010b = 32h
       Device6 = 00110b & function3 = 011b = 33h
       Device6 = 00110b & function4 = 100b = 34h
       Device6 = 00110b & function5 = 101b = 35h
       Device6 = 00110b & function6 = 110b = 36h
       Device7 = 00111b & function0 = 000b = 38h
       Device7 = 00111b & function1 = 001b = 39h
       Device7 = 00111b & function2 = 010b = 3Ah
       Device7 = 00111b & function3 = 011b = 3Bh
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_LEF_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* APICBASE_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x20000140)                                                  */
/*       IVT_EX (0x20000140)                                                  */
/*       HSX (0x20000140)                                                     */
/*       BDX (0x20000140)                                                     */
/* Register default value:              0x0000                                */
#define APICBASE_IIO_PCIEDMI_REG 0x0E002140
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x140
 */
typedef union {
  struct {
    UINT16 en : 1;
    /* en - Bits[0:0], RW, default = 1'b0 
       enables the decode of the APIC window
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       These are addr bits 19:9. Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a 
       don't care for address decode. Address decoding to the APIC range is done as 
       APICBASE.ADDR[31:9] &lt;= A[31:9] &lt;= APICLIMIT.ADDR[31:9]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if bit 0 is set, even if the MSE bit of the root port is clear or the 
       root port itself is in D3hot state. 
     */
    UINT16 rsvd : 4;
    /* rsvd - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICBASE_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* APICLIMIT_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x20000142)                                                  */
/*       IVT_EX (0x20000142)                                                  */
/*       HSX (0x20000142)                                                     */
/*       BDX (0x20000142)                                                     */
/* Register default value:              0x0000                                */
#define APICLIMIT_IIO_PCIEDMI_REG 0x0E002142
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x142
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Applies only to root ports. These are addr bits 19:9. Bits 31:20 are assumed to 
       be 0xFECh. Bits 8:0 are a don't care for address decode. Address decoding to the 
       APIC range is done as APICBASE.ADDR[31:9] &lt;= A[31:9] &lt;= 
       APICLIMIT.ADDR[31:9]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if the range is enabled, even if the MSE bit of the root port is clear 
       or the root 
       port itself is in D3hot state.
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICLIMIT_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* VSECPHDR_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x40000144)                                                  */
/*       IVT_EX (0x40000144)                                                  */
/*       HSX (0x40000144)                                                     */
/*       BDX (0x40000144)                                                     */
/* Register default value:              0x1D01000B                            */
#define VSECPHDR_IIO_PCIEDMI_REG 0x0E004144
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x144
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000111010000  */
  } Bits;
  UINT32 Data;
} VSECPHDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* VSHDR_IIO_PCIEDMI_REG supported on:                                        */
/*       IVT_EP (0x40000148)                                                  */
/*       IVT_EX (0x40000148)                                                  */
/*       HSX (0x40000148)                                                     */
/*       BDX (0x40000148)                                                     */
/* Register default value:              0x03C10004                            */
#define VSHDR_IIO_PCIEDMI_REG 0x0E004148
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x148
 */
typedef union {
  struct {
    UINT32 vsec_id : 16;
    /* vsec_id - Bits[15:0], RO, default = 16'b0000000000000100  */
    UINT32 vsec_version : 4;
    /* vsec_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 vsec_length : 12;
    /* vsec_length - Bits[31:20], RO, default = 12'b000000111100  */
  } Bits;
  UINT32 Data;
} VSHDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* UNCERRSTS_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x4000014C)                                                  */
/*       IVT_EX (0x4000014C)                                                  */
/*       HSX (0x4000014C)                                                     */
/*       BDX (0x4000014C)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRSTS_IIO_PCIEDMI_REG 0x0E00414C
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x14c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 ecrc_error_status : 1;
    /* ecrc_error_status - Bits[19:19], RW1CS, default = 1'b0  */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* UNCERRMSK_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x40000150)                                                  */
/*       IVT_EX (0x40000150)                                                  */
/*       HSX (0x40000150)                                                     */
/*       BDX (0x40000150)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRMSK_IIO_PCIEDMI_REG 0x0E004150
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x150
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_mask : 1;
    /* ecrc_error_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* UNCERRSEV_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x40000154)                                                  */
/*       IVT_EX (0x40000154)                                                  */
/*       HSX (0x40000154)                                                     */
/*       BDX (0x40000154)                                                     */
/* Register default value:              0x00062030                            */
#define UNCERRSEV_IIO_PCIEDMI_REG 0x0E004154
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x154
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 ecrc_error_severity : 1;
    /* ecrc_error_severity - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* CORERRSTS_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x40000158)                                                  */
/*       IVT_EX (0x40000158)                                                  */
/*       HSX (0x40000158)                                                     */
/*       BDX (0x40000158)                                                     */
/* Register default value:              0x00000000                            */
#define CORERRSTS_IIO_PCIEDMI_REG 0x0E004158
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x158
 */
typedef union {
  struct {
    UINT32 receiver_error_status : 1;
    /* receiver_error_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_status : 1;
    /* bad_tlp_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 bad_dllp_status : 1;
    /* bad_dllp_status - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 replay_num_rollover_status : 1;
    /* replay_num_rollover_status - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_status : 1;
    /* replay_timer_time_out_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_status : 1;
    /* advisory_non_fatal_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* CORERRMSK_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x4000015C)                                                  */
/*       IVT_EX (0x4000015C)                                                  */
/*       HSX (0x4000015C)                                                     */
/*       BDX (0x4000015C)                                                     */
/* Register default value:              0x00002000                            */
#define CORERRMSK_IIO_PCIEDMI_REG 0x0E00415C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x15c
 */
typedef union {
  struct {
    UINT32 receiver_error_mask : 1;
    /* receiver_error_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_mask : 1;
    /* bad_tlp_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_mask : 1;
    /* bad_dllp_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_mask : 1;
    /* replay_num_rollover_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_mask : 1;
    /* replay_timer_time_out_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_mask : 1;
    /* advisory_non_fatal_error_mask - Bits[13:13], RWS, default = 1'b1  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRMSK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ERRCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x40000160)                                                  */
/*       IVT_EX (0x40000160)                                                  */
/*       HSX (0x40000160)                                                     */
/*       BDX (0x40000160)                                                     */
/* Register default value on IVT_EP:    0x00000000                            */
/* Register default value on IVT_EX:    0x00000000                            */
/* Register default value on HSX:       0x00000000                            */
/* Register default value on BDX:       0x000000A0                            */
#define ERRCAP_IIO_PCIEDMI_REG 0x0E004160
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 first_error_pointer : 5;
    /* first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000 
       The First Error Pointer is a read-only register that identifies the bit position 
       of the first unmasked error reported in the Uncorrectable Error register. In 
       case of two errors happening at the same time, fatal error gets precedence over 
       non-fatal, in terms of being reported as first error. This field is rearmed to 
       capture new errors when the status bit indicated by this field is cleared by 
       software. 
     */
    UINT32 ecrc_generation_capable : 1;
    /* ecrc_generation_capable - Bits[5:5], RW_O, default = 1'b1  */
    UINT32 ecrc_generation_enable : 1;
    /* ecrc_generation_enable - Bits[6:6], RWS, default = 1'b0  */
    UINT32 ecrc_check_capable : 1;
    /* ecrc_check_capable - Bits[7:7], RW_O, default = 1'b1  */
    UINT32 ecrc_check_enable : 1;
    /* ecrc_check_enable - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd : 23;
    /* rsvd - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ERRCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* HDRLOG0_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000164)                                                  */
/*       IVT_EX (0x40000164)                                                  */
/*       HSX (0x40000164)                                                     */
/*       BDX (0x40000164)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG0_IIO_PCIEDMI_REG 0x0E004164
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Header Log 0 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 0: Logs the first DWORD of the header on an error condition.
     */
  } Bits;
  UINT32 Data;
} HDRLOG0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* HDRLOG1_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000168)                                                  */
/*       IVT_EX (0x40000168)                                                  */
/*       HSX (0x40000168)                                                     */
/*       BDX (0x40000168)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG1_IIO_PCIEDMI_REG 0x0E004168
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Header Log 1
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 1: Logs the second DWORD of the header on an error 
       condition. 
     */
  } Bits;
  UINT32 Data;
} HDRLOG1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* HDRLOG2_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x4000016C)                                                  */
/*       IVT_EX (0x4000016C)                                                  */
/*       HSX (0x4000016C)                                                     */
/*       BDX (0x4000016C)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG2_IIO_PCIEDMI_REG 0x0E00416C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Header Log 2 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 2: Logs the third DWORD of the header on an error condition.
     */
  } Bits;
  UINT32 Data;
} HDRLOG2_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* HDRLOG3_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000170)                                                  */
/*       IVT_EX (0x40000170)                                                  */
/*       HSX (0x40000170)                                                     */
/*       BDX (0x40000170)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG3_IIO_PCIEDMI_REG 0x0E004170
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Header Log 3 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 3: Logs the fourth DWORD of the header on an error 
       condition. 
     */
  } Bits;
  UINT32 Data;
} HDRLOG3_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* RPERRCMD_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x40000174)                                                  */
/*       IVT_EX (0x40000174)                                                  */
/*       HSX (0x40000174)                                                     */
/*       BDX (0x40000174)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRCMD_IIO_PCIEDMI_REG 0x0E004174
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x174
 */
typedef union {
  struct {
    UINT32 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on correctable errors when set.
     */
    UINT32 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on a non-fatal error when set.
     */
    UINT32 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Applies to root ports onlyEnable MSI/INTx interrupt on fatal errors when set.
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPERRCMD_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* RPERRSTS_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x40000178)                                                  */
/*       IVT_EX (0x40000178)                                                  */
/*       HSX (0x40000178)                                                     */
/*       BDX (0x40000178)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRSTS_IIO_PCIEDMI_REG 0x0E004178
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Root Port Error Status
 * The Root Error Status register reports status of error Messages (ERR_COR), 
 * ERR_NONFATAL, and ERR_FATAL) received by the Root Complex in IIO, and errors 
 * detected by the Root Port itself (which are treated conceptually as if the Root 
 * Port had sent an error Message to itself). 
 * The ERR_NONFATAL and ERR_FATAL Messages are grouped together as uncorrectable. 
 * Each correctable and uncorrectable (Non-fatal and Fatal) error source has a 
 * first error bit and a next error bit associated with it respectively. When an 
 * error is received by a Root Complex, the respective first error bit is set and 
 * the Requestor ID is logged in the Error Source Identification register. 
 * A set individual error status bit indicates that a particular error category 
 * occurred; software may clear an error status by writing a 1 to the respective 
 * bit. If software does not clear the first reported error before another error 
 * Message is received of the same category (correctable or uncorrectable), the 
 * corresponding next error status bit will be set but the Requestor ID of the 
 * subsequent error Message is discarded. The next error status bits may be cleared 
 * by software by writing a 1 to the respective bit as well. 
 */
typedef union {
  struct {
    UINT32 correctable_error_received : 1;
    /* correctable_error_received - Bits[0:0], RW1CS, default = 1'b0 
       Set when a correctable error message is received and this bit is already not 
       set. i.e. log the first error message. 
     */
    UINT32 multiple_correctable_error_received : 1;
    /* multiple_correctable_error_received - Bits[1:1], RW1CS, default = 1'b0 
       Set when either a correctable error message is received and Correctable Error 
       Received bit is already set, i.e log from the 2nd Correctable error message 
       onwards. 
     */
    UINT32 error_fatal_nonfatal_received : 1;
    /* error_fatal_nonfatal_received - Bits[2:2], RW1CS, default = 1'b0 
       Set when either a fatal or a non-fatal error message is received and this bit is 
       already not set. i.e. log the first error message. Note that when this bit is 
       set bit 3 could be either set or clear. 
     */
    UINT32 multiple_error_fatal_nonfatal_received : 1;
    /* multiple_error_fatal_nonfatal_received - Bits[3:3], RW1CS, default = 1'b0 
       Set when either a fatal or a non-fatal error message is received and Error 
       Fatal/Nonfatal Received is already set, i.e log from the 2nd Fatal or No fatal 
       error message onwards. 
     */
    UINT32 first_uncorrectable_fatal : 1;
    /* first_uncorrectable_fatal - Bits[4:4], RW1CS, default = 1'b0 
       Set when bit 2 is set (from being clear) and the message causing bit 2 to be set 
       is an ERR_FATAL message. 
     */
    UINT32 non_fatal_error_messages_received : 1;
    /* non_fatal_error_messages_received - Bits[5:5], RW1CS, default = 1'b0 
       Set when one or more Non-Fatal Uncorrectable error Messages have been received.
     */
    UINT32 fatal_error_messages_received : 1;
    /* fatal_error_messages_received - Bits[6:6], RW1CS, default = 1'b0 
       Set when one or more Fatal Uncorrectable error Messages have been received.
     */
    UINT32 rsvd : 20;
    /* rsvd - Bits[26:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 advanced_error_interrupt_message_number : 5;
    /* advanced_error_interrupt_message_number - Bits[31:27], RO, default = 5'b00000 
       Advanced Error Interrupt Message Number offset between base message data an the 
       MSI message if assigned more than one message number. IIO hardware automatically 
       updates this register to 0x1h if the number of messages allocated to the root 
       port is 2. 
     */
  } Bits;
  UINT32 Data;
} RPERRSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ERRSID_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x4000017C)                                                  */
/*       IVT_EX (0x4000017C)                                                  */
/*       HSX (0x4000017C)                                                     */
/*       BDX (0x4000017C)                                                     */
/* Register default value:              0x00000000                            */
#define ERRSID_IIO_PCIEDMI_REG 0x0E00417C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Error Source Identification
 */
typedef union {
  struct {
    UINT32 correctable_error_source_id : 16;
    /* correctable_error_source_id - Bits[15:0], ROS_V, default = 16'b0000000000000000 
       Requestor ID of the source when a correctable error message is received and the 
       Correctable Error Received bit is not already set. i.e log ID of the first 
       correctable error message. Note that when the root port itself is the cause of 
       the received message (virtual message), then a Source ID of CPUBUSNO0:DevNo:0 is 
       logged into this register. 
     */
    UINT32 fatal_non_fatal_error_source_id : 16;
    /* fatal_non_fatal_error_source_id - Bits[31:16], ROS_V, default = 16'b0000000000000000 
       Requestor ID of the source when an Fatal or Non Fatal error message is received 
       and the Error Fatal/Nonfatal Received bit is not already set. i.e log ID of the 
       first Fatal or Non Fatal error message. Note that when the root port itself is 
       the cause of the received message (virtual message), then a Source ID of 
       CPUBUSNO0:DevNo:0 is logged into this register. 
     */
  } Bits;
  UINT32 Data;
} ERRSID_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PERFCTRLSTS_0_IIO_PCIEDMI_REG supported on:                                */
/*       IVT_EP (0x40000180)                                                  */
/*       IVT_EX (0x40000180)                                                  */
/*       HSX (0x40000180)                                                     */
/*       BDX (0x40000180)                                                     */
/* Register default value:              0x00183091                            */
#define PERFCTRLSTS_0_IIO_PCIEDMI_REG 0x0E004180


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x180
 */
typedef union {
  struct {
    UINT32 read_stream_policy : 1;
    /* read_stream_policy - Bits[0:0], RW, default = 1'b1  */
    UINT32 read_passing_read_disable : 1;
    /* read_passing_read_disable - Bits[1:1], RW, default = 1'b0  */
    UINT32 nosnoopoprden : 1;
    /* nosnoopoprden - Bits[2:2], RW, default = 1'b0  */
    UINT32 nosnoopopwren : 1;
    /* nosnoopopwren - Bits[3:3], RW, default = 1'b0  */
    UINT32 read_stream_interleave_size : 1;
    /* read_stream_interleave_size - Bits[4:4], RW, default = 1'b1  */
    UINT32 vc1m_nosnoopopdis : 1;
    /* vc1m_nosnoopopdis - Bits[5:5], RW, default = 1'b0 
       Disables inbound VC1/m traffic with NS=1 from issuing non-snoop IDI/QPI 
       requests. 
     */
    UINT32 vcp_nosnoopopen : 1;
    /* vcp_nosnoopopen - Bits[6:6], RW, default = 1'b0 
       Enables inbound VCp traffic with NS=1 to issue non-snoop IDI/QPI requests.
     */
    UINT32 use_allocating_flow_wr : 1;
    /* use_allocating_flow_wr - Bits[7:7], RW, default = 1'b1  */
    UINT32 outstanding_requests_gen2 : 6;
    /* outstanding_requests_gen2 - Bits[13:8], RW, default = 6'b110000  */
    UINT32 rsvd_14 : 2;
    /* rsvd_14 - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outstanding_requests_gen1 : 5;
    /* outstanding_requests_gen1 - Bits[20:16], RW, default = 5'b11000  */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_0_IIO_PCIEDMI_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* PERFCTRLSTS_1_IIO_PCIEDMI_REG supported on:                                */
/*       IVT_EP (0x40000184)                                                  */
/*       IVT_EX (0x40000184)                                                  */
/*       HSX (0x40000184)                                                     */
/*       BDX (0x40000184)                                                     */
/* Register default value:              0x00000000                            */
#define PERFCTRLSTS_1_IIO_PCIEDMI_REG 0x0E004184


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x184
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[3:3], RW, default = 1'b0  */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dca_reqid_override : 1;
    /* dca_reqid_override - Bits[8:8], RW, default = 1'b0  */
    UINT32 tphdis : 1;
    /* tphdis - Bits[9:9], RW, default = 1'b0  */
    UINT32 partial_cohrd_op : 2;
    /* partial_cohrd_op - Bits[11:10], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need less than 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 full_cohrd_op : 2;
    /* full_cohrd_op - Bits[13:12], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need all 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_1_IIO_PCIEDMI_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* MISCCTRLSTS_0_IIO_PCIEDMI_REG supported on:                                */
/*       IVT_EP (0x40000188)                                                  */
/*       IVT_EX (0x40000188)                                                  */
/*       HSX (0x40000188)                                                     */
/*       BDX (0x40000188)                                                     */
/* Register default value:              0x60101800                            */
#define MISCCTRLSTS_0_IIO_PCIEDMI_REG 0x0E004188
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Miscellaneous Control and Status 0
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 inbound_configuration_enable : 1;
    /* inbound_configuration_enable - Bits[1:1], RW_O, default = 1'b0 
       Enable Inbound Configuration Requests.
     */
    UINT32 enable_acpi_mode_for_pm : 1;
    /* enable_acpi_mode_for_pm - Bits[2:2], RW, default = 1'b0 
       Applies only to root ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, all PM events at the PCI Express 
       port are handled via _PMEGPE messages to the PCH, and no MSI interrupts are ever 
       generated for PM events at the root port (regardless of whether MSI is enabled 
       at the root port or not). When clear, _PMEGPE message generation for PM events 
       is disabled and OS can chose to generate MSI interrupts for delivering PM events 
       by setting the MSI enable bit in root ports. This bit does not apply to the DMI 
       ports. Refer to PCI Express Base Specification, Revision 2.0 for details of MSI 
       and GPE Clearing this bit (from being 1) schedules a Deassert_PMEGPE event on 
       behalf of the root port, provided there was any previous Assert_PMEGPE message 
       that was sent without an associated Deassert message. Note that this bit applies 
       to Dev#3/Fn#0 in NTB mode as well and BIOS needs to set it up appropriately in 
       that mode. 
     */
    UINT32 enable_acpi_mode_for_hotplug : 1;
    /* enable_acpi_mode_for_hotplug - Bits[3:3], RW, default = 1'b0 
       Applies only to root ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, all hotplug events from the PCI 
       Express port are handled via _HPGPE messages to the PCH and no MSI/INTx messages 
       are ever generated for hotplug events (regardless of whether MSI or INTx is 
       enabled at the root port or not) at the root port. When this bit is clear, 
       _HPGPE message generation on behalf of root port hotplug events is disabled and 
       OS can chose to generate MSI or INTx interrupt for hotplug events, by setting 
       the MSI enable bit in root ports. This bit does not apply to the DMI ports. 
       Refer to PCI Express Base Specification, Revision 2.0 for details of MSI and GPE 
       message generation for hotplug events. Clearing this bit (from being 1) 
       schedules a Deassert_HPGPE event on behalf of the root port, provided there was 
       any previous Assert_HPGPE message that was sent without an associated Deassert 
       message. Note that this bit applies to Dev#3/Fn#0 in NTB mode as well and BIOS 
       needs to set it up appropriately in that mode. 
     */
    UINT32 enable_system_error_only_for_aer : 1;
    /* enable_system_error_only_for_aer - Bits[4:4], RW, default = 1'b0 
       Applies only to root/NTB ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, the PCI Express errors do not 
       trigger an MSI or Intx interrupt, regardless of the whether MSI or INTx is 
       enabled or not. Whether or not PCI Express errors result in a system event like 
       NMI/SMI/PMI/CPEI is dependent on whether the appropriate system error or 
       override system error enable bits are set or not. When this bit is clear, PCI 
       Express errors are reported via MSI or INTx and/or NMI/SMI/MCA/CPEI. When this 
       bit is clear and if MSI enable bit in the MSI Control Register (MSICTRL)is set 
       (clear), then an MSI (INTx) interrupt is generated for PCI Express errors. When 
       this bit is clear, and 'System Error on Fatal Error Enable' bit in ROOTCON 
       register is set, then NMI/SMI/MCA is (also) generated for a PCI Express fatal 
       error. Similar behavior for non-fatal and corrected errors. Note that this bit 
       applies to Dev#3/Fn#0 in NTB mode as well and BIOS needs to set it up 
       appropriately in that mode. 
     */
    UINT32 send_pme_turn_off_message : 1;
    /* send_pme_turn_off_message - Bits[5:5], RW_V, default = 1'b0 
       When this bit is written with a 1b, IIO sends a PME_TURN_OFF message to the PCIE 
       link. Hardware clears this bit when the message has been sent on the link. 
     */
    UINT32 enable_timeout_for_receiving_pme_to_ack : 1;
    /* enable_timeout_for_receiving_pme_to_ack - Bits[6:6], RW, default = 1'b0 
       Enable timeout for receiving PME_TO_ACK.
       When set, IIO enables the timeout to receiving the PME_TO_ACK.
     */
    UINT32 pme2acktoctrl : 2;
    /* pme2acktoctrl - Bits[8:7], RW, default = 2'b00  */
    UINT32 dispdspolling : 1;
    /* dispdspolling - Bits[9:9], RWS, default = 1'b0 
       Disables gen2 if timeout happens in polling.cfg.
     */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 allow_1nonvc1_after_10vc1s : 1;
    /* allow_1nonvc1_after_10vc1s - Bits[11:11], RWS, default = 1'b1  */
    UINT32 disable_ob_parity_check : 1;
    /* disable_ob_parity_check - Bits[12:12], RWS, default = 1'b1  */
    UINT32 tlp_on_any_lane : 1;
    /* tlp_on_any_lane - Bits[13:13], RWS, default = 1'b0  */
    UINT32 allow_one_np_os : 1;
    /* allow_one_np_os - Bits[14:14], RWS, default = 1'b0  */
    UINT32 dis_hdr_storage : 1;
    /* dis_hdr_storage - Bits[15:15], RWS, default = 1'b0  */
    UINT32 force_ep_biterr : 1;
    /* force_ep_biterr - Bits[16:16], RO, default = 1'b0 
       Force EP Bit Error (Poison Bit).
     */
    UINT32 force_data_perr : 1;
    /* force_data_perr - Bits[17:17], RO, default = 1'b0 
       Force Data Parity Error.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[18:18], RWS, default = 1'b0 
       Disable Read Completion Combining
       When set, all completions are returned without combining. Completions are 
       naturally broken on cacheline boundaries, so all completions will be 64B or 
       less. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maltlp_32baddr64bhdr_en : 1;
    /* maltlp_32baddr64bhdr_en - Bits[20:20], RW, default = 1'b1 
       Malformed TLP 32b address in 64b header Enable
       When set, enables reporting a Malformed packet when the TLP is a 32 bit address 
       in a 4DW header. PCI Express forbids using 4DW header sizes when the address is 
       less than 4GB, but some cards may use the 4DW header anyway. In these cases, the 
       upper 32 bits of address are all 0. 
     */
    UINT32 zero_ob_tc : 1;
    /* zero_ob_tc - Bits[21:21], RW_O, default = 1'b0 
       Force Outbound TC to Zero
       Forces the TC field to zero for outbound requests.
       1: TC is forced to zero on all outbound transactions regardless of the source TC 
       value 
       0: TC is not altered
       In DMI mode, TC is always forced to zero and this bit has no effect.
       
     */
    UINT32 check_cpl_tc : 1;
    /* check_cpl_tc - Bits[22:22], RWS, default = 1'b0  */
    UINT32 phold_disable : 1;
    /* phold_disable - Bits[23:23], RW, default = 1'b0 
       Applies only to Dev#0
       When set, the IIO responds with Unsupported request on receiving assert_phold 
       message from ICH and results in generating a fatal error. 
     */
    UINT32 peer2peer_memory_read_disable : 1;
    /* peer2peer_memory_read_disable - Bits[24:24], RW, default = 1'b0 
       When set, peer2peer memory reads are master aborted otherwise they are allowed 
       to progress per the peer2peer decoding rules. 
     */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 eoifd : 1;
    /* eoifd - Bits[26:26], RW, default = 1'b0 
       EOI Forwarding Disable - Disable EOI broadcast to this PCIE link
       When set, EOI message will not be broadcast down this PCIE link. When clear, the 
       port is a valid target for EOI broadcast. BIOS must set this bit on a port if it 
       is connected to a another processor NTB or root port on other end of the link. 
     */
    UINT32 system_interrupt_only_on_link_bw_management_status : 1;
    /* system_interrupt_only_on_link_bw_management_status - Bits[27:27], RWS, default = 1'b0  */
    UINT32 to_dis : 1;
    /* to_dis - Bits[28:28], RW, default = 1'b0 
       Disables timeouts completely.
     */
    UINT32 cfg_to_en : 1;
    /* cfg_to_en - Bits[29:29], RW, default = 1'b1 
       Disables/enables config timeouts, independently of other timeouts.
     */
    UINT32 inbound_io_disable : 1;
    /* inbound_io_disable - Bits[30:30], RW_O, default = 1'b1 
       Disable Inbound IO Requests.
     */
    UINT32 disable_l0s_on_transmitter : 1;
    /* disable_l0s_on_transmitter - Bits[31:31], RW, default = 1'b0 
       When set, IIO never puts its tx in L0s state, even if OS enables it via the Link 
       Control register. L0s is not supported on the processor. 
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* MISCCTRLSTS_1_IIO_PCIEDMI_REG supported on:                                */
/*       IVT_EP (0x4000018C)                                                  */
/*       IVT_EX (0x4000018C)                                                  */
/*       HSX (0x4000018C)                                                     */
/*       BDX (0x4000018C)                                                     */
/* Register default value:              0x00080000                            */
#define MISCCTRLSTS_1_IIO_PCIEDMI_REG 0x0E00418C
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0  */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 rsvd_5 : 1;
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0  */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0  */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 rsvd_18 : 14;
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Miscellaneous Control and Status 1
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0 
       When set, correctable errors on PCI Express (that have been successfully 
       propagated to the primary interface of the port) are sent to the IIO core error 
       logic (for further escalation) regardless of the setting of the equivalent bit 
       in the ROOTCTRL register. When clear, the correctable errors are only propagated 
       to the IIO core error logic if the equivalent bit in ROOTCTRL register is set. 
       For Dev#0 in DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link 
       related correctable errors will never be notified to system software. 
     */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0 
       When set, non-fatal errors on PCI Express (that have been successfully 
       propagated to the primary interface of the port) are sent to the IIO core error 
       logic (for further escalation) regardless of the setting of the equivalent bit 
       in the ROOTCTRL register. When clear, the non-fatal errors are only propagated 
       to the IIO core error logic if the equivalent bit in ROOTCTRL register is set. 
       For Dev#0 in DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link 
       related non-fatal errors will never be notified to system software. 
     */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0 
       When set, fatal errors on PCI Express (that have been successfully propagated to 
       the primary interface of the port) are sent to the IIO core error logic (for 
       further escalation) regardless of the setting of the equivalent bit in the 
       ROOTCTRL register. When clear, the fatal errors are only propagated to the IIO 
       core error logic if the equivalent bit in ROOTCTRL register is set. For Dev#0 in 
       DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link related fatal 
       errors will never be notified to system software. 
     */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 disable_mctp_broadcast_to_this_link : 1;
    /* disable_mctp_broadcast_to_this_link - Bits[5:5], RW, default = 1'b0  */
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0 
       This bit is set by BIOS when it knows that this port is connected to a device 
       that creates Posted-Posted dependency on its In-Out queues. 
       Briefly, this bit is set on a link if:
       This link is connected to a processor RP or processor NTB port on the other side 
       of the link. 
       This link is connected to a port or device that creates Posted-Posted dependency 
       on its In-Out queues. 
       IIO lock flows depend on the setting of this bit to treat this port in a special 
       way during the flows. Note that if BIOS is setting up the lock flow to be in the 
       'QPI compatible' mode then this bit must be set to 0. 
       An inbound MSI request can block the posted channel until EOI's are posted to 
       all outbound queues enabled to receive EOI. Because of this, this bit cannot be 
       set unless EOIFD is also set. 
     */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0 
       For TPH/DCA requests, the Completer ID can be returned with SocketID when this 
       bit is set. 
     */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0 
       Indicates that IIO received a PME turn off ack packet or it timed out waiting 
       for the packet. 
     */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0 
       Indicates that a locked read request incurred a completion time-out on PCI 
       Express/DMI. 
     */
    UINT32 rsvd_18 : 12;
    UINT32 disable_sending_pme_to_port : 1;
    /* disable_sending_pme_to_port - Bits[30:30], RW, default = 1'b0  */
    UINT32 mimic_pme_to_ack_received : 1;
    /* mimic_pme_to_ack_received - Bits[31:31], RW, default = 1'b0  */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* PCIE_IOU_BIF_CTRL_IIO_PCIEDMI_REG supported on:                            */
/*       IVT_EP (0x20000190)                                                  */
/*       IVT_EX (0x20000190)                                                  */
/*       HSX (0x20000190)                                                     */
/*       BDX (0x20000190)                                                     */
/* Register default value:              0x0000                                */
#define PCIE_IOU_BIF_CTRL_IIO_PCIEDMI_REG 0x0E002190
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU.  
 */
typedef union {
  struct {
    UINT16 iou_bifurcation_control : 3;
    /* iou_bifurcation_control - Bits[2:0], RO, default = 3'b000 
       To select a IOU bifurcation, software sets this field and then either:
       a) sets bit 3 in this register to initiate training OR
       b) resets the entire processor and on exit from that reset
       The processor will bifurcate the ports per the setting in this field.
       For x8 ports:
       000: x4x4 (operate lanes 7:4 as x4, 3:0 as x4)
       001: x8
       others: Reserved
       
       For x16 ports:
       000: x4x4x4x4 (operate lanes 15:12 as x4, 11:8 as x4, 7:4 as x4 and 3:0 as x4)
       001: x4x4x8 (operate lanes 15:12 as x4, 11:8 as x4 and 7:0 as x8)
       010: x8x4x4 (operate lanes 15:8 as x8, 7:4 as x4 and 3:0 as x4)
       011: x8x8 (operate lanes 15:8 as x8, 7:0 as x8)
       100: x16
       others: Reserved
     */
    UINT16 iou_start_bifurcation : 1;
    /* iou_start_bifurcation - Bits[3:3], WO, default = 1'b0 
       When software writes a 1 to this bit, IIO starts the port 0 bifurcation process. 
       After writing to this bit, software can poll the Data Link Layer link active bit 
       in the LNKSTS register to determine if a port is up and running. Once a port 
       bifurcation has been initiated by writing a 1 to this bit, software cannot 
       initiate any more write-1 to this bit (write of 0 is ok). 
       Notes:
       That this bit can be written to a 1 in the same write that changes values for 
       bits 2:0 in this register and in that case, the new value from the write to bits 
       2:0 take effect. 
       This bit always reads a 0b.
     */
    UINT16 rsvd : 12;
    /* rsvd - Bits[15:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCIE_IOU_BIF_CTRL_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DMICTRL_N0_IIO_PCIEDMI_REG supported on:                                   */
/*       IVT_EP (0x400001A0)                                                  */
/*       IVT_EX (0x400001A0)                                                  */
/*       HSX (0x400001A0)                                                     */
/*       BDX (0x400001A0)                                                     */
/* Register default value:              0x00000003                            */
#define DMICTRL_N0_IIO_PCIEDMI_REG 0x0E0041A0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1a0
 */
typedef union {
  struct {
    UINT32 abort_inbound_requests : 1;
    /* abort_inbound_requests - Bits[0:0], RW, default = 1'b1 
       Requires processor reset sequence to be completed.
     */
    UINT32 auto_complete_pm : 1;
    /* auto_complete_pm - Bits[1:1], RW, default = 1'b1 
       This bit, if set, enables the DMI port to automatically complete PM message 
       handshakes by generating an Ack_Sx or Rst_Warn_Ack message down DMI for the 
       following DMI messages received: 
       Go_S0
       Go_S1_RW
       Go_S1_Temp
       Go_S1_Final
       Go_S3
       Go_S4
       Go_S5
       Rst_Warn
       
       Notes:
       This is used by pCode to indicate periods of time when it is not ready to accept 
       messages and there is a risk the messages will be lost. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], RO, default = 62'b00000000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} DMICTRL_N0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DMICTRL_N1_IIO_PCIEDMI_REG supported on:                                   */
/*       IVT_EP (0x400001A4)                                                  */
/*       IVT_EX (0x400001A4)                                                  */
/*       HSX (0x400001A4)                                                     */
/*       BDX (0x400001A4)                                                     */
/* Register default value:              0x00000000                            */
#define DMICTRL_N1_IIO_PCIEDMI_REG 0x0E0041A4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1a0
 */
typedef union {
  struct {
    UINT32 rsvd : 32;
    /* rsvd - Bits[31:0], RO, default = 62'b00000000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} DMICTRL_N1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* DMISTS_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x400001A8)                                                  */
/*       IVT_EX (0x400001A8)                                                  */
/*       HSX (0x400001A8)                                                     */
/*       BDX (0x400001A8)                                                     */
/* Register default value:              0x00000000                            */
#define DMISTS_IIO_PCIEDMI_REG 0x0E0041A8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1a8
 */
typedef union {
  struct {
    UINT32 received_cpu_reset_done_ack : 1;
    /* received_cpu_reset_done_ack - Bits[0:0], RW1C, default = 1'b0  */
    UINT32 reserved : 31;
    /* reserved - Bits[31:1], RO, default = 31'b0000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} DMISTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LNKCON_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x200001B0)                                                  */
/*       IVT_EX (0x200001B0)                                                  */
/*       HSX (0x200001B0)                                                     */
/*       BDX (0x200001B0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON_IIO_PCIEDMI_REG 0x0E0021B0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCI Express Link Control
 */
typedef union {
  struct {
    UINT16 active_state_link_pm_control : 2;
    /* active_state_link_pm_control - Bits[1:0], RW, default = 2'b00 
       When 01b or 11b, L0s on transmitter is enabled, otherwise it is disabled. 10 and 
       11 enables L1 ASPM. 
     */
    UINT16 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 read_completion_boundary : 1;
    /* read_completion_boundary - Bits[3:3], RO, default = 1'b0 
       Set to zero to indicate IIO could return read completions at 64B boundaries.
     */
    UINT16 link_disable : 1;
    /* link_disable - Bits[4:4], RW, default = 1'b0  */
    UINT16 retrain_link : 1;
    /* retrain_link - Bits[5:5], WO, default = 1'b0  */
    UINT16 common_clock_configuration : 1;
    /* common_clock_configuration - Bits[6:6], RW_V, default = 1'b0  */
    UINT16 extended_synch : 1;
    /* extended_synch - Bits[7:7], RW, default = 1'b0  */
    UINT16 enable_clock_power_management : 1;
    /* enable_clock_power_management - Bits[8:8], RO, default = 1'b0  */
    UINT16 hardware_autonomous_width_disable : 1;
    /* hardware_autonomous_width_disable - Bits[9:9], RW, default = 1'b0  */
    UINT16 link_bandwidth_management_interrupt_enable : 1;
    /* link_bandwidth_management_interrupt_enable - Bits[10:10], RW, default = 1'b0 
       For root ports, when set to 1b this bit enables the generation of an interrupt 
       to indicate that the Link Bandwidth Management Status bit has been set. For DMI 
       mode on Dev#0, interrupt is not supported and hence this bit is not useful. 
       Expectation is that BIOS will set bit 27 to notify the system of autonomous BW 
       change event on that port per BIOS Writers Guide. 
     */
    UINT16 link_autonomous_bandwidth_interrupt_enable : 1;
    /* link_autonomous_bandwidth_interrupt_enable - Bits[11:11], RW, default = 1'b0 
       For root ports, when set to 1b this bit enables the generation of an interrupt 
       to indicate that the Link Autonomous Bandwidth Status bit has been set. For DMI 
       mode on Dev#0, interrupt is not supported and hence this bit is not useful. 
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKCON_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LNKSTS_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x200001B2)                                                  */
/*       IVT_EX (0x200001B2)                                                  */
/*       HSX (0x200001B2)                                                     */
/*       BDX (0x200001B2)                                                     */
/* Register default value:              0x1001                                */
#define LNKSTS_IIO_PCIEDMI_REG 0x0E0021B2
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1b2
 */
typedef union {
  struct {
    UINT16 current_link_speed : 4;
    /* current_link_speed - Bits[3:0], RO_V, default = 4'b0001  */
    UINT16 negotiated_link_width : 6;
    /* negotiated_link_width - Bits[9:4], RO_V, default = 6'b000000  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 link_training : 1;
    /* link_training - Bits[11:11], RO_V, default = 1'b0  */
    UINT16 slot_clock_configuration : 1;
    /* slot_clock_configuration - Bits[12:12], RW_O, default = 1'b1  */
    UINT16 data_link_layer_link_active : 1;
    /* data_link_layer_link_active - Bits[13:13], RO_V, default = 1'b0  */
    UINT16 link_bandwidth_management_status : 1;
    /* link_bandwidth_management_status - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_status : 1;
    /* link_autonomous_bandwidth_status - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} LNKSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LNKCON2_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x200001C0)                                                  */
/*       IVT_EX (0x200001C0)                                                  */
/*       HSX (0x200001C0)                                                     */
/*       BDX (0x200001C0)                                                     */
/* Register default value:              0x0002                                */
#define LNKCON2_IIO_PCIEDMI_REG 0x0E0021C0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1c0
 */
typedef union {
  struct {
    UINT16 target_link_speed : 4;
    /* target_link_speed - Bits[3:0], RWS_V, default = 4'b0010 
       This field sets an upper limit on link operational speed by restricting the 
       values advertised by the upstream component in its training sequences. Defined 
       encodings are: 
       0001b 2.5Gb/s Target Link Speed
       0010b 5Gb/s Target Link Speed
       Reserved (Dev#0)/0011b (others) 8Gb/s Target Link Speed
       All other encodings are reserved.
       If a value is written to this field that does not correspond to a speed included 
       in the Supported Link Speeds field, IIO will default to Gen1 speed. 
       This field is also used to set the target compliance mode speed when software is 
       using the Enter Compliance bit to force a link into compliance mode. 
     */
    UINT16 enter_compliance : 1;
    /* enter_compliance - Bits[4:4], RWS_V, default = 1'b0 
       Software is permitted to force a link to enter Compliance mode at the speed 
       indicated in the Target Link Speed field by setting this bit to 1b in both 
       components on a link and then initiating a hot reset on the link. 
     */
    UINT16 hardware_autonomous_speed_disable : 1;
    /* hardware_autonomous_speed_disable - Bits[5:5], RWS, default = 1'b0 
       When Set, this bit disables hardware from changing the Link speed for device 
       specific reasons other than attempting to correct unreliable Link operation by 
       reducing Link speed. 
     */
    UINT16 selectable_de_emphasis : 1;
    /* selectable_de_emphasis - Bits[6:6], RW_O, default = 1'b0 
       When the Link is operating at 5.0 GT/s speed, this bit selects the level of 
       de-emphasis for an Upstream component.Encodings: 
       1b -3.5 dB
       0b -6 dB
       When the Link is operating at 2.5 GT/s speed, the setting of this bit has no 
       effect. 
     */
    UINT16 transmit_margin : 3;
    /* transmit_margin - Bits[9:7], RWS_V, default = 3'b000 
       This field controls the value of the nondeemphasized voltage level at the 
       Transmitter pins. 
     */
    UINT16 enter_modified_compliance : 1;
    /* enter_modified_compliance - Bits[10:10], RWS, default = 1'b0 
       When this bit is set to 1b, the device transmits Modified Compliance Pattern if 
       the LTSSM enters Polling.Compliance substate. 
     */
    UINT16 compliance_sos : 1;
    /* compliance_sos - Bits[11:11], RWS, default = 1'b0 
       When set to 1b, the LTSSM is required to send SKP Ordered Sets periodically in 
       between the (modified) compliance patterns. 
     */
    UINT16 compliance_de_emphasis : 1;
    /* compliance_de_emphasis - Bits[12:12], RWS, default = 1'b0 
       For 8GT/s Data Rate:
       This bit sets the Transmitter Preset level in Polling.Compliance state if the 
       entry occurred due to the Enter Compliance bit being 1b. The Encodings are 
       defined as follows: 
       0000b: -6 dB for de-emphasis, 0 dB for preshoot
       0001b: -3.5 dB for de-emphasis, 0 dB for preshoot
       0010b: -4.5 dB for de-emphasis, 0 dB for preshoot
       0011b: -2.5 dB for de-emphasis, 0 dB for preshoot
       0100b: 0 dB for de-emphasis, 0 dB for preshoot
       0101b: 0 dB for de-emphasis, 2 dB for preshoot
       0110b: 0 dB for de-emphasis, 2.5 dB for preshoot
       0111b: -6 dB for de-emphasis, 3.5 dB for preshoot
       1000b: -3.5 dB for de-emphasis, 3.5 dB for preshoot
       1001b: 0 dB for de-emphasis, 3.5 dB for preshoot
       Others: reserved
       
       For 5GT/s Data Rate:
       This bit sets the de-emphasis level in Polling.Compliance state if the entry 
       occurred due to the Enter Compliance bit being 1b. Encodings: 
       0001b: -3.5 dB
       0000b: -6 dB
       
       For 2.5GT/s Data Rate:
       The setting of this field has no effect. Components that support only 2.5 GT/s 
       speed are permitted to hardwire this field to 0h. 
       This bit is intended for debug, compliance testing purposes. System firmware and 
       software is allowed to modify this bit only during debug or compliance testing. 
     */
    UINT16 rsvd : 3;
    /* rsvd - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKCON2_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LNKSTS2_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x200001C2)                                                  */
/*       IVT_EX (0x200001C2)                                                  */
/*       HSX (0x200001C2)                                                     */
/*       BDX (0x200001C2)                                                     */
/* Register default value:              0x0000                                */
#define LNKSTS2_IIO_PCIEDMI_REG 0x0E0021C2
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1c2
 */
typedef union {
  struct {
    UINT16 current_de_emphasis_level : 1;
    /* current_de_emphasis_level - Bits[0:0], RO_V, default = 1'b0 
       When operating at Gen2 speed, this reports the current de-emphasis level. This 
       field is Unused for Gen1 speeds 
       
       1b: -3.5 dB
       0b: -6 dB
     */
    UINT16 rsvd : 15;
    /* rsvd - Bits[15:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKSTS2_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ERRINJCAP_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x400001D0)                                                  */
/*       IVT_EX (0x400001D0)                                                  */
/*       HSX (0x400001D0)                                                     */
/*       BDX (0x400001D0)                                                     */
/* Register default value:              0x2801000B                            */
#define ERRINJCAP_IIO_PCIEDMI_REG 0x0E0041D0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCI Express Error Injection
 */
typedef union {
  struct {
    UINT32 extcapid : 16;
    /* extcapid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCI Express Extended CAP ID
       Vendor Specific Capability
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability Version
       Set to 1h for this version of the PCI Express logic
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001010000000 
       Next Capability Offset
       This field points to the next capability or 0 if there isn't a next capability.
       For non-DMI (x4) port next capability is at 0x250.
       For DMI port next capability is at 0x280.
     */
  } Bits;
  UINT32 Data;
} ERRINJCAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ERRINJHDR_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x400001D4)                                                  */
/*       IVT_EX (0x400001D4)                                                  */
/*       HSX (0x400001D4)                                                     */
/*       BDX (0x400001D4)                                                     */
/* Register default value:              0x00A10003                            */
#define ERRINJHDR_IIO_PCIEDMI_REG 0x0E0041D4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCI Express Error Injection
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000011 
       Vendor Specific ID
       Assigned for WHEA Error Injection
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0001 
       Vendor Specific Capability Revision
       Set to 1h for this version of the WHEA Error Injection logic
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000001010 
       Vendor Specific Capability Length
       Indicates the length of the capability structure, including header bytes.
     */
  } Bits;
  UINT32 Data;
} ERRINJHDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* ERRINJCON_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x200001D8)                                                  */
/*       IVT_EX (0x200001D8)                                                  */
/*       HSX (0x200001D8)                                                     */
/*       BDX (0x200001D8)                                                     */
/* Register default value:              0x0000                                */
#define ERRINJCON_IIO_PCIEDMI_REG 0x0E0021D8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCI Express Error Injection Control Register
 */
typedef union {
  struct {
    UINT16 errinjdis : 1;
    /* errinjdis - Bits[0:0], RW_O, default = 1'b0 
       Error Injection Disable
       This bit disables the use of the PCIe error injection bits.
     */
    UINT16 cause_rcverr : 1;
    /* cause_rcverr - Bits[1:1], RW, default = 1'b0 
       Cause a Receiver Error
       When this bit is written to transition from 0 to 1, one and only one error 
       assertion pulse is produced on the error source signal for the given port. This 
       error will appear equivalent to an actual error assertion because this event is 
       OR'd into the existing error reporting structure. To log another error, this bit 
       must be cleared first, before setting again. Leaving this bit in a 1 state does 
       not produce a persistent error condition. 
       This bit is used for an correctable error test.
       This bit must be cleared by software before creating another event.
       This bit is disabled by bit 0 of this register.
     */
    UINT16 cause_ctoerr : 1;
    /* cause_ctoerr - Bits[2:2], RW, default = 1'b0 
       Cause a Completion Timeout Error
       When this bit is written to transition from 0 to 1, one and only one error 
       assertion pulse is produced on the error source signal for the given port. This 
       error will appear equivalent to an actual error assertion because this event is 
       OR'd into the existing error reporting structure. To log another error, this bit 
       must be cleared first, before setting again. Leaving this bit in a 1 state does 
       not produce a persistent error condition. 
       This bit is used for an uncorrectable error test.
       This bit must be cleared by software before creating another event.
       This bit is disabled by bit 0 of this register.
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ERRINJCON_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* CTOCTRL_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x400001E0)                                                  */
/*       IVT_EX (0x400001E0)                                                  */
/*       HSX (0x400001E0)                                                     */
/*       BDX (0x400001E0)                                                     */
/* Register default value:              0x00000000                            */
#define CTOCTRL_IIO_PCIEDMI_REG 0x0E0041E0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Completion Timeout Control
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    /* rsvd_0 - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 xp_to_pcie_timeout_select : 2;
    /* xp_to_pcie_timeout_select - Bits[9:8], RW, default = 2'b00 
       When OS selects a timeout range of 17s to 64s for XP (that affect NP tx issued 
       to the PCIE/DMI) using the root port's DEVCTRL2 register, this field selects the 
       sub-range within that larger range, for additional controllability. 
       00: 17s-30s
       01: 31s-45s
       10: 46s-64s
       11: Reserved
       This field is not used at all when NTB is enabled on Dev#3/Fn#0 since there is 
       no programmability of completion timeout in that mode. 
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CTOCTRL_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* PCIE_LER_SS_CTRLSTS_IIO_PCIEDMI_REG supported on:                          */
/*       IVT_EP (0x400001E4)                                                  */
/*       IVT_EX (0x400001E4)                                                  */
/*       HSX (0x400001E4)                                                     */
/*       BDX (0x400001E4)                                                     */
/* Register default value:              0x00000000                            */
#define PCIE_LER_SS_CTRLSTS_IIO_PCIEDMI_REG 0x0E0041E4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x1e4
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PCIE_LER_SS_CTRLSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPCORERRSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000200)                                                  */
/*       IVT_EX (0x40000200)                                                  */
/*       HSX (0x40000200)                                                     */
/*       BDX (0x40000200)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRSTS_IIO_PCIEDMI_REG 0x0E004200
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP Correctable Error Status
 * The architecture model for error logging and escalation of internal errors is 
 * similar to that of PCI Express AER, except that these internal errors never 
 * trigger an MSI and are always reported to the system software. Mask bits mask 
 * the reporting of an error and severity bit controls escalation to either fatal 
 * or non-fatal error to the internal core error logic. Note that internal errors 
 * detected in the PCI Express cluster are not dependent on any other control bits 
 * for error escalation other than the mask bit defined in these registers. All 
 * these registers are sticky 
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0 
       This bit is set when:
       (LNKSTS[15] and LNKCON[11])=1 or
       LNKSTS[14]=1 or
       (LNKSTS[5] and LNKCON[1])=1
       This bit is cleared by software.
     */
    UINT32 msgd_gt_16dw : 1;
    /* msgd_gt_16dw - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* XPCORERRMSK_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000204)                                                  */
/*       IVT_EX (0x40000204)                                                  */
/*       HSX (0x40000204)                                                     */
/*       BDX (0x40000204)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRMSK_IIO_PCIEDMI_REG 0x0E004204
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP Correctable Error Mask
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 msgd_gt_16dw_errmask : 1;
    /* msgd_gt_16dw_errmask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* XPUNCERRSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000208)                                                  */
/*       IVT_EX (0x40000208)                                                  */
/*       HSX (0x40000208)                                                     */
/*       BDX (0x40000208)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRSTS_IIO_PCIEDMI_REG 0x0E004208
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x208
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected : 1;
    /* outbound_switch_fifo_data_parity_error_detected - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort : 1;
    /* sent_completion_with_completer_abort - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request : 1;
    /* sent_completion_with_unsupported_request - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status : 1;
    /* received_pcie_completion_with_ca_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status : 1;
    /* received_pcie_completion_with_ur_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data : 1;
    /* received_msi_writes_greater_than_a_dword_data - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 outbound_poisoned_data : 1;
    /* outbound_poisoned_data - Bits[9:9], RW1CS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPUNCERRMSK_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x4000020C)                                                  */
/*       IVT_EX (0x4000020C)                                                  */
/*       HSX (0x4000020C)                                                     */
/*       BDX (0x4000020C)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRMSK_IIO_PCIEDMI_REG 0x0E00420C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x20c
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detected_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_mask : 1;
    /* sent_completion_with_completer_abort_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_mask : 1;
    /* sent_completion_with_unsupported_request_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRMSK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPUNCERRSEV_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000210)                                                  */
/*       IVT_EX (0x40000210)                                                  */
/*       HSX (0x40000210)                                                     */
/*       BDX (0x40000210)                                                     */
/* Register default value:              0x00000002                            */
#define XPUNCERRSEV_IIO_PCIEDMI_REG 0x0E004210
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x210
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_severity : 1;
    /* outbound_switch_fifo_data_parity_error_detected_severity - Bits[1:1], RWS, default = 1'b1  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_severity : 1;
    /* sent_completion_with_completer_abort_severity - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_severity : 1;
    /* sent_completion_with_unsupported_request_severity - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_severity : 1;
    /* received_pcie_completion_with_ca_status_severity - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_severity : 1;
    /* received_pcie_completion_with_ur_status_severity - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_severity : 1;
    /* received_msi_writes_greater_than_a_dword_data_severity - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_severity : 1;
    /* outbound_poisoned_data_severity - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSEV_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPUNCERRPTR_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x10000214)                                                  */
/*       IVT_EX (0x10000214)                                                  */
/*       HSX (0x10000214)                                                     */
/*       BDX (0x10000214)                                                     */
/* Register default value:              0x00                                  */
#define XPUNCERRPTR_IIO_PCIEDMI_REG 0x0E001214
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP Uncorrectable Error Pointer
 */
typedef union {
  struct {
    UINT8 xp_uncorrectable_first_error_pointer : 5;
    /* xp_uncorrectable_first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000 
       This field points to which of the unmasked uncorrectable errors happened first. 
       This field is only valid when the corresponding error is unmasked and the status 
       bit is set and this field is rearmed to load again when the status bit indicated 
       to by this pointer is cleared by software from 1 to 0. Value of 0x0 corresponds 
       to bit 0 in XPUNCERRSTS register, value of 0x1 corresponds to bit 1 etc. 
     */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} XPUNCERRPTR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* UNCEDMASK_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x40000218)                                                  */
/*       IVT_EX (0x40000218)                                                  */
/*       HSX (0x40000218)                                                     */
/*       BDX (0x40000218)                                                     */
/* Register default value:              0x00000000                            */
#define UNCEDMASK_IIO_PCIEDMI_REG 0x0E004218
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x218
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_detect_mask : 1;
    /* ecrc_error_detect_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* COREDMASK_IIO_PCIEDMI_REG supported on:                                    */
/*       IVT_EP (0x4000021C)                                                  */
/*       IVT_EX (0x4000021C)                                                  */
/*       HSX (0x4000021C)                                                     */
/*       BDX (0x4000021C)                                                     */
/* Register default value:              0x00000000                            */
#define COREDMASK_IIO_PCIEDMI_REG 0x0E00421C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x21c
 */
typedef union {
  struct {
    UINT32 receiver_error_detect_mask : 1;
    /* receiver_error_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_detect_mask : 1;
    /* bad_tlp_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_detect_mask : 1;
    /* bad_dllp_detect_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_detect_mask : 1;
    /* replay_num_rollover_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_detect_mask : 1;
    /* replay_timer_time_out_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_detect_mask : 1;
    /* advisory_non_fatal_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} COREDMASK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* RPEDMASK_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x40000220)                                                  */
/*       IVT_EX (0x40000220)                                                  */
/*       HSX (0x40000220)                                                     */
/*       BDX (0x40000220)                                                     */
/* Register default value:              0x00000000                            */
#define RPEDMASK_IIO_PCIEDMI_REG 0x0E004220
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x220
 */
typedef union {
  struct {
    UINT32 correctable_error_detected_status_mask : 1;
    /* correctable_error_detected_status_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 non_fatal_error_detected_status_mask : 1;
    /* non_fatal_error_detected_status_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 fatal_error_detected_status_mask : 1;
    /* fatal_error_detected_status_mask - Bits[2:2], RWS, default = 1'b0  */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPEDMASK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPUNCEDMASK_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000224)                                                  */
/*       IVT_EX (0x40000224)                                                  */
/*       HSX (0x40000224)                                                     */
/*       BDX (0x40000224)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCEDMASK_IIO_PCIEDMI_REG 0x0E004224
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x224
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detect_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detect_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_detect_mask : 1;
    /* sent_completion_with_completer_abort_detect_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_detect_mask : 1;
    /* sent_completion_with_unsupported_request_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_detect_mask : 1;
    /* received_pcie_completion_with_ca_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_detect_mask : 1;
    /* received_pcie_completion_with_ur_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_detect_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_detect_mask : 1;
    /* outbound_poisoned_data_detect_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCEDMASK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPCOREDMASK_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000228)                                                  */
/*       IVT_EX (0x40000228)                                                  */
/*       HSX (0x40000228)                                                     */
/*       BDX (0x40000228)                                                     */
/* Register default value:              0x00000000                            */
#define XPCOREDMASK_IIO_PCIEDMI_REG 0x0E004228
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP Correctable Error Mask
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0 
       Masks the BW change event from being propagated to the IIO core error logic as a 
       correctable error. 
     */
    UINT32 msgd_gt_16dw_detmask : 1;
    /* msgd_gt_16dw_detmask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* XPGLBERRSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x20000230)                                                  */
/*       IVT_EX (0x20000230)                                                  */
/*       HSX (0x20000230)                                                     */
/*       BDX (0x20000230)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRSTS_IIO_PCIEDMI_REG 0x0E002230
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP Global Error Status
 */
typedef union {
  struct {
    UINT16 pcie_aer_fatal_error : 1;
    /* pcie_aer_fatal_error - Bits[0:0], RW1CS, default = 1'b0 
       A PCIE fatal error (ERR_FATAL message received from externally or through a 
       virtual ERR_FATAL message generated internally) was detected anew. Note that if 
       that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage, only 'subsequent' 
       PCIE unmasked fatal errors will set this bit.See section titled PCI Express 
       Error Reporting Specifics in the RAS chapter for details of how this bit 
       interacts with other control/status bits in signalling errors to the IIO global 
       error reporting logic. 
     */
    UINT16 pcie_aer_non_fatal_error : 1;
    /* pcie_aer_non_fatal_error - Bits[1:1], RW1CS, default = 1'b0 
       A PCIE non-fatal error (ERR_NONFATAL message received from externally or through 
       a virtual ERR_NONFATAL message generated internally) was detected anew. Note 
       that if that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage only 'subsequent' PCIE 
       unmasked non-fatal errors will set this bit again.See section titled PCI Express 
       Error Reporting Specifics in the RAS chapter for details of how this bit 
       interacts with other control/status bits in signalling errors to the IIO global 
       error reporting logic. 
     */
    UINT16 pcie_aer_correctable_error : 1;
    /* pcie_aer_correctable_error - Bits[2:2], RW1CS, default = 1'b0 
       A PCIE correctable error (ERR_COR message received from externally or through a 
       virtual ERR_COR message generated internally) was detected anew. Note that if 
       that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage, only 'subsequent' 
       PCIE unmasked correctable errors will set this bit.Conceptually, per the flow of 
       PCI Express Base Spec 2.0 defined Error message control, this bit is set by the 
       ERR_COR message that is enabled to cause a System Error notification. See 
       section titled PCI Express Error Reporting Specifics in the RAS chapter for 
       details of how this bit interacts with other control/status bits in signalling 
       errors to the IIO global error reporting logic. 
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPGLBERRPTR_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x20000232)                                                  */
/*       IVT_EX (0x20000232)                                                  */
/*       HSX (0x20000232)                                                     */
/*       BDX (0x20000232)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRPTR_IIO_PCIEDMI_REG 0x0E002232
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP Global Error Pointer
 */
typedef union {
  struct {
    UINT16 xp_cluster_global_first_error_pointer : 3;
    /* xp_cluster_global_first_error_pointer - Bits[2:0], ROS_V, default = 3'b000 
       This field points to which of the 3 errors indicated in the XPGLBERRSTS register 
       happened first. This field is only valid when the corresponding status bit is 
       set and this field is rearmed to load again when the status bit indicated to by 
       this pointer is cleared by software from 1 to 0.Value of 0x0 corresponds to bit 
       0 in XPGLBERRSTS register, value of 0x1 corresponds to bit 1 etc. 
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRPTR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LER_CAP_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000280)                                                  */
/*       IVT_EX (0x40000280)                                                  */
/*       HSX (0x40000280)                                                     */
/*       BDX (0x40000280)                                                     */
/* Register default value on IVT_EP:    0x0001000B                            */
/* Register default value on IVT_EX:    0x0001000B                            */
/* Register default value on HSX:       0x2981000B                            */
/* Register default value on BDX:       0x2981000B                            */
#define LER_CAP_IIO_PCIEDMI_REG 0x0E004280
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Live Error Recovery Capability
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCI Express Extended CAP ID
       Vendor Specific Capability
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability Version
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001010011000 
       Next Capability Offset
       Default may vary depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} LER_CAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LER_HDR_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000284)                                                  */
/*       IVT_EX (0x40000284)                                                  */
/*       HSX (0x40000284)                                                     */
/*       BDX (0x40000284)                                                     */
/* Register default value:              0x01830005                            */
#define LER_HDR_IIO_PCIEDMI_REG 0x0E004284
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Live Error Recovery Capability Header
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000101 
       Vendor Specific ID
       Represents the Live Error Recovery capability
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0011 
       Vendor Specific Capability Revision
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000011000 
       Vendor Specific Capability Length
     */
  } Bits;
  UINT32 Data;
} LER_HDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LER_CTRLSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       IVT_EP (0x40000288)                                                  */
/*       IVT_EX (0x40000288)                                                  */
/*       HSX (0x40000288)                                                     */
/*       BDX (0x40000288)                                                     */
/* Register default value:              0x00000000                            */
#define LER_CTRLSTS_IIO_PCIEDMI_REG 0x0E004288
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0 
       Live Error Recovery Enable
       When set, allows the LER_Status to assert on error. When the status bit is set, 
       the port is in LER mode. When this bit is cleared, the LER_Status bit cannot 
       become set on an error. 
       If this bit is cleared when LER_Status bit is already set, then clearing this 
       bit does not clear the status bit and does not exit LER mode. To exit LER mode, 
       the status bit must be cleared by software. 
       This bit is also used for stop and scream and can be enabled even though LER is 
       not available. 
     */
    UINT32 ler_ss_severity_en : 1;
    /* ler_ss_severity_en - Bits[1:1], RWS, default = 1'b0 
       Live Error Recovery Severity Enable
       If set, forces the errors that trigger LER mode to be signalled as correctable 
       error of Severity 0. If cleared, then errors are signaled as Uncorrectable 
       Non-Fatal Severity 1 or Uncorrectable Fatal Severity 2 as specified for the 
       given error. 
     */
    UINT32 ler_ss_drop_txn : 1;
    /* ler_ss_drop_txn - Bits[2:2], RWS, default = 1'b0 
       Live Error Recovery Drop Transaction
       If set, after entering LER subsequent transactions will be dropped as soon as 
       the port configuration allows. 
     */
    UINT32 ler_ss_inten : 1;
    /* ler_ss_inten - Bits[3:3], RWS, default = 1'b0 
       Live Error Recovery Interrupt Enable
       If set, causes and INTx or MSI interrupt from the root port (if enabled in the 
       root port) to be generated when LER_Status is set. 
     */
    UINT32 rsvd : 26;
    /* rsvd - Bits[29:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ler_ss_lnk_up_ok : 1;
    /* ler_ss_lnk_up_ok - Bits[30:30], ROS_V, default = 1'b0 
       Live Error Recovery Port Quiesced
       Indicates when the port has no more pending inbound or outbound packets after 
       the port has entered LER mode. It is used by software to determine when it is 
       safe to clear the LER_Status bit to bring the port out of LER mode. 
     */
    UINT32 ler_ss_status : 1;
    /* ler_ss_status - Bits[31:31], RW1CS, default = 1'b0 
       Live Error Recovery Status
       Indicates that an error was detected that caused the PCIE port to go into a live 
       error recovery (LER) mode. While in LER mode, the link goes into a LinkDown 
       "Disabled" state and all outbound transactions are aborted (including packets 
       that may have caused the error). 
       This bit cannot be cleared until all the associated unmasked status bits are 
       cleared, or the corresponding LER mask bits are set. Once the unmasked error 
       considtion are cleared, then this bit may be cleared by software writing a '1'. 
       Once this status becomes cleared by clearing the error condition, the link will 
       retrain into LinkUp state and outbound transactions will no longer be aborted. 
       A link that is forced into a LinkDown state due to LER does not trigger a 
       "surprise LinkDown" error in the UNCERRSTS register. 
       It should be noted that many PCIe cards will go into internal reset when they 
       receive training sequences that indicate the "Disabled" state. 
     */
  } Bits;
  UINT32 Data;
} LER_CTRLSTS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LER_UNCERRMSK_IIO_PCIEDMI_REG supported on:                                */
/*       IVT_EP (0x4000028C)                                                  */
/*       IVT_EX (0x4000028C)                                                  */
/*       HSX (0x4000028C)                                                     */
/*       BDX (0x4000028C)                                                     */
/* Register default value:              0x00000000                            */
#define LER_UNCERRMSK_IIO_PCIEDMI_REG 0x0E00428C
#if defined(IVT_HOST) || defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file IVX\0.0.0.Port0_DMI.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIEDMI_IVT_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* defined(IVT_HOST) || defined(HSX_HOST) */



#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Live Error Recovery Uncorrectable Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_err_mask : 1;
    /* ecrc_err_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIEDMI_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* LER_XPUNCERRMSK_IIO_PCIEDMI_REG supported on:                              */
/*       IVT_EP (0x40000290)                                                  */
/*       IVT_EX (0x40000290)                                                  */
/*       HSX (0x40000290)                                                     */
/*       BDX (0x40000290)                                                     */
/* Register default value:              0x00000000                            */
#define LER_XPUNCERRMSK_IIO_PCIEDMI_REG 0x0E004290
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Live Error Recovery XP Uncorrectable Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 sent_completion_with_ca_mask : 1;
    /* sent_completion_with_ca_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_ur_mask : 1;
    /* sent_completion_with_ur_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0 
       Masks signaling of stop and scream condition to the core error logic.
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_XPUNCERRMSK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* LER_RPERRMSK_IIO_PCIEDMI_REG supported on:                                 */
/*       IVT_EP (0x40000294)                                                  */
/*       IVT_EX (0x40000294)                                                  */
/*       HSX (0x40000294)                                                     */
/*       BDX (0x40000294)                                                     */
/* Register default value:              0x00000000                            */
#define LER_RPERRMSK_IIO_PCIEDMI_REG 0x0E004294
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Live Error Recovery Root Port Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 non_fatal_error_message_received_mask : 1;
    /* non_fatal_error_message_received_mask - Bits[5:5], RWS, default = 1'b0 
       Masks LER response to Non-Fatal Error Messages received.
     */
    UINT32 fatal_error_message_received_mask : 1;
    /* fatal_error_message_received_mask - Bits[6:6], RWS, default = 1'b0 
       Masks LER response to Fatal Error Messages received
     */
    UINT32 rsvd_7 : 25;
    /* rsvd_7 - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_RPERRMSK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* RPPIOERR_CAP_IIO_PCIEDMI_REG supported on:                                 */
/*       HSX (0x40000298)                                                     */
/*       BDX (0x40000298)                                                     */
/* Register default value:              0x3001000B                            */
#define RPPIOERR_CAP_IIO_PCIEDMI_REG 0x0E004298

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCIe spec-defined capability register for enhanced root port PIO error 
 * reporting. 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe extended capability ID.
       Set to 0xb for vendor-specific capability.
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability version.
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001100000000 
       Next capability pointer.
       May not point to 0x300 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_CAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDR_IIO_PCIEDMI_REG supported on:                                 */
/*       HSX (0x4000029C)                                                     */
/*       BDX (0x4000029C)                                                     */
/* Register default value:              0x02400007                            */
#define RPPIOERR_HDR_IIO_PCIEDMI_REG 0x0E00429C

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * PCIe spec-defined vendor-specific header register for enhanced root port PIO 
 * error reporting. 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000111 
       Vendor-specific capability ID. Intel defines 0x7 as the ID for enhanced root 
       port PIO error reporting. 
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000 
       VSEC revision.
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000100100 
       VSEC length.
       Length of the RP_PIO_ERR capability in bytes, starting from the capability ID.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HF_IIO_PCIEDMI_REG supported on:                                  */
/*       HSX (0x400002A0)                                                     */
/*       BDX (0x400002A0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HF_IIO_PCIEDMI_REG 0x0E0042A0

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Register that controls which PIO errors should cause a poison indication.
 */
typedef union {
  struct {
    UINT32 cfg_ur_hf : 1;
    /* cfg_ur_hf - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all configuration requests targeting 
       the PCIe hierarchy below the Root Port will be treated as UR, and will return 
       poison if this bit is set. 
     */
    UINT32 cfg_ca_hf : 1;
    /* cfg_ca_hf - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 cfg_to_hf : 1;
    /* cfg_to_hf - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_hf : 1;
    /* io_ur_hf - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all IO requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 io_ca_hf : 1;
    /* io_ca_hf - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 io_to_hf : 1;
    /* io_to_hf - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_hf : 1;
    /* mem_ur_hf - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all memory requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 mem_ca_hf : 1;
    /* mem_ca_hf - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 mem_to_hf : 1;
    /* mem_to_hf - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HF_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_STATUS_IIO_PCIEDMI_REG supported on:                              */
/*       HSX (0x400002A4)                                                     */
/*       BDX (0x400002A4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_STATUS_IIO_PCIEDMI_REG 0x0E0042A4

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Register that logs the PIO errors.  Note that PIO UR errors that occur after LER 
 * has been triggered will not update this register. 
 * If a PIO error is detected and the corresponding RPPIOERR_MASK bit is cleared, 
 * then LER will be triggered if LER is enabled, and pio_err_first_header and 
 * RPPIOERR_HDRLOG[0-3] may update. 
 * Regardless of the state of the corresponding RPPIOERR_MASK bit, a PIO error may 
 * update its status bit in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_err : 1;
    /* cfg_ur_err - Bits[0:0], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ur_mask). 
     */
    UINT32 cfg_ca_err : 1;
    /* cfg_ca_err - Bits[1:1], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ca_mask). 
     */
    UINT32 cfg_to_err : 1;
    /* cfg_to_err - Bits[2:2], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_err : 1;
    /* io_ur_err - Bits[8:8], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ur_mask). 
     */
    UINT32 io_ca_err : 1;
    /* io_ca_err - Bits[9:9], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ca_mask). 
     */
    UINT32 io_to_err : 1;
    /* io_to_err - Bits[10:10], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.io_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_err : 1;
    /* mem_ur_err - Bits[16:16], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ur_mask). 
     */
    UINT32 mem_ca_err : 1;
    /* mem_ca_err - Bits[17:17], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ca_mask). 
     */
    UINT32 mem_to_err : 1;
    /* mem_to_err - Bits[18:18], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 pio_err_first_header : 5;
    /* pio_err_first_header - Bits[23:19], RW1CS, default = 5'b00000 
       These 5 bits identify the first unmasked (by rppioerr_mask) RPPIO error that was 
       observed. The encoding is as follows: 
       00: No Error
       01: CFG_UR_ERR
       02: CFG_CA_ERR
       03: CFG_TO_ERR
       04: IO_UR_ERR
       05: IO_CA_ERR
       06: IO_TO_ERR
       07: MEM_UR_ERR
       08: MEM_CA_ERR
       09: MEM_TO_ERR
       Others: undefined
       Note these bits will not record subsequent errors until the first error is 
       cleared by SW. 
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_STATUS_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_MASK_IIO_PCIEDMI_REG supported on:                                */
/*       HSX (0x400002A8)                                                     */
/*       BDX (0x400002A8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_MASK_IIO_PCIEDMI_REG 0x0E0042A8

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Register that masks triggering of LER on PIO errors.  When clear, LER will be 
 * triggered when LER is enabled and an error sets the corresponding bit in the 
 * RPPIOERR_STATUS. 
 * When RPPIOERR_STATUS is used to trigger LER, it is expected the end user will 
 * program the LER_XPUNCERRMSK and XPUNCERRMSK registers correctly so that they do 
 * not trigger a LER event also. 
 * If LER_CTRLSTS.LER_Enable is not set, LER will not be triggered, regardless of 
 * the setting of the RPPIOERR_MASK registers. 
 * Poison may still be returned to the requester, based on the RPPIOERR_HF 
 * register, even when the corresponding error is masked in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_mask : 1;
    /* cfg_ur_mask - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_ca_mask : 1;
    /* cfg_ca_mask - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_to_mask : 1;
    /* cfg_to_mask - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_mask : 1;
    /* io_ur_mask - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_ca_mask : 1;
    /* io_ca_mask - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_to_mask : 1;
    /* io_to_mask - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_mask : 1;
    /* mem_ur_mask - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_ca_mask : 1;
    /* mem_ca_mask - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_to_mask : 1;
    /* mem_to_mask - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_MASK_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG0_IIO_PCIEDMI_REG supported on:                             */
/*       HSX (0x400002AC)                                                     */
/*       BDX (0x400002AC)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG0_IIO_PCIEDMI_REG 0x0E0042AC

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 0 ([31:24]), 1 ([23:16]), 2 ([15:8]), and 3 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG1_IIO_PCIEDMI_REG supported on:                             */
/*       HSX (0x400002B0)                                                     */
/*       BDX (0x400002B0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG1_IIO_PCIEDMI_REG 0x0E0042B0

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 4 ([31:24]), 5 ([23:16]), 6 ([15:8]), and 7 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG2_IIO_PCIEDMI_REG supported on:                             */
/*       HSX (0x400002B4)                                                     */
/*       BDX (0x400002B4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG2_IIO_PCIEDMI_REG 0x0E0042B4

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 8 ([31:24]), 9 ([23:16]), 10 ([15:8]), and 11 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG2_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* RPPIOERR_HDRLOG3_IIO_PCIEDMI_REG supported on:                             */
/*       HSX (0x400002B8)                                                     */
/*       BDX (0x400002B8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG3_IIO_PCIEDMI_REG 0x0E0042B8

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 12 ([31:24]), 13 ([23:16]), 14 ([15:8]), and 15 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG3_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */










/* MCAST_CAP_HDR_IIO_PCIEDMI_REG supported on:                                */
/*       HSX (0x40000300)                                                     */
/*       BDX (0x40000300)                                                     */
/* Register default value:              0x0001000B                            */
#define MCAST_CAP_HDR_IIO_PCIEDMI_REG 0x0E004300

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Capability Header Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_HDR_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CAP_EXT_IIO_PCIEDMI_REG supported on:                                */
/*       HSX (0x40000304)                                                     */
/*       BDX (0x40000304)                                                     */
/* Register default value:              0x03800008                            */
#define MCAST_CAP_EXT_IIO_PCIEDMI_REG 0x0E004304

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Extended Capability Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000001000 
       Vendor-specific capability ID. Intel defines 0x8 as the ID for dualcast.
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000111000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_EXT_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CAP_IIO_PCIEDMI_REG supported on:                                    */
/*       HSX (0x2000030C)                                                     */
/*       BDX (0x2000030C)                                                     */
/* Register default value:              0x000F                                */
#define MCAST_CAP_IIO_PCIEDMI_REG 0x0E00230C

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Capability Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Capability Register (see section 7.21.2 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_max_group : 6;
    /* mc_max_group - Bits[5:0], RO, default = 6'b001111  */
    UINT16 rsvd_6 : 2;
    /* rsvd_6 - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_window_size_req : 6;
    /* mc_window_size_req - Bits[13:8], RO, default = 6'b000000  */
    UINT16 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_ecrc_regen_sup : 1;
    /* mc_ecrc_regen_sup - Bits[15:15], RO, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CAP_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_CTRL_IIO_PCIEDMI_REG supported on:                                   */
/*       HSX (0x2000030E)                                                     */
/*       BDX (0x2000030E)                                                     */
/* Register default value:              0x0000                                */
#define MCAST_CTRL_IIO_PCIEDMI_REG 0x0E00230E

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Control Register (Dualcast is a version of PCIe Multicast supported on 
 * the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Control Register (see section 7.21.3 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_num_group : 6;
    /* mc_num_group - Bits[5:0], RW_L, default = 6'b000000 
       This field only supports and implements bits [3:0]. Bits [5:4] are not 
       supported. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[14:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_enable : 1;
    /* mc_enable - Bits[15:15], RW_L, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CTRL_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_BASE_N0_IIO_PCIEDMI_REG supported on:                                */
/*       HSX (0x40000310)                                                     */
/*       BDX (0x40000310)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N0_IIO_PCIEDMI_REG 0x0E004310

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Base Address Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_index_position : 6;
    /* mc_index_position - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 rsvd : 6;
    /* rsvd - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mc_base_address : 20;
    /* mc_base_address - Bits[31:12], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_BASE_N1_IIO_PCIEDMI_REG supported on:                                */
/*       HSX (0x40000314)                                                     */
/*       BDX (0x40000314)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N1_IIO_PCIEDMI_REG 0x0E004314

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Base Address Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_base_address : 32;
    /* mc_base_address - Bits[31:0], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_RCV_N0_IIO_PCIEDMI_REG supported on:                                 */
/*       HSX (0x40000318)                                                     */
/*       BDX (0x40000318)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_RCV_N0_IIO_PCIEDMI_REG 0x0E004318

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Receive Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Receive Register (see section 7.21.5 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_rcv : 16;
    /* mc_rcv - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_RCV_N0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MCAST_BLK_ALL_N0_IIO_PCIEDMI_REG supported on:                             */
/*       HSX (0x40000320)                                                     */
/*       BDX (0x40000320)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_ALL_N0_IIO_PCIEDMI_REG 0x0E004320

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Block All Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_All Register (see section 7.21.6 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_all : 16;
    /* mc_blk_all - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_ALL_N0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MCAST_BLK_UNT_N0_IIO_PCIEDMI_REG supported on:                             */
/*       HSX (0x40000328)                                                     */
/*       BDX (0x40000328)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_UNT_N0_IIO_PCIEDMI_REG 0x0E004328

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Block Untranslated Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_Untranslated Register (see section 7.21.7 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_unt : 16;
    /* mc_blk_unt - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_UNT_N0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MCAST_OVERLAY_BAR_N0_IIO_PCIEDMI_REG supported on:                         */
/*       HSX (0x40000330)                                                     */
/*       BDX (0x40000330)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N0_IIO_PCIEDMI_REG 0x0E004330

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Overlay Bar Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_size : 6;
    /* mc_overlay_size - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 mc_overlay_addr : 26;
    /* mc_overlay_addr - Bits[31:6], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MCAST_OVERLAY_BAR_N1_IIO_PCIEDMI_REG supported on:                         */
/*       HSX (0x40000334)                                                     */
/*       BDX (0x40000334)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N1_IIO_PCIEDMI_REG 0x0E004334

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Dualcast Overlay Bar Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_addr : 32;
    /* mc_overlay_addr - Bits[31:0], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* NVRAM_VIRAL_BASE_IIO_PCIEDMI_REG supported on:                             */
/*       BDX (0x40000350)                                                     */
/* Register default value:              0x00000000                            */
#define NVRAM_VIRAL_BASE_IIO_PCIEDMI_REG 0x0E004350

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x350
 */
typedef union {
  struct {
    UINT32 vclean_enable : 1;
    /* vclean_enable - Bits[0:0], RW, default = 1'b0  */
    UINT32 rsvd : 11;
    /* rsvd - Bits[11:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vclean_base : 20;
    /* vclean_base - Bits[31:12], RW, default = 20'b00000000000000000000  */
  } Bits;
  UINT32 Data;
} NVRAM_VIRAL_BASE_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* NVRAM_VIRAL_SIZE_IIO_PCIEDMI_REG supported on:                             */
/*       BDX (0x40000354)                                                     */
/* Register default value:              0x00000000                            */
#define NVRAM_VIRAL_SIZE_IIO_PCIEDMI_REG 0x0E004354

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * generated by critter 00_0_0x354
 */
typedef union {
  struct {
    UINT32 vclean_size : 24;
    /* vclean_size - Bits[23:0], RW, default = 24'b000000000000000000000000  */
    UINT32 rsvd : 8;
    /* rsvd - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} NVRAM_VIRAL_SIZE_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMDL0_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000480)                                                  */
/*       IVT_EX (0x40000480)                                                  */
/*       HSX (0x40000480)                                                     */
/*       BDX (0x40000480)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMDL0_IIO_PCIEDMI_REG 0x0E004480
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Data Low Bits
 * This is the performance monitor counter. This counter is reset at the beginning 
 * of a sample period unless pre-loaded with a sample value. Therefore, the counter 
 * can cause an early overflow condition with values loaded into the register. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 pm_data_counter_low_value : 32;
    /* pm_data_counter_low_value - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       Low order bits [31:0] for PM data counter[1:0].
     */
  } Bits;
  UINT32 Data;
} XPPMDL0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMDL1_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000484)                                                  */
/*       IVT_EX (0x40000484)                                                  */
/*       HSX (0x40000484)                                                     */
/*       BDX (0x40000484)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMDL1_IIO_PCIEDMI_REG 0x0E004484
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Data Low Bits
 * This is the performance monitor counter. This counter is reset at the beginning 
 * of a sample period unless pre-loaded with a sample value. Therefore, the counter 
 * can cause an early overflow condition with values loaded into the register. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 pm_data_counter_low_value : 32;
    /* pm_data_counter_low_value - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       Low order bits [31:0] for PM data counter[1:0].
     */
  } Bits;
  UINT32 Data;
} XPPMDL1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMCL0_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x40000488)                                                  */
/*       IVT_EX (0x40000488)                                                  */
/*       HSX (0x40000488)                                                     */
/*       BDX (0x40000488)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL0_IIO_PCIEDMI_REG 0x0E004488
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Compare Low Bits
 * The value of PMD is compared to the value of PMC. If PMD is greater than PMC, 
 * this status is reflected in the PERFCON register and/or on the GE[3:0] as 
 * selected in the Event Status Output field of the PMR register. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 pm_compare_low_value : 32;
    /* pm_compare_low_value - Bits[31:0], RW_V, default = 32'b11111111111111111111111111111111 
       Low order bits [31:0] for PM compare register [1:0].
     */
  } Bits;
  UINT32 Data;
} XPPMCL0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMCL1_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x4000048C)                                                  */
/*       IVT_EX (0x4000048C)                                                  */
/*       HSX (0x4000048C)                                                     */
/*       BDX (0x4000048C)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL1_IIO_PCIEDMI_REG 0x0E00448C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Compare Low Bits
 * The value of PMD is compared to the value of PMC. If PMD is greater than PMC, 
 * this status is reflected in the PERFCON register and/or on the GE[3:0] (TBD) as 
 * selected in the Event Status Output field of the PMR register. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 pm_compare_low_value : 32;
    /* pm_compare_low_value - Bits[31:0], RW_V, default = 32'b11111111111111111111111111111111 
       Low order bits [31:0] for PM compare register [1:0].
     */
  } Bits;
  UINT32 Data;
} XPPMCL1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMDH_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x20000490)                                                  */
/*       IVT_EX (0x20000490)                                                  */
/*       HSX (0x20000490)                                                     */
/*       BDX (0x20000490)                                                     */
/* Register default value:              0x0000                                */
#define XPPMDH_IIO_PCIEDMI_REG 0x0E002490
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Data High Bits
 * This register contains the high nibbles from each of the PMD 36-bit counter 
 * register. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT16 high_nibble_pex_counter0_value : 4;
    /* high_nibble_pex_counter0_value - Bits[3:0], RW_V, default = 4'b0000 
       High order bits [35:32] of the 36-bit PM Data0 register.
     */
    UINT16 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 high_nibble_pex_counter1_value : 4;
    /* high_nibble_pex_counter1_value - Bits[11:8], RW_V, default = 4'b0000 
       High order bits [35:32] of the 36-bit PM Data1 register.
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPPMDH_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMCH_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x20000492)                                                  */
/*       IVT_EX (0x20000492)                                                  */
/*       HSX (0x20000492)                                                     */
/*       BDX (0x20000492)                                                     */
/* Register default value:              0x0F0F                                */
#define XPPMCH_IIO_PCIEDMI_REG 0x0E002492
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Compare High Bits
 * This register contains the high nibbles from each of the PMC 36-bit compare 
 * registers. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT16 high_nibble_pex_compare0_value : 4;
    /* high_nibble_pex_compare0_value - Bits[3:0], RW_V, default = 4'b1111 
       High order bits [35:32] of the 36-bit PM Compare0 register.
     */
    UINT16 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 high_nibble_pex_compare1_value : 4;
    /* high_nibble_pex_compare1_value - Bits[11:8], RW_V, default = 4'b1111 
       High order bits [35:32] of the 36-bit PM Compare1 register.
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPPMCH_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMR0_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x40000494)                                                  */
/*       IVT_EX (0x40000494)                                                  */
/*       HSX (0x40000494)                                                     */
/*       BDX (0x40000494)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMR0_IIO_PCIEDMI_REG 0x0E004494
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Response Control
 * The PMR register controls operation of its associated counter, and provides 
 * overflow or max compare status information. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 counter_reset : 1;
    /* counter_reset - Bits[0:0], RW, default = 1'b0 
       Setting this bit resets the PMD counter, the associated adder storage register 
       and the count mode state latch (see bits CNTMD) to the default state. It does 
       not change the state of this PMR register, the event selections, or the value in 
       the compare register. 
       Note: This bit must be cleared by software, otherwise the counters remain in 
       reset. There is also a reset bit in the PERFCON register which clears all PM 
       registers including the PMR. 
     */
    UINT32 overflow_status_bit : 1;
    /* overflow_status_bit - Bits[1:1], RW1C, default = 1'b0 
       This status bit captures the overflow event from the PMD counter.
       This bit remains set once an event is reported even though the original 
       condition is no longer valid. Writing a logic '1' clears the bit. 
     */
    UINT32 compare_status : 1;
    /* compare_status - Bits[2:2], RW1C, default = 1'b0 
       This status bit captures a count compare event. The Compare Status field can be 
       programmed to allow this bit to be driven to Global Event (GE[3:0]) signals 
       which will then distribute the event to the debug logic. 
       0: no event
       1: count compare - PMD counter greater than PMC register when in compare mode.
       This bit remains set once an event is reported even though the original 
       condition is no longer valid. Writing a logic '1' clears the bit. 
     */
    UINT32 cto : 2;
    /* cto - Bits[4:3], RW, default = 2'b00 
       This field selects what the signal is communicated to the chip's event logic 
       structure. 
       00: No cluster trigger output from PerfMons or header match.
       01: PM Status.
       10: PM Event Detection.
       11: Reserved
     */
    UINT32 pm_status_signal_output : 1;
    /* pm_status_signal_output - Bits[5:5], RW, default = 1'b0 
       0: Level output from status/overflow signals.
       1: Pulsed output from status/overflow signals.
     */
    UINT32 compare_mode : 2;
    /* compare_mode - Bits[7:6], RW, default = 2'b00 
       This field defines how the PMC (compare) register is to be used.
       00: compare mode disabled (PMC register not used)
       01: max compare only: The PMC register value is compared with the counter value. 
       If the counter value is greater then the Compare Status (CMPSTAT) will be set. 
       10: max compare with update of PMC at end of sample: The PMC register value is 
       compared with the counter value, and if the counter value is greater, the PMC 
       register is updated with the counter value. Note, the Compare Status field is 
       not affected in this mode. 
       11: Reserved
     */
    UINT32 reset_event_select : 3;
    /* reset_event_select - Bits[10:8], RW, default = 3'b000 
       Counter and event status will reset and counting will continue.
       000: No reset condition
       001: Partner's event status: When the partner counter causes an event status 
       condition to be activated, either by a counter overflow or max comparison, then 
       this counter will reset and continue counting. 
       010: Partners PME register event: When the partner counter detects a match 
       condition which meets its selected PME register qualifications, then this 
       counter will reset and continue counting. 
       011: This PM counter's status output.
       100: GE[0], from the Global Debug Event Block.
       101: GE[1], from the Global Debug Event Block.
       110: GE[2], from the Global Debug Event Block.
       111: GE[3], from the Global Debug Event Block.
     */
    UINT32 counter_enable_source : 3;
    /* counter_enable_source - Bits[13:11], RW, default = 3'b000 
       These bits identify which input enables the counter. Default value disables 
       counting. 
       000: Disabled
       001: Local Count Enabled (LCEN). This bit is always a 1.
       010: Partner counter's event status (max compare or overflow)
       011: Reserved
       100: GE[0], from the Global Debug Event Block
       101: GE[1], from the Global Debug Event Block
       110: GE[2], from the Global Debug Event Block
       111: GE[3], from the Global Debug Event Block
       Note: Address/Header MatchOut signal must align with PMEVL,H events for this to 
       be effective. 
     */
    UINT32 count_mode : 2;
    /* count_mode - Bits[15:14], RW, default = 2'b00 
       This field sets how the events will be counted.
       00: Count clocks when event is logic high. Counting is level sensitive, whenever 
       the event is logic 1 the counter is enabled to count. 
       01: Count rising edge events. Active low signals should be inverted with 
       EVPOLINV for correct measurements. 
       10: Latch event and count clocks continuously. After the event is asserted, 
       latch this state and count clocks continuously. The latched state of this 
       condition is cleared by xxxPMRx.CNTRST bit, or PERFCON.GBRST, or GE[3:0]. 
       11: Enable FIFO (push/pop) queue histogram measurement. This mode will enable 
       histogram measurements on PM0. This mode enable logic to perform the function 
       listed in the table below. The measurement cycle will not begin until the Qempty 
       signal is asserted. 
       FIFO queue histogram table
       FIFOn_Push, FIFOn_POP, PMD Adder control
       0, 0, Add zero
       1, 0, Add queue bus value
       0, 1, Sub queue bus value
       1, 1, Add zero
       The latched condition of the Qempty signal cannot be cleared by PMR.CLREVLAT. A 
       new measurement cycle requires clearing all counters and the latched value by 
       asserting either PMRx.CNTRST or PERFCON.GBRST. 
     */
    UINT32 event_polarity_invert : 1;
    /* event_polarity_invert - Bits[16:16], RW, default = 1'b0 
       This bit inverts the polarity of the conditioned event signal.
       0: No inversion
       1: Invert the polarity of the conditioned event signal
     */
    UINT32 count_event_select : 2;
    /* count_event_select - Bits[18:17], RW, default = 2'b00 
       Selects the condition for incrementing the performance monitor counter.
       00: Event source selected by PMEVL,H
       01: Partner event status (max compare or overflow)
       10: All clocks when enabled
       11: Reserved
     */
    UINT32 event_group_selection : 2;
    /* event_group_selection - Bits[20:19], RW, default = 2'b00 
       Selects which event register to use for performance monitoring.
       00: Bus events (XPMEVL,H register) and also Resource Utilizations (XP_PMER 
       Registers) when all XP_PMEH and XP_PMEL Registers are set to '0'. i.e. When 
       monitoring PMER events, all PMEV events are to be deselected; when monitoring 
       PMEV events, all PMER events are to be deselcted. 
       01: Reserved
       10: Queue measurement (in the XPPMER register). Note: To enable FIFO queue 
       histogramming write bit field CNTMD ='11' and select queues in the XPPMER 
       register. 
       11: Reserved
     */
    UINT32 rsvd_21 : 6;
    UINT32 reset_pulse_enable : 1;
    /* reset_pulse_enable - Bits[27:27], RW, default = 1'b0 
       Setting this bit will select a pulsed version of the reset signal source in the 
       reset block. 
       0: Normal reset signaling
       1: Select a pulsed reset from the reset signal sources.
     */
    UINT32 latched_count_enable_select : 1;
    /* latched_count_enable_select - Bits[28:28], RW, default = 1'b0 
       0: Normal PM operation. Use CENS as count enable.
       1: Use Latched count enable from queue empty events
     */
    UINT32 force_pmd_counter_to_add_zero_to_input : 1;
    /* force_pmd_counter_to_add_zero_to_input - Bits[29:29], RW, default = 1'b0 
       This feature is used with the queue measurement bus. When this bit is set the 
       value on the queue measurement bus is added to zero so the result in PMD will 
       always reflect the value from the queue measurement bus. 
       0: Do not add zero. Normal PerfMon operation.
       1: Add zero with input queue bus.
     */
    UINT32 not_greater_than_comparison : 1;
    /* not_greater_than_comparison - Bits[30:30], RW, default = 1'b0 
       0: PMC will compare a greater than function. When clear the perfmon status will 
       assert when the PMD is greater than the PMC. 
       1: PMC will compare with NOT(greater than) function. When set the perfmon status 
       will assert when the PMD is less than or equal to the PMC. 
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMR0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMR1_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x40000498)                                                  */
/*       IVT_EX (0x40000498)                                                  */
/*       HSX (0x40000498)                                                     */
/*       BDX (0x40000498)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMR1_IIO_PCIEDMI_REG 0x0E004498
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Response Control
 * The PMR register controls operation of its associated counter, and provides 
 * overflow or max compare status information. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 counter_reset : 1;
    /* counter_reset - Bits[0:0], RW, default = 1'b0 
       Setting this bit resets the PMD counter, the associated adder storage register 
       and the count mode state latch (see bits CNTMD) to the default state. It does 
       not change the state of this PMR register, the event selections, or the value in 
       the compare register. 
       Note: This bit must be cleared by software, otherwise the counters remain in 
       reset. There is also a reset bit in the PERFCON register which clears all PM 
       registers including the PMR. 
     */
    UINT32 overflow_status_bit : 1;
    /* overflow_status_bit - Bits[1:1], RW1C, default = 1'b0 
       This status bit captures the overflow event from the PMD counter.
       This bit remains set once an event is reported even though the original 
       condition is no longer valid. Writing a logic '1' clears the bit. 
     */
    UINT32 compare_status : 1;
    /* compare_status - Bits[2:2], RW1C, default = 1'b0 
       This status bit captures a count compare event. The Compare Status field can be 
       programmed to allow this bit to be driven to Global Event (GE[3:0]) signals 
       which will then distribute the event to the debug logic. 
       0: no event
       1: count compare - PMD counter greater than PMC register when in compare mode.
       This bit remains set once an event is reported even though the original 
       condition is no longer valid. Writing a logic '1' clears the bit. 
     */
    UINT32 cto : 2;
    /* cto - Bits[4:3], RW, default = 2'b00 
       This field selects what the signal is communicated to the chip's event logic 
       structure. 
       00: No cluster trigger output from PerfMons or header match.
       01: PM Status.
       10: PM Event Detection.
       11: Reserved
     */
    UINT32 pm_status_signal_output : 1;
    /* pm_status_signal_output - Bits[5:5], RW, default = 1'b0 
       0: Level output from status/overflow signals.
       1: Pulsed output from status/overflow signals.
     */
    UINT32 compare_mode : 2;
    /* compare_mode - Bits[7:6], RW, default = 2'b00 
       This field defines how the PMC (compare) register is to be used.
       00: compare mode disabled (PMC register not used)
       01: max compare only: The PMC register value is compared with the counter value. 
       If the counter value is greater then the Compare Status (CMPSTAT) will be set. 
       10: max compare with update of PMC at end of sample: The PMC register value is 
       compared with the counter value, and if the counter value is greater, the PMC 
       register is updated with the counter value. Note, the Compare Status field is 
       not affected in this mode. 
       11: Reserved
     */
    UINT32 reset_event_select : 3;
    /* reset_event_select - Bits[10:8], RW, default = 3'b000 
       Counter and event status will reset and counting will continue.
       000: No reset condition
       001: Partner's event status: When the partner counter causes an event status 
       condition to be activated, either by a counter overflow or max comparison, then 
       this counter will reset and continue counting. 
       010: Partners PME register event: When the partner counter detects a match 
       condition which meets its selected PME register qualifications, then this 
       counter will reset and continue counting. 
       011: This PM counter's status output.
       100: GE[0], from the Global Debug Event Block.
       101: GE[1], from the Global Debug Event Block.
       110: GE[2], from the Global Debug Event Block.
       111: GE[3], from the Global Debug Event Block.
     */
    UINT32 counter_enable_source : 3;
    /* counter_enable_source - Bits[13:11], RW, default = 3'b000 
       These bits identify which input enables the counter. Default value disables 
       counting. 
       000: Disabled
       001: Local Count Enabled (LCEN). This bit is always a 1.
       010: Partner counter's event status (max compare or overflow)
       011: Reserved
       100: GE[0], from the Global Debug Event Block
       101: GE[1], from the Global Debug Event Block
       110: GE[2], from the Global Debug Event Block
       111: GE[3], from the Global Debug Event Block
       Note: Address/Header MatchOut signal must align with PMEVL,H events for this to 
       be effective. 
     */
    UINT32 count_mode : 2;
    /* count_mode - Bits[15:14], RW, default = 2'b00 
       This field sets how the events will be counted.
       00: Count clocks when event is logic high. Counting is level sensitive, whenever 
       the event is logic 1 the counter is enabled to count. 
       01: Count rising edge events. Active low signals should be inverted with 
       EVPOLINV for correct measurements. 
       10: Latch event and count clocks continuously. After the event is asserted, 
       latch this state and count clocks continuously. The latched state of this 
       condition is cleared by xxxPMRx.CNTRST bit, or PERFCON.GBRST, or GE[3:0]. 
       11: Enable FIFO (push/pop) queue histogram measurement. This mode will enable 
       histogram measurements on PM0. This mode enable logic to perform the function 
       listed in the table below. The measurement cycle will not begin until the Qempty 
       signal is asserted. 
       FIFO queue histogram table
       FIFOn_Push, FIFOn_POP, PMD Adder control
       0, 0, Add zero
       1, 0, Add queue bus value
       0, 1, Sub queue bus value
       1, 1, Add zero
       The latched condition of the Qempty signal cannot be cleared by PMR.CLREVLAT. A 
       new measurement cycle requires clearing all counters and the latched value by 
       asserting either PMRx.CNTRST or PERFCON.GBRST. 
     */
    UINT32 event_polarity_invert : 1;
    /* event_polarity_invert - Bits[16:16], RW, default = 1'b0 
       This bit inverts the polarity of the conditioned event signal.
       0: No inversion
       1: Invert the polarity of the conditioned event signal
     */
    UINT32 count_event_select : 2;
    /* count_event_select - Bits[18:17], RW, default = 2'b00 
       Selects the condition for incrementing the performance monitor counter.
       00: Event source selected by PMEVL,H
       01: Partner event status (max compare or overflow)
       10: All clocks when enabled
       11: Reserved
     */
    UINT32 event_group_selection : 2;
    /* event_group_selection - Bits[20:19], RW, default = 2'b00 
       Selects which event register to use for performance monitoring.
       00: Bus events (XPMEVL,H register) and also Resource Utilizations (XP_PMER 
       Registers) when all XP_PMEH and XP_PMEL Registers are set to '0'. i.e. When 
       monitoring PMER events, all PMEV events are to be deselected; when monitoring 
       PMEV events, all PMER events are to be deselcted. 
       01: Reserved
       10: Queue measurement (in the XPPMER register). Note: To enable FIFO queue 
       histogramming write bit field CNTMD ='11' and select queues in the XPPMER 
       register. 
       11: Reserved
     */
    UINT32 rsvd_21 : 6;
    UINT32 reset_pulse_enable : 1;
    /* reset_pulse_enable - Bits[27:27], RW, default = 1'b0 
       Setting this bit will select a pulsed version of the reset signal source in the 
       reset block. 
       0: Normal reset signaling
       1: Select a pulsed reset from the reset signal sources.
     */
    UINT32 latched_count_enable_select : 1;
    /* latched_count_enable_select - Bits[28:28], RW, default = 1'b0 
       0: Normal PM operation. Use CENS as count enable.
       1: Use Latched count enable from queue empty events
     */
    UINT32 force_pmd_counter_to_add_zero_to_input : 1;
    /* force_pmd_counter_to_add_zero_to_input - Bits[29:29], RW, default = 1'b0 
       This feature is used with the queue measurement bus. When this bit is set the 
       value on the queue measurement bus is added to zero so the result in PMD will 
       always reflect the value from the queue measurement bus.0: Do not add zero. 
       Normal PerfMon operation. 1: Add zero with input queue bus. 
     */
    UINT32 not_greater_than_comparison : 1;
    /* not_greater_than_comparison - Bits[30:30], RW, default = 1'b0 
       0: PMC will compare a greater than function. When clear the perfmon status will 
       assert when the PMD is greater than the PMC. 
       1: PMC will compare with NOT(greater than) function. When set the perfmon status 
       will assert when the PMD is less than or equal to the PMC. 
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMR1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMEVL0_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x4000049C)                                                  */
/*       IVT_EX (0x4000049C)                                                  */
/*       HSX (0x4000049C)                                                     */
/*       BDX (0x4000049C)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVL0_IIO_PCIEDMI_REG 0x0E00449C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Events Low
 * Selections in this register correspond to fields within the PCIe header. Each 
 * field selection is logically combined according to the match equation. The 
 * qualifications for fields in this register are listed below. It should be noted 
 * that the bit selections are generic for packet and for either inbound or 
 * outbound direction. Because of this, there will be bit fields that do not make 
 * sense. For these packet matching situations the user should select Either which 
 * acts as a do not care for the match equation PCIe PerfMon Match Equation PMEV 
 * Match = ((IO_Cfg_Write_event + IO_Cfg_Read_event _+ Mem_Write_event + 
 * Mem_Read_event + Trusted_write_event + Trusted_read_event + General_event) & 
 * INOUTBND) + GESEL  
 * - IO_Cfg_Write_event = (REQCMP[0] & CMPR[1] & RDWR[1] & DATALEN & (TTYP[2] + 
 * (TTYP[1] & CFGTYP)))  
 * - IO_Cfg_Read_event = (REQCMP[0] & CMPR[1] & RDWR[0] & DATALEN & (TTYP[2] + 
 * (FMTTYP[1] & CFGTYP)))  
 * - Mem_Write_event = (REQCMP[0] & CMPR[0] & RDWR[1] & DATALEN & TTYP[3] & LOCK & 
 * EXTADDR & SNATTR)  
 * Note: An outbound memory write does not have a snoop attribute as an inbound 
 * memory write has. So the user should set SNATTR=11 for outbound memory write 
 * transaction event counting. Mem_Read_event = (REQCMP[0] & CMPR[1] & RDWR[0] & 
 * DATALEN & (( TTYP[3] & LOCK & EXTADDR & SNATTR) + TTYP[2] + (TTYP[1] & CFGTYP))) 
 * Note: For outbound memory reads there is no concept of issuing a snoop cycle. 
 * The user should select SNATTR=11 for either snoop attribute. Msg_event = 
 * (TTYP[0] & DND) (INOUTBND[0] & (MatchEq) + (IOBND[1] & (MatchEq) Setting both 
 * bits in INOUTBND is acceptable however the performance data gathered will not be 
 * accurate since once one header can be counted at a time. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    UINT32 data_length : 7;
    /* data_length - Bits[10:4], RW, default = 7'b0000000 
       1xx_xxxx: (129 to 256 bytes)
       x1x_xxxx: (65 to 128 bytes)
       xx1_xxxx: (33 to 64 bytes)
       xxx_1xxx: (17 to 32 bytes)
       xxx_x1xx: (9 to 16 bytes)
       xxx_xx1x: (0 to 8 bytes)
       xxx_xxx1: 0 bytes, used for a special zero length encoded packets
       111_1111: Any Data length
     */
    UINT32 fmttyp : 5;
    /* fmttyp - Bits[15:11], RW, default = 5'b00000 
       1_xxxx: Trusted
       x_1xxx: Memory
       x_x1xx: IO
       x_xx1x: Configuration
       x_xxx1: Messages
       1_1111: Any transaction type
     */
    UINT32 cfgtyp : 2;
    /* cfgtyp - Bits[17:16], RW, default = 2'b00 
       x1: Type 0
       1x: Type 1
       11: Either
     */
    UINT32 extended_addressing_header : 2;
    /* extended_addressing_header - Bits[19:18], RW, default = 2'b00 
       x1: 32b addressing
       1x: 64b addressing
       11: Either
     */
    UINT32 lock_attribute_selection : 2;
    /* lock_attribute_selection - Bits[21:20], RW, default = 2'b00 
       x1: No Lock
       1x: Lock
       11: Either
     */
    UINT32 request_packet_only : 2;
    /* request_packet_only - Bits[23:22], RW, default = 2'b00 
       Completion Required
       x1: No Completion Required
       1x: Completion Required
       11: Either
     */
    UINT32 read_or_write_selection : 2;
    /* read_or_write_selection - Bits[25:24], RW, default = 2'b00 
       x1: Read
       1x: Write
       11: Either
     */
    UINT32 request_or_completion_packet_selection : 2;
    /* request_or_completion_packet_selection - Bits[27:26], RW, default = 2'b00 
       x1: Request packet
       1x: Completion packet
       11: Either
     */
    UINT32 snoop_attribute : 2;
    /* snoop_attribute - Bits[29:28], RW, default = 2'b00 
       x1: No snoop required
       1x: Snoop required
       11: Either
     */
    UINT32 data_or_no_data_attribute : 2;
    /* data_or_no_data_attribute - Bits[31:30], RW, default = 2'b00 
       x1: Request/completion/message with data
       1x: Request/completion/message packet without data
     */
  } Bits;
  UINT32 Data;
} XPPMEVL0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMEVL1_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x400004A0)                                                  */
/*       IVT_EX (0x400004A0)                                                  */
/*       HSX (0x400004A0)                                                     */
/*       BDX (0x400004A0)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVL1_IIO_PCIEDMI_REG 0x0E0044A0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Events Low
 * Selections in this register correspond to fields within the PCIe header. Each 
 * field selection is logically combined according to the match equation. The 
 * qualifications for fields in this register are listed below. It should be noted 
 * that the bit selections are generic for packet and for either inbound or 
 * outbound direction. Because of this, there will be bit fields that do not make 
 * sense. For these packet matching situations the user should select Either which 
 * acts as a do not care for the match equation PCIe PerfMon Match Equation PMEV 
 * Match = ((IO_Cfg_Write_event + IO_Cfg_Read_event _+ Mem_Write_event + 
 * Mem_Read_event + Trusted_write_event + Trusted_read_event + General_event) & 
 * INOUTBND) + GESEL  
 * - IO_Cfg_Write_event = (REQCMP[0] & CMPR[1] & RDWR[1] & DATALEN & (TTYP[2] + 
 * (TTYP[1] & CFGTYP)))  
 * - IO_Cfg_Read_event = (REQCMP[0] & CMPR[1] & RDWR[0] & DATALEN & (TTYP[2] + 
 * (FMTTYP[1] & CFGTYP)))  
 * - Mem_Write_event = (REQCMP[0] & CMPR[0] & RDWR[1] & DATALEN & TTYP[3] & LOCK & 
 * EXTADDR & SNATTR)  
 * Note: An outbound memory write does not have a snoop attribute as an inbound 
 * memory write has. So the user should set SNATTR=11 for outbound memory write 
 * transaction event counting. Mem_Read_event = (REQCMP[0] & CMPR[1] & RDWR[0] & 
 * DATALEN & (( TTYP[3] & LOCK & EXTADDR & SNATTR) + TTYP[2] + (TTYP[1] & CFGTYP))) 
 * Note: For outbound memory reads there is no concept of issuing a snoop cycle. 
 * The user should select SNATTR=11 for either snoop attribute. Msg_event = 
 * (TTYP[0] & DND) (INOUTBND[0] & (MatchEq) + (IOBND[1] & (MatchEq) Setting both 
 * bits in INOUTBND is acceptable however the performance data gathered will not be 
 * accurate since once one header can be counted at a time. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    UINT32 data_length : 7;
    /* data_length - Bits[10:4], RW, default = 7'b0000000 
       1xx_xxxx: (129 to 256 bytes)
       x1x_xxxx: (65 to 128 bytes)
       xx1_xxxx: (33 to 64 bytes)
       xxx_1xxx: (17 to 32 bytes)
       xxx_x1xx: (9 to 16 bytes)
       xxx_xx1x: (0 to 8 bytes)
       xxx_xxx1: 0 bytes, used for a special zero length encoded packets
       111_1111: Any Data length
     */
    UINT32 fmttyp : 5;
    /* fmttyp - Bits[15:11], RW, default = 5'b00000 
       1_xxxx: Trusted
       x_1xxx: Memory
       x_x1xx: IO
       x_xx1x: Configuration
       x_xxx1: Messages
       1_1111: Any transaction type
     */
    UINT32 cfgtyp : 2;
    /* cfgtyp - Bits[17:16], RW, default = 2'b00 
       x1: Type 0
       1x: Type 1
       11: Either
     */
    UINT32 extended_addressing_header : 2;
    /* extended_addressing_header - Bits[19:18], RW, default = 2'b00 
       x1: 32b addressing
       1x: 64b addressing
       11: Either
     */
    UINT32 lock_attribute_selection : 2;
    /* lock_attribute_selection - Bits[21:20], RW, default = 2'b00 
       x1: No Lock
       1x: Lock
       11: Either
     */
    UINT32 cmpreq : 2;
    /* cmpreq - Bits[23:22], RW, default = 2'b00 
       Completion Required
       x1: No Completion Required
       1x: Completion Required
       11: Either
     */
    UINT32 read_or_write_selection : 2;
    /* read_or_write_selection - Bits[25:24], RW, default = 2'b00 
       x1: Read
       1x: Write
       11: Either
     */
    UINT32 request_or_completion_packet_selection : 2;
    /* request_or_completion_packet_selection - Bits[27:26], RW, default = 2'b00 
       x1: Request packet
       1x: Completion packet
       11: Either
     */
    UINT32 snoop_attribute : 2;
    /* snoop_attribute - Bits[29:28], RW, default = 2'b00 
       x1: No snoop required
       1x: Snoop required
       11: Either
     */
    UINT32 data_or_no_data_attribute : 2;
    /* data_or_no_data_attribute - Bits[31:30], RW, default = 2'b00 
       x1: Request/completion/message with data
       1x: Request/completion/message packet without data
     */
  } Bits;
  UINT32 Data;
} XPPMEVL1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMEVH0_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x400004A4)                                                  */
/*       IVT_EX (0x400004A4)                                                  */
/*       HSX (0x400004A4)                                                     */
/*       BDX (0x400004A4)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVH0_IIO_PCIEDMI_REG 0x0E0044A4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Events High
 * Selections in this register correspond to fields within the PEX packet header. 
 * Each field selection is ANDed with all other fields in this register including 
 * the XPPMEVL except for the Global Event signals. These signals are ORed with any 
 * event in the XPPMEVL and enables for debug operations requiring the accumulation 
 * of specific debug signals. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 inbound_or_outbound_selection : 2;
    /* inbound_or_outbound_selection - Bits[1:0], RW, default = 2'b00 
       Selects which path to count transactions.
       1x: Outbound
       x1: Inbound (from PCI bus)
       11: Either
     */
    UINT32 global_event_selection : 6;
    /* global_event_selection - Bits[7:2], RW, default = 6'b000000 
       Selects which GE[3:0] is used for event counting. This field is OR'd with other 
       fields in this register. The GEs cannot be qualified with other PerfMon signals. 
       If more than 1 GE is selected then the resultant event is the OR between each 
       GE. However, properly counting Global Event based on design, XP PM Response 
       Control Register bit [13:11] CENS must be set to choose GE[3:0] and also 
       bit[18:17] CNTEVSEL must be set to 2'b10. 
       1x_xxxx: GE[5]
       x1_xxxx: GE[4]
       xx_1xxx: GE[3]
       xx_x1xx: GE[2]
       xx_xx1x: GE[1]
       xx_xxx1: GE[0]
     */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMEVH0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMEVH1_IIO_PCIEDMI_REG supported on:                                     */
/*       IVT_EP (0x400004A8)                                                  */
/*       IVT_EX (0x400004A8)                                                  */
/*       HSX (0x400004A8)                                                     */
/*       BDX (0x400004A8)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVH1_IIO_PCIEDMI_REG 0x0E0044A8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * Selections in this register correspond to fields within the PEX packet header. 
 * Each field selection is ANDed with all other fields in this register including 
 * the XPPMEVL except for the Global Event signals. These signals are ORed with any 
 * event in the XPPMEVL and enables for debug operations requiring the accumulation 
 * of specific debug signals. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 inbound_or_outbound_selection : 2;
    /* inbound_or_outbound_selection - Bits[1:0], RW, default = 2'b00 
       Selects which path to count transactions.
       1x: Outbound
       x1: Inbound (from PCI bus)
       11: Either
     */
    UINT32 global_event_selection : 6;
    /* global_event_selection - Bits[7:2], RW, default = 6'b000000 
       Selects which GE[3:0] is used for event counting. This field is OR'd with other 
       fields in this register. The GEs cannot be qualified with other PerfMon signals. 
       If more than 1 GE is selected then the resultant event is the OR between each 
       GE. However, properly counting Global Event based on design, XP PM Response 
       Control Register bit [13:11] CENS must be set to choose GE[3:0] and also 
       bit[18:17] CNTEVSEL must be set to 2'b10. 
       1x_xxxx: GE[5]
       x1_xxxx: GE[4]
       xx_1xxx: GE[3]
       xx_x1xx: GE[2]
       xx_xx1x: GE[1]
       xx_xxx1: GE[0]
     */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMEVH1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMER0_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x400004AC)                                                  */
/*       IVT_EX (0x400004AC)                                                  */
/*       HSX (0x400004AC)                                                     */
/*       BDX (0x400004AC)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMER0_IIO_PCIEDMI_REG 0x0E0044AC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Resource Events
 * This register is used to select queuing structures for measurement. Use of this 
 * event register is mutually exclusive with the XPPMEVL,H registers. The Event 
 * Register Select field in the PMR register must select this register for to 
 * enable monitoring operations of the queues. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000 
       Queue Measurement Bus Select: This field selects a queue to monitor. These 
       queues are connected the QueueMeasBus that is derived from the difference in the 
       write and read pointers. 
       000000: No queues selected =selected -1-
       010001: xp0, xp3, xp7 - Inbound data payload
       010010: xp1, xp4, xp8 - Inbound data payload
       010100: xp2, xp5, xp9 - Inbound data payload
       011000: NA, xp6, xp10 - Inbound data payload
       100001: xp0, xp3, xp7 - Outbound data payload
       100010: xp1, xp4, xp8 - Outbound data payload
       100100: xp2, xp5, xp9 - Outbound data payload
       101000: NA, xp6, xp10 - Outbound data payload
       others: reserved NA: not applicable.
     */
    UINT32 flowcntrclass : 2;
    /* flowcntrclass - Bits[7:6], RW, default = 2'b00  */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 link_send_utilization : 4;
    /* link_send_utilization - Bits[16:13], RW, default = 4'b0000 
       This level signal that is active when the link could send a packet or an idle. 
       The choices are a logic idle flit, a link layer packet, or a transaction layer 
       packet. The user can count the number of clocks that the link is not active by 
       inverting this signal in the event conditioning logic (PMR.EVPOLINV = 1). 
       The selection listed combines all the links for clarity. If the user is 
       operating on XP3 then the bit field selects Links[6:3] only. 
       0000: No event selected
       1000: Link 6 (xp3), link 10 (xp7), reserved, reserved
       0100: Link 5 (xp3), link 9 (xp7), reserved, reserved
       0010: Link 4 (xp3), link 8 (xp7), port 2 (xp0), reserved
       0001: Link 3 (xp3), link 7 (xp7), link 1 (xp0), link 0 (xp0 -DMI)
     */
    UINT32 xp_resource_assignment : 4;
    /* xp_resource_assignment - Bits[20:17], RW, default = 4'b0000 
       This selects which PCI-Express links are being monitored.
       A logic 1 selects that PCIe link for monitoring.
       1000: Select NA / PXP6 / PXP10 (depending on device number) for monitoring.
       0100: Select PXP2 / PXP5 / PXP9 (depending on device number) for monitoring.
       0010: Select PXP1 / PXP4 / PXP8 (depending on device number) for monitoring.
       0001: Select PXP / PXP3 / PXP7 (depending on device number) for monitoring.
     */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMER0_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */


/* XPPMER1_IIO_PCIEDMI_REG supported on:                                      */
/*       IVT_EP (0x400004B0)                                                  */
/*       IVT_EX (0x400004B0)                                                  */
/*       HSX (0x400004B0)                                                     */
/*       BDX (0x400004B0)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMER1_IIO_PCIEDMI_REG 0x0E0044B0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.0.0.Port0_DMI.xml.
 * XP PM Resource Events
 * This register is used to select queuing structures for measurement. Use of this 
 * event register is mutually exclusive with the XPPMEVL,H registers. The Event 
 * Register Select field in the PMR register must select this register for to 
 * enable monitoring operations of the queues. 
 * This register is only implemented in device 2 and 3, function 0. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000 
       Queue Measurement Bus Select: This field selects a queue to monitor. These 
       queues are connected the QueueMeasBus that is derived from the difference in the 
       write and read pointers. 
       000000: No queues selected =selected -1-
       010001: xp0, xp3, xp7 - Inbound data payload
       010010: xp1, xp4, xp8 - Inbound data payload
       010100: xp2, xp5, xp9 - Inbound data payload
       011000: NA, xp6, xp10 - Inbound data payload
       100001: xp0, xp3, xp7 - Outbound data payload
       100010: xp1, xp4, xp8 - Outbound data payload
       100100: xp2, xp5, xp9 - Outbound data payload
       101000: NA, xp6, xp10 - Outbound data payload
       others: reserved NA: not applicable.
     */
    UINT32 flowcntrclass : 2;
    /* flowcntrclass - Bits[7:6], RW, default = 2'b00  */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 link_send_utilization : 4;
    /* link_send_utilization - Bits[16:13], RW, default = 4'b0000 
       This level signal that is active when the link could send a packet or an idle. 
       The choices are a logic idle flit, a link layer packet, or a transaction layer 
       packet. The user can count the number of clocks that the link is not active by 
       inverting this signal in the event conditioning logic (PMR.EVPOLINV = 1). 
       The selection listed combines all the links for clarity. If the user is 
       operating on XP3 then the bit field selects Links[6:3] only. 
       0000: No event selected
       1000: Link 6 (xp3), link 10 (xp7), reserved, reserved
       0100: Link 5 (xp3), link 9 (xp7), reserved, reserved
       0010: Link 4 (xp3), link 8 (xp7), port 2 (xp0), reserved
       0001: Link 3 (xp3), link 7 (xp7), link 1 (xp0), link 0 (xp0 -DMI)
     */
    UINT32 xp_resource_assignment : 4;
    /* xp_resource_assignment - Bits[20:17], RW, default = 4'b0000 
       This selects which PCI-Express links are being monitored.
       A logic 1 selects that PCIe link for monitoring.
       1000: Select NA / PXP6 / PXP10 (depending on device number) for monitoring.
       0100: Select PXP2 / PXP5 / PXP9 (depending on device number) for monitoring.
       0010: Select PXP1 / PXP4 / PXP8 (depending on device number) for monitoring.
       0001: Select PXP / PXP3 / PXP7 (depending on device number) for monitoring.
     */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMER1_IIO_PCIEDMI_STRUCT;
#endif /* ASM_INC */










/* RID_IIO_PCIEDMI_REG supported on:                                          */
/*       IVT_EP (0x10000008)                                                  */
/*       IVT_EX (0x10000008)                                                  */
/* Register default value:              0x00                                  */
#define RID_IIO_PCIEDMI_REG 0x0E001008



/* CCR_N0_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x10000009)                                                  */
/*       IVT_EX (0x10000009)                                                  */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_PCIEDMI_REG 0x0E001009



/* CCR_N1_IIO_PCIEDMI_REG supported on:                                       */
/*       IVT_EP (0x2000000A)                                                  */
/*       IVT_EX (0x2000000A)                                                  */
/* Register default value:              0x0600                                */
#define CCR_N1_IIO_PCIEDMI_REG 0x0E00200A



#endif /* IIO_PCIEDMI_h */
