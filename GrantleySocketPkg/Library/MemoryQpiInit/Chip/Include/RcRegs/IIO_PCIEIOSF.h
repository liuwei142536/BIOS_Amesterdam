/* Date Stamp: 9/4/2013 */

#ifndef IIO_PCIEIOSF_h
#define IIO_PCIEIOSF_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For BDX_HOST:                                                              */
/* IIO_PCIEIOSF_BDX_DEV 2                                                     */
/* IIO_PCIEIOSF_BDX_FUN 0                                                     */

/* VID_IIO_PCIEIOSF_REG supported on:                                         */
/*       BDX (0x20010000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_PCIEIOSF_REG 0x14002000

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DID_IIO_PCIEIOSF_REG supported on:                                         */
/*       BDX (0x20010002)                                                     */
/* Register default value:              0x6F04                                */
#define DID_IIO_PCIEIOSF_REG 0x14002002

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'b0110111100000100 
       Device ID values vary from function to function. Bits 15:8 are equal to 0x6F for 
       the processor. The following list is a breakdown of the function groups. 
       0x6F00 - 0x6F1F : PCI Express and DMI ports
       0x6F20 - 0x6F3F : IO Features (CBDMA, APIC, VT, RAS, Intel TXT)
       0x6F40 - 0x6F5F : Performance Monitors
       0x6F60 - 0x6F7F : DFX
       0x6F80 - 0x6F9F : Intel Quick Path Interface
       0x6FA0 - 0x6FBF : Home Agent/Memory Controller
       0x6FC0 - 0x6FDF : Power Management
       0x6FE0 - 0x6FFF : Cbo/Ring
       
     */
  } Bits;
  UINT16 Data;
} DID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PCICMD_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x20010004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_PCIEIOSF_REG 0x14002004

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x004
 */
typedef union {
  struct {
    UINT16 iose : 1;
    /* iose - Bits[0:0], RW, default = 1'b0 
       1
     */
    UINT16 mse : 1;
    /* mse - Bits[1:1], RW, default = 1'b0 
       1
     */
    UINT16 bme : 1;
    /* bme - Bits[2:2], RW, default = 1'b0 
       1
     */
    UINT16 sce : 1;
    /* sce - Bits[3:3], RO, default = 1'b0  */
    UINT16 mwie : 1;
    /* mwie - Bits[4:4], RO, default = 1'b0  */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0  */
    UINT16 perre : 1;
    /* perre - Bits[6:6], RW, default = 1'b0  */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0  */
    UINT16 serre : 1;
    /* serre - Bits[8:8], RW, default = 1'b0  */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0  */
    UINT16 interrupt_disable : 1;
    /* interrupt_disable - Bits[10:10], RW, default = 1'b0 
       1
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PCISTS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x20010006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_PCIEIOSF_REG 0x14002006

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x006
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO_V, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1  */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0  */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0  */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0  */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00  */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0  */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0  */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0  */
    UINT16 sse : 1;
    /* sse - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RID_IIO_PCIEIOSF_REG supported on:                                         */
/*       BDX (0x10010008)                                                     */
/* Register default value:              0x00                                  */
#define RID_IIO_PCIEIOSF_REG 0x14001008

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * "PCIe header Revision ID register"
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], RO_V, default = 8'b00000000 
       Reflects the Uncore Revision ID after reset.
       Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID 
       register in the processor uncore. 
       
     */
  } Bits;
  UINT8 Data;
} RID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CCR_N0_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x10010009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_PCIEIOSF_REG 0x14001009

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT8 register_level_programming_interface : 8;
    /* register_level_programming_interface - Bits[7:0], RO_V, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} CCR_N0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CCR_N1_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x2001000A)                                                     */
/* Register default value:              0x0604                                */
#define CCR_N1_IIO_PCIEIOSF_REG 0x1400200A

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO_V, default = 8'b00000100 
       The value changes dependent upon the dev/func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h80 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h01. 
                 dev-0x0 through 0x7 (return 0x4, d0f0 return 0x0 under default 
       settings) 
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO_V, default = 8'b00000110 
       The value changes dependent upon the dev-func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h08 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h11. 
                 dev-0x0 through 0x7 (return 0x6)
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
  } Bits;
  UINT16 Data;
} CCR_N1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CLSR_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x1001000C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_PCIEIOSF_REG 0x1400100C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only.
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLAT_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x1001000D)                                                     */
/* Register default value:              0x00                                  */
#define PLAT_IIO_PCIEIOSF_REG 0x1400100D

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x00d
 */
typedef union {
  struct {
    UINT8 primary_latency_timer : 8;
    /* primary_latency_timer - Bits[7:0], RO, default = 8'b00000000 
       Not applicable to PCI-Express. Hardwired to 00h.
     */
  } Bits;
  UINT8 Data;
} PLAT_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDR_IIO_PCIEIOSF_REG supported on:                                         */
/*       BDX (0x1001000E)                                                     */
/* Register default value:              0x81                                  */
#define HDR_IIO_PCIEIOSF_REG 0x1400100E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x00e
 */
typedef union {
  struct {
    UINT8 cl : 7;
    /* cl - Bits[6:0], RO, default = 7'b0000001 
       This field identifies the format of the configuration header layout. It is Type1 
       for all PCI Express root ports. The default is 01h, indicating a 'PCI to PCI 
       Bridge'. 
     */
    UINT8 mfd : 1;
    /* mfd - Bits[7:7], RO_V, default = 1'b1 
       This bit defaults to 1 for Devices 1-3 since these are multi-function devices.
       BIOS can individually control the value of this bit in Function 0 of these 
       devices, based on HDRTYPCTRL register. BIOS will write to that register to 
       change this field to 0 in Function 0 of these devices, if it exposes only 
       Function 0 in the device to OS. 
       Notes:
       In product SKUs where only Function 0 of the device is exposed to any software 
       (BIOS/OS), BIOS would have to still set the control bits mentioned above to set 
       the this bit in this register to be compliant per PCI rules. 
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* BIST_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x1001000F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_IIO_PCIEIOSF_REG 0x1400100F

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x00f
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} BIST_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PBUS_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x10010018)                                                     */
/* Register default value:              0x00                                  */
#define PBUS_IIO_PCIEIOSF_REG 0x14001018

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x018
 */
typedef union {
  struct {
    UINT8 pbn : 8;
    /* pbn - Bits[7:0], RW, default = 8'b00000000 
       Configuration software programs this field with the number of the bus on the 
       primary side of the bridge. This register has to be kept consistent with the 
       Internal Bus Number 0 in the CPUBUSNO01 register. BIOS (and OS if internal bus 
       number gets moved) must program this register to the correct value since IIO 
       hardware would depend on this register for inbound configuration cycle decode 
       purposes. 
     */
  } Bits;
  UINT8 Data;
} PBUS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SECBUS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x10010019)                                                     */
/* Register default value:              0x00                                  */
#define SECBUS_IIO_PCIEIOSF_REG 0x14001019

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x019
 */
typedef union {
  struct {
    UINT8 sbn : 8;
    /* sbn - Bits[7:0], RW, default = 8'b00000000 
       This field is programmed by configuration software to assign a bus number to the 
       secondary bus of the virtual P2P bridge. IIO uses this register to either 
       forward a configuration transaction as a Type 1 or Type 0 to PCI Express. 
       
     */
  } Bits;
  UINT8 Data;
} SECBUS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SUBBUS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x1001001A)                                                     */
/* Register default value:              0x00                                  */
#define SUBBUS_IIO_PCIEIOSF_REG 0x1400101A

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x01a
 */
typedef union {
  struct {
    UINT8 subordinate_bus_number : 8;
    /* subordinate_bus_number - Bits[7:0], RW, default = 8'b00000000 
       This register is programmed by configuration software with the number of the 
       highest subordinate bus that is behind the PCI Express port. Any transaction 
       that falls between the secondary and subordinate bus number (both inclusive) of 
       an Express port is forwarded to the express port. 
     */
  } Bits;
  UINT8 Data;
} SUBBUS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* IOBAS_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x1001001C)                                                     */
/* Register default value:              0xF0                                  */
#define IOBAS_IIO_PCIEIOSF_REG 0x1400101C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x01c
 */
typedef union {
  struct {
    UINT8 i_o_address_capability : 2;
    /* i_o_address_capability - Bits[1:0], RO, default = 2'b00 
       IIO supports only 16 bit addressing
     */
    UINT8 more_i_o_base_address : 2;
    /* more_i_o_base_address - Bits[3:2], RW_L, default = 2'b00 
       When EN1K is set in the IIOMISCCTRL register, these bits become RW and allow for 
       1K granularity of I/O addressing, otherwise these are RO. 
     */
    UINT8 i_o_base_address : 4;
    /* i_o_base_address - Bits[7:4], RW, default = 4'b1111 
       Corresponds to A[15:12] of the I/O base address of the PCI Express port. See 
       also the IOLIM register description. 
     */
  } Bits;
  UINT8 Data;
} IOBAS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* IOLIM_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x1001001D)                                                     */
/* Register default value:              0x00                                  */
#define IOLIM_IIO_PCIEIOSF_REG 0x1400101D

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x01d
 */
typedef union {
  struct {
    UINT8 i_o_address_limit_capability : 2;
    /* i_o_address_limit_capability - Bits[1:0], RO, default = 2'b00 
       IIO only supports 16 bit addressing
     */
    UINT8 more_i_o_address_limit : 2;
    /* more_i_o_address_limit - Bits[3:2], RW_L, default = 2'b00 
       When EN1K is set in the IIOMISCCTRL register, these bits become RW and allow for 
       1K granularity of I/O addressing, otherwise these are RO. 
     */
    UINT8 i_o_address_limit : 4;
    /* i_o_address_limit - Bits[7:4], RW, default = 4'b0000 
       Corresponds to A[15:12] of the I/O limit address of the PCI Express port.The I/O 
       Base and I/O Limit registers define an address range that is used by the PCI 
       Express port to determine when to forward I/O transactions from one interface to 
       the other using the following formula: 
       
       IO_BASE &lt;= A[15:12] &lt;=IO_LIMIT
       
       The bottom of the defined I/O address range will be aligned to a 4KB boundary 
       (1KB if EN1K bit is set. Refer to the IIOMISCCTRL register for definition of 
       EN1K bit) while the top of the region specified by IO_LIMIT will be one less 
       than a 4 KB (1KB if EN1K bit is set) multiple. 
       
       Notes:
       Setting the I/O limit less than I/O base disables the I/O range altogether.
       General the I/O base and limit registers won't be programmed by software without 
       clearing the IOSE bit first. 
     */
  } Bits;
  UINT8 Data;
} IOLIM_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SECSTS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x2001001E)                                                     */
/* Register default value:              0x0000                                */
#define SECSTS_IIO_PCIEIOSF_REG 0x1400201E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x01e
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 pci66_mhz_capability : 1;
    /* pci66_mhz_capability - Bits[5:5], RO, default = 1'b0  */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back_transactions_capable : 1;
    /* fast_back_to_back_transactions_capable - Bits[7:7], RO, default = 1'b0  */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0  */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00  */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0  */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0  */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0  */
    UINT16 rse : 1;
    /* rse - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} SECSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MBAS_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x20010020)                                                     */
/* Register default value:              0xFFF0                                */
#define MBAS_IIO_PCIEIOSF_REG 0x14002020

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x020
 */
typedef union {
  struct {
    UINT16 rsvd : 4;
    /* rsvd - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 memory_base_address : 12;
    /* memory_base_address - Bits[15:4], RW, default = 12'b111111111111 
       Corresponds to A[31:20] of the 32 bit memory window's base address of the PCI 
       Express port. See also the MLIM register description. 
     */
  } Bits;
  UINT16 Data;
} MBAS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MLIM_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x20010022)                                                     */
/* Register default value:              0x0000                                */
#define MLIM_IIO_PCIEIOSF_REG 0x14002022

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x022
 */
typedef union {
  struct {
    UINT16 rsvd : 4;
    /* rsvd - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 memory_limit_address : 12;
    /* memory_limit_address - Bits[15:4], RW, default = 12'b000000000000 
       Corresponds to A[31:20] of the 32 bit memory window's limit address that 
       corresponds to the upper limit of the range of memory accesses that will be 
       passed by the PCI Express bridge.The Memory Base and Memory Limit registers 
       define a memory mapped I/O non-prefetchable address range (32-bit addresses) and 
       the IIO directs accesses in this range to the PCI Express port based on the 
       following formula: 
       MEMORY_BASE &lt;= A[31:20] &lt;= MEMORY_LIMIT
       The upper 12 bits of both the Memory Base and Memory Limit registers are 
       read/write and corresponds to the upper 12 address bits, A[31:20] of 32-bit 
       addresses. Thus, the bottom of the defined memory address range will be aligned 
       to a 1 MB boundary and the top of the defined memory address range will be one 
       less than a 1 MB boundary. 
       Notes:
       Setting the memory limit less than memory base disables the 32-bit memory range 
       altogether. 
       Note that in general the memory base and limit registers won't be programmed by 
       software without clearing the MSE bit first. 
     */
  } Bits;
  UINT16 Data;
} MLIM_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PBAS_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x20010024)                                                     */
/* Register default value:              0xFFF1                                */
#define PBAS_IIO_PCIEIOSF_REG 0x14002024

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x024
 */
typedef union {
  struct {
    UINT16 prefetchable_memory_base_address_capability : 4;
    /* prefetchable_memory_base_address_capability - Bits[3:0], RO, default = 4'b0001 
       IIO sets this bit to 01h to indicate 64bit capability.
     */
    UINT16 prefetchable_memory_base_address : 12;
    /* prefetchable_memory_base_address - Bits[15:4], RW, default = 12'b111111111111 
       Corresponds to A[31:20] of the prefetchable memory address range's base address 
       of the PCI Express port. See also the PLIMU register description. 
     */
  } Bits;
  UINT16 Data;
} PBAS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLIM_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x20010026)                                                     */
/* Register default value:              0x0001                                */
#define PLIM_IIO_PCIEIOSF_REG 0x14002026

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x026
 */
typedef union {
  struct {
    UINT16 prefetchable_memory_limit_address_capability : 4;
    /* prefetchable_memory_limit_address_capability - Bits[3:0], RO, default = 4'b0001 
       IIO sets this field to 01h to indicate 64bit capability.
     */
    UINT16 prefetchable_memory_limit_address : 12;
    /* prefetchable_memory_limit_address - Bits[15:4], RW, default = 12'b000000000000 
       Corresponds to A[31:20] of the prefetchable memory address range's limit address 
       of the PCI Express port. See also the PLIMU register description. 
     */
  } Bits;
  UINT16 Data;
} PLIM_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PBASU_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x40010028)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define PBASU_IIO_PCIEIOSF_REG 0x14004028

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x028
 */
typedef union {
  struct {
    UINT32 prefetchable_upper_32_bit_memory_base_address : 32;
    /* prefetchable_upper_32_bit_memory_base_address - Bits[31:0], RW, default = 32'b11111111111111111111111111111111 
       Corresponds to A[63:32] of the prefetchable memory address range's base address 
       of the PCI Express port. See also the PLIMU register description. 
     */
  } Bits;
  UINT32 Data;
} PBASU_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLIMU_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x4001002C)                                                     */
/* Register default value:              0x00000000                            */
#define PLIMU_IIO_PCIEIOSF_REG 0x1400402C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x02c
 */
typedef union {
  struct {
    UINT32 prefetchable_upper_32_bit_memory_limit_address : 32;
    /* prefetchable_upper_32_bit_memory_limit_address - Bits[31:0], RW, default = 32'b00000000000000000000000000000000 
       Corresponds to A[63:32] of the prefetchable memory address range's limit address 
       of the PCI Express port.The Prefetchable Memory Base and Memory Limit registers 
       define a memory mapped I/O prefetchable address range (64-bit addresses) which 
       is used by the PCI Express bridge to determine when to forward memory 
       transactions based on the following formula: 
       
       PREFETCH_MEMORY_BASE_UPPER PREFETCH_MEMORY_BASE &lt;= A[63:20] &lt;= 
       PREFETCH_MEMORY_LIMIT_UPPERPREFETCH_MEMORY_LIMIT 
       
       The upper 12 bits of both the Prefetchable Memory Base and Memory Limit 
       registers are read/write and corresponds to the upper 12 address bits, A[31:20] 
       of 32-bit addresses. The bottom of the defined memory address range will be 
       aligned to a 1 MB boundary and the top of the defined memory address range will 
       be one less than a 1 MB boundary. 
       
       The bottom 4 bits of both the Prefetchable Memory Base and Prefetchable Memory 
       Limit registers are read-only, contain the same value, and encode whether or not 
       the bridge supports 64-bit addresses. 
       If these four bits have the value 0h, then the bridge supports only 32 bit 
       addresses. 
       If these four bits have the value 1h, then the bridge supports 64-bit addresses 
       and the Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits 
       registers hold the rest of the 64-bit prefetchable base and limit addresses 
       respectively. 
       Setting the prefetchable memory limit less than prefetchable memory base 
       disables the 64-bit prefetchable memory range altogether. 
       
       Notes:
       In general the memory base and limit registers won't be programmed by software 
       without clearing the MSE bit first. 
     */
  } Bits;
  UINT32 Data;
} PLIMU_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CAPPTR_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x10010034)                                                     */
/* Register default value:              0x40                                  */
#define CAPPTR_IIO_PCIEIOSF_REG 0x14001034

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'b01000000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* INTL_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x1001003C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_PCIEIOSF_REG 0x1400103C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RW, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* INTPIN_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x1001003D)                                                     */
/* Register default value:              0x01                                  */
#define INTPIN_IIO_PCIEIOSF_REG 0x1400103D

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x03d
 */
typedef union {
  struct {
    UINT8 intp : 8;
    /* intp - Bits[7:0], RW_O, default = 8'b00000001 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* BCTRL_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x2001003E)                                                     */
/* Register default value:              0x0000                                */
#define BCTRL_IIO_PCIEIOSF_REG 0x1400203E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x03e
 */
typedef union {
  struct {
    UINT16 perre : 1;
    /* perre - Bits[0:0], RW, default = 1'b0  */
    UINT16 serre : 1;
    /* serre - Bits[1:1], RW, default = 1'b0  */
    UINT16 isaen : 1;
    /* isaen - Bits[2:2], RW, default = 1'b0 
       Modifies the response by the root port to an I/O access issued by the core that 
       target ISA I/O addresses. This applies only to I/O addresses that are enabled by 
       the IOBASE and IOLIM registers. 
       
       1: The root port will not forward to PCI Express any I/O transactions addressing 
       the last 768 bytes in each 1KB block even if the addresses are within the range 
       defined by the IOBASE and IOLIM registers. 
       0: All addresses defined by the IOBASE and IOLIM for core issued I/O 
       transactions will be mapped to PCI Express. 
     */
    UINT16 vgaen : 1;
    /* vgaen - Bits[3:3], RW, default = 1'b0 
       Controls the routing of CPU initiated transactions targeting VGA compatible I/O 
       and memory address ranges. This bit must only be set for one p2p port in the 
       entire system. 
       
       Notes:
       When Device 3 Function 0 is in NTB mode, then the Device 3 Function 0 versoin of 
       this bit must be left at default value. VGA compatible devices are not supported 
       on the secondary side of the NTB. 
     */
    UINT16 vga16b : 1;
    /* vga16b - Bits[4:4], RW, default = 1'b0 
       This bit enables the virtual PCI-to-PCI bridge to provide 16-bit decoding of VGA 
       I/O address precluding the decoding of alias addresses every 1 KB. 
       
       0: execute 10-bit address decodes on VGA I/O accesses.
       1: execute 16-bit address decodes on VGA I/O accesses.
       
       Notes:
       This bit only has meaning if bit 3 of this register is also set to 1, enabling 
       VGA I/O decoding and forwarding by the bridge. 
       Refer to PCI-PCI Bridge Specification Revision 1.2 for further details of this 
       bit behavior. 
     */
    UINT16 rsvd_5 : 1;
    /* rsvd_5 - Bits[5:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 sbr : 1;
    /* sbr - Bits[6:6], RW, default = 1'b0  */
    UINT16 rsvd_7 : 9;
    /* rsvd_7 - Bits[15:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} BCTRL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SCAPID_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x10010040)                                                     */
/* Register default value:              0x0D                                  */
#define SCAPID_IIO_PCIEIOSF_REG 0x14001040

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x040
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00001101 
       Assigned by PCI-SIG for subsystem capability ID
     */
  } Bits;
  UINT8 Data;
} SCAPID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SNXTPTR_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x10010041)                                                     */
/* Register default value:              0x60                                  */
#define SNXTPTR_IIO_PCIEIOSF_REG 0x14001041

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x041
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b01100000 
       This field is set to 60h for the next capability list (MSI capability structure) 
       in the chain. 
     */
  } Bits;
  UINT8 Data;
} SNXTPTR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SVID_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x20010044)                                                     */
/* Register default value:              0x8086                                */
#define SVID_IIO_PCIEIOSF_REG 0x14002044

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x044
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_id : 16;
    /* subsystem_vendor_id - Bits[15:0], RW_O, default = 16'b1000000010000110  */
  } Bits;
  UINT16 Data;
} SVID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SDID_IIO_PCIEIOSF_REG supported on:                                        */
/*       BDX (0x20010046)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_PCIEIOSF_REG 0x14002046

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x046
 */
typedef union {
  struct {
    UINT16 subsystem_device_id : 16;
    /* subsystem_device_id - Bits[15:0], RW_O, default = 16'b0000000000000000  */
  } Bits;
  UINT16 Data;
} SDID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSICAPID_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x10010060)                                                     */
/* Register default value:              0x05                                  */
#define MSICAPID_IIO_PCIEIOSF_REG 0x14001060

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x060
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000101 
       Assigned by PCI-SIG for MSI (root ports).
     */
  } Bits;
  UINT8 Data;
} MSICAPID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSINXTPTR_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x10010061)                                                     */
/* Register default value:              0x90                                  */
#define MSINXTPTR_IIO_PCIEIOSF_REG 0x14001061

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x061
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RW_O, default = 8'b10010000 
       This field is set to 90h for the next capability list (PCI Express capability 
       structure) in the chain. 
     */
  } Bits;
  UINT8 Data;
} MSINXTPTR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSIMSGCTL_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x20010062)                                                     */
/* Register default value:              0x0102                                */
#define MSIMSGCTL_IIO_PCIEIOSF_REG 0x14002062

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x062
 */
typedef union {
  struct {
    UINT16 msien : 1;
    /* msien - Bits[0:0], RW, default = 1'b0 
       Software sets this bit to select INTx style interrupt or MSI interrupt for root 
       port generated interrupts. 
       
       0: INTx interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       1: MSI interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       Note there bits 4:2 and bit 2 MISCCTRLSTS can disable both MSI and INTx 
       interrupt from being generated on root port interrupt events. 
     */
    UINT16 mmc : 3;
    /* mmc - Bits[3:1], RO, default = 3'b001  */
    UINT16 mme : 3;
    /* mme - Bits[6:4], RW, default = 3'b000 
       Applicable only to PCI Express ports. Software writes to this field to indicate 
       the number of allocated messages which is aligned to a power of two. When MSI is 
       enabled, the software will allocate at least one message to the device. A value 
       of 000 indicates 1 message. Any value greater than or equal to 001 indicates a 
       message of 2. 
       
       See MSIDR for discussion on how the interrupts are distributed amongst the 
       various sources of interrupt based on the number of messages allocated by 
       software for the PCI Express ports. 
     */
    UINT16 b64ac : 1;
    /* b64ac - Bits[7:7], RO, default = 1'b0 
       This field is hardwired to 0h since the message addresses are only 32-bit 
       addresses (e.g. FEEx_xxxxh). 
     */
    UINT16 pvmc : 1;
    /* pvmc - Bits[8:8], RO, default = 1'b1 
       This bit indicates that PCI Express ports support MSI per-vector masking.
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} MSIMSGCTL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSGADR_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x40010064)                                                     */
/* Register default value:              0x00000000                            */
#define MSGADR_IIO_PCIEIOSF_REG 0x14004064

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * The MSI Address Register (MSIAR) contains the system specific address 
 * information to route MSI interrupts from the root ports and is broken into its 
 * constituent fields. 
 */
typedef union {
  struct {
    UINT32 rsvd : 2;
    /* rsvd - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 address_id : 30;
    /* address_id - Bits[31:2], RW, default = 30'b000000000000000000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
  } Bits;
  UINT32 Data;
} MSGADR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSGDAT_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x40010068)                                                     */
/* Register default value:              0x00000000                            */
#define MSGDAT_IIO_PCIEIOSF_REG 0x14004068

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x068
 */
typedef union {
  struct {
    UINT32 data : 16;
    /* data - Bits[15:0], RW, default = 16'b0000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSGDAT_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSIMSK_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x4001006C)                                                     */
/* Register default value:              0x00000000                            */
#define MSIMSK_IIO_PCIEIOSF_REG 0x1400406C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x06c
 */
typedef union {
  struct {
    UINT32 mask_bits : 2;
    /* mask_bits - Bits[1:0], RW, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. For each Mask bit that is set, the PCI Express port is prohibited from 
       sending the associated message. When only one message is allocated to the root 
       port by software, only mask bit 0 is relevant and used by hardware. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSIPENDING_IIO_PCIEIOSF_REG supported on:                                  */
/*       BDX (0x40010070)                                                     */
/* Register default value:              0x00000000                            */
#define MSIPENDING_IIO_PCIEIOSF_REG 0x14004070

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x070
 */
typedef union {
  struct {
    UINT32 pending_bits : 2;
    /* pending_bits - Bits[1:0], RO_V, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. When MSI is not enabled or used by the root port, this register always 
       reads a value 0. For each Pending bit that is set, the PCI Express port has a 
       pending associated message. When only one message is allocated to the root port 
       by software, only pending bit 0 is set/cleared by hardware and pending bit 1 
       always reads 0. 
       Hardware sets this bit whenever it has an interrupt pending to be sent. This bit 
       remains set till either the interrupt is sent by hardware or the status bits 
       associated with the interrupt condition are cleared by software. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIPENDING_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PXPCAPID_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x10010090)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_PCIEIOSF_REG 0x14001090

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x090
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PXPNXTPTR_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x10010091)                                                     */
/* Register default value:              0xE0                                  */
#define PXPNXTPTR_IIO_PCIEIOSF_REG 0x14001091

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x091
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b11100000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PXPCAP_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x20010092)                                                     */
/* Register default value:              0x0042                                */
#define PXPCAP_IIO_PCIEIOSF_REG 0x14002092

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x092
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RW_O, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure, which 
       is 2h as of now. This register field is left as RW-O to cover any unknowns with 
       Gen3. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO_V, default = 4'b0100 
       This field identifies the type of device. It is set to 0100 for all the Express 
       ports. 
     */
    UINT16 slot_implemented : 1;
    /* slot_implemented - Bits[8:8], RW_O, default = 1'b0 
       Applies only to the root ports.
       1: indicates that the PCI Express link associated with the port is connected to 
       a slot. 
       0: indicates no slot is connected to this port.
       
       Notes:
       This register bit is of type 'write once' and is set by BIOS.
     */
    UINT16 interrupt_message_number : 5;
    /* interrupt_message_number - Bits[13:9], RO, default = 5'b00000 
       Applies to root ports. This field indicates the interrupt message number that is 
       generated for Power Management/Hot Plug/Bandwidth-change events. When there are 
       more than one MSI interrupt Number allocated for the root port MSI interrupts, 
       this register field is required to contain the offset between the base Message 
       Data and the MSI Message that is generated when there are these change 
       interrupts. IIO assigns the first vector for these change events and so this 
       field is set to 0. 
     */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCAP_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x40010094)                                                     */
/* Register default value:              0x00008001                            */
#define DEVCAP_IIO_PCIEIOSF_REG 0x14004094

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * The PCI Express Device Capabilities register identifies device specific 
 * information for the device. 
 */
typedef union {
  struct {
    UINT32 max_payload_size_supported : 3;
    /* max_payload_size_supported - Bits[2:0], RO, default = 3'b001 
       1
     */
    UINT32 phantom_functions_supported : 2;
    /* phantom_functions_supported - Bits[4:3], RO, default = 2'b00 
       CB DMA does not support phantom functions.
     */
    UINT32 extended_tag_field_supported : 1;
    /* extended_tag_field_supported - Bits[5:5], RW_O, default = 1'b0  */
    UINT32 endpoint_l0s_acceptable_latency : 3;
    /* endpoint_l0s_acceptable_latency - Bits[8:6], RO, default = 3'b000 
       N/A
     */
    UINT32 endpoint_l1_acceptable_latency : 3;
    /* endpoint_l1_acceptable_latency - Bits[11:9], RO, default = 3'b000 
       N/A
     */
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[12:12], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[13:13], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 power_indicator_present_on_device : 1;
    /* power_indicator_present_on_device - Bits[14:14], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 role_based_error_reporting : 1;
    /* role_based_error_reporting - Bits[15:15], RO, default = 1'b1 
       IIO is 1.1 compliant and so supports this feature
     */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 captured_slot_power_limit_value : 8;
    /* captured_slot_power_limit_value - Bits[25:18], RO, default = 8'b00000000 
       Does not apply to CB DMA
     */
    UINT32 captured_slot_power_limit_scale : 2;
    /* captured_slot_power_limit_scale - Bits[27:26], RO, default = 2'b00 
       Does not apply to CB DMA
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCTRL_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x20010098)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL_IIO_PCIEIOSF_REG 0x14002098

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x098
 */
typedef union {
  struct {
    UINT16 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0  */
    UINT16 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0  */
    UINT16 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0  */
    UINT16 unsupported_request_reporting_enable : 1;
    /* unsupported_request_reporting_enable - Bits[3:3], RW, default = 1'b0  */
    UINT16 enable_relaxed_ordering : 1;
    /* enable_relaxed_ordering - Bits[4:4], RO, default = 1'b0  */
    UINT16 max_payload_size : 3;
    /* max_payload_size - Bits[7:5], RW_LV, default = 3'b000  */
    UINT16 extended_tag_field_enable : 1;
    /* extended_tag_field_enable - Bits[8:8], RW, default = 1'b0  */
    UINT16 phantom_functions_enable : 1;
    /* phantom_functions_enable - Bits[9:9], RO, default = 1'b0  */
    UINT16 auxiliary_power_management_enable : 1;
    /* auxiliary_power_management_enable - Bits[10:10], RO, default = 1'b0  */
    UINT16 enable_no_snoop : 1;
    /* enable_no_snoop - Bits[11:11], RO, default = 1'b0  */
    UINT16 max_read_request_size : 3;
    /* max_read_request_size - Bits[14:12], RO, default = 3'b000  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVSTS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x2001009A)                                                     */
/* Register default value:              0x0000                                */
#define DEVSTS_IIO_PCIEIOSF_REG 0x1400209A

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x09a
 */
typedef union {
  struct {
    UINT16 correctable_error_detected : 1;
    /* correctable_error_detected - Bits[0:0], RW1C, default = 1'b0  */
    UINT16 non_fatal_error_detected : 1;
    /* non_fatal_error_detected - Bits[1:1], RW1C, default = 1'b0  */
    UINT16 fatal_error_detected : 1;
    /* fatal_error_detected - Bits[2:2], RW1C, default = 1'b0  */
    UINT16 unsupported_request_detected : 1;
    /* unsupported_request_detected - Bits[3:3], RW1C, default = 1'b0  */
    UINT16 aux_power_detected : 1;
    /* aux_power_detected - Bits[4:4], RO, default = 1'b0  */
    UINT16 transactions_pending : 1;
    /* transactions_pending - Bits[5:5], RO, default = 1'b0  */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCAP_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x4001009C)                                                     */
/* Register default value:              0x00100011                            */
#define LNKCAP_IIO_PCIEIOSF_REG 0x1400409C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * The Link Capabilities register identifies the PCI Express specific link 
 * capabilities. The link capabilities register needs some default values setup by 
 * the local host. This register is relocated to the enhanced configuration space 
 * region in while in NTB mode. 
 */
typedef union {
  struct {
    UINT32 maxlnkspd : 4;
    /* maxlnkspd - Bits[3:0], RW_O, default = 4'b0001 
       This field indicates the maximum link speed of this Port.
       The encoding is the binary value of the bit location in the Supported Link 
       Speeds Vector (in LNKCAP2) that corresponds to the maximum link speed. 
       0010b = (5Gbps)
       0011b = (8Gbps)
     */
    UINT32 maximum_link_width : 6;
    /* maximum_link_width - Bits[9:4], RW_O, default = 6'b000001 
       This field indicates the maximum width of the given PCI Express Link attached to 
       the port. 
       000001: x1
       000010: x2
       000100: x4
       001000: x8
       010000: x16
       Others: Reserved
       
       This is left as a RW-O register for bios to update based on the platform usage 
       of the links. 
     */
    UINT32 active_state_link_pm_support : 2;
    /* active_state_link_pm_support - Bits[11:10], RW_O, default = 2'b00 
       This field indicates the level of active state power management supported on the 
       given PCI-Express port. 
       00: Disabled
       01: L0s Entry Supported
       10: L1 Entry Supported (Gen3; spec allows 0x2)
       11: L0s and L1 Supported
       L0s is not supported on the processor.
     */
    UINT32 l0s_exit_latency : 3;
    /* l0s_exit_latency - Bits[14:12], RW_O, default = 3'b000 
       This field indicates the L0s exit latency (i.e L0s to L0) for the PCI-Express 
       port. 
       L0s is not supported on the processor.
     */
    UINT32 l1_exit_latency : 3;
    /* l1_exit_latency - Bits[17:15], RW_O, default = 3'b000 
       This field indicates the L1 exit latency for the given PCI-Express port. It 
       indicates the length of time this port requires to complete transition from L1 
       to L0. 
       000: Less than 1us
       001: 1 us to less than 2 us
       010: 2 us to less than 4 us
       011: 4 us to less than 8 us
       100: 8 us to less than 16 us
       101: 16 us to less than 32 us
       110: 32 us to 64 us
       111: More than 64us
       
       This register is made writable once by BIOS so that the value is settable based 
       on experiments post-si. 
     */
    UINT32 clock_power_management : 1;
    /* clock_power_management - Bits[18:18], RW_O, default = 1'b0 
       Does not apply to processor
     */
    UINT32 surprise_down_error_reporting_capable : 1;
    /* surprise_down_error_reporting_capable - Bits[19:19], RW_O, default = 1'b0 
       IIO supports reporting a surprise down error condition
     */
    UINT32 data_link_layer_link_active_reporting_capable : 1;
    /* data_link_layer_link_active_reporting_capable - Bits[20:20], RW_O, default = 1'b1 
       IIO supports reporting status of the data link layer so software knows when it 
       can enumerate a device on the link or otherwise know the status of the link. 
     */
    UINT32 link_bandwidth_notification_capability : 1;
    /* link_bandwidth_notification_capability - Bits[21:21], RW_O, default = 1'b0 
       A value of 1b indicates support for the Link Bandwidth Notification status and 
       interrupt mechanisms. 
     */
    UINT32 aspm_optionality_compliance : 1;
    /* aspm_optionality_compliance - Bits[22:22], RW_O, default = 1'b0  */
    UINT32 rsvd : 1;
    /* rsvd - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 port_number : 8;
    /* port_number - Bits[31:24], RW_O, default = 8'b00000000 
       This field indicates the PCI Express port number for the link and is initialized 
       by software/BIOS. IIO hardware does nothing with this bit. 
     */
  } Bits;
  UINT32 Data;
} LNKCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCON_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x200100A0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON_IIO_PCIEIOSF_REG 0x140020A0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0a0
 */
typedef union {
  struct {
    UINT16 active_state_link_pm_control : 2;
    /* active_state_link_pm_control - Bits[1:0], RW_V, default = 2'b00  */
    UINT16 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 read_completion_boundary : 1;
    /* read_completion_boundary - Bits[3:3], RO, default = 1'b0  */
    UINT16 link_disable : 1;
    /* link_disable - Bits[4:4], RW, default = 1'b0  */
    UINT16 rsvd_5 : 1;
    /* rsvd_5 - Bits[5:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 common_clock_configuration : 1;
    /* common_clock_configuration - Bits[6:6], RW, default = 1'b0  */
    UINT16 extended_synch : 1;
    /* extended_synch - Bits[7:7], RW, default = 1'b0  */
    UINT16 enable_clock_power_management : 1;
    /* enable_clock_power_management - Bits[8:8], RO, default = 1'b0  */
    UINT16 hardware_autonomous_width_disable : 1;
    /* hardware_autonomous_width_disable - Bits[9:9], RW, default = 1'b0  */
    UINT16 link_bandwidth_management_interrupt_enable : 1;
    /* link_bandwidth_management_interrupt_enable - Bits[10:10], RW, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_interrupt_enable : 1;
    /* link_autonomous_bandwidth_interrupt_enable - Bits[11:11], RW, default = 1'b0  */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKCON_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKSTS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x200100A2)                                                     */
/* Register default value:              0x1011                                */
#define LNKSTS_IIO_PCIEIOSF_REG 0x140020A2

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0a2
 */
typedef union {
  struct {
    UINT16 current_link_speed : 4;
    /* current_link_speed - Bits[3:0], RO_V, default = 4'b0001  */
    UINT16 negotiated_link_width : 6;
    /* negotiated_link_width - Bits[9:4], RO_V, default = 6'b000001  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 link_training : 1;
    /* link_training - Bits[11:11], RO_V, default = 1'b0  */
    UINT16 slot_clock_configuration : 1;
    /* slot_clock_configuration - Bits[12:12], RW_O, default = 1'b1  */
    UINT16 data_link_layer_link_active : 1;
    /* data_link_layer_link_active - Bits[13:13], RO_V, default = 1'b0  */
    UINT16 link_bandwidth_management_status : 1;
    /* link_bandwidth_management_status - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_status : 1;
    /* link_autonomous_bandwidth_status - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} LNKSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SLTCAP_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x400100A4)                                                     */
/* Register default value:              0x00000000                            */
#define SLTCAP_IIO_PCIEIOSF_REG 0x140040A4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0a4
 */
typedef union {
  struct {
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[0:0], RW_O, default = 1'b0 
       This bit indicates that the Attention Button event signal is routed (from slot 
       or on-board in the chassis) to the IIO's hotplug controller. 
       0: indicates that an Attention Button signal is routed to IIO
       1: indicates that an Attention Button is not routed to IIO
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_controller_present : 1;
    /* power_controller_present - Bits[1:1], RW_O, default = 1'b0 
       This bit indicates that a software controllable power controller is implemented 
       on the chassis for this slot. 
       0: indicates that a software controllable power controller is not present
       1: indicates that a software controllable power controller is present
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 mrl_sensor_present : 1;
    /* mrl_sensor_present - Bits[2:2], RW_O, default = 1'b0 
       This bit indicates that an MRL Sensor is implemented on the chassis for this 
       slot. 
       0: indicates that an MRL Sensor is not present
       1: indicates that an MRL Sensor is present
       BIOS programs this field with a 0 for Express Module FF always. If CEM slot is 
       hotplug capable, BIOS programs this field with either 0 or 1 depending on system 
       design. 
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[3:3], RW_O, default = 1'b0 
       This bit indicates that an Attention Indicator is implemented for this slot and 
       is electrically controlled by the chassis 
       0: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_indicator_present : 1;
    /* power_indicator_present - Bits[4:4], RW_O, default = 1'b0 
       This bit indicates that a Power Indicator is implemented for this slot and is 
       electrically controlled by the chassis. 
       0: indicates that a Power Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that Power Indicator that is electrically controlled by the chassis 
       is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 hot_plug_surprise : 1;
    /* hot_plug_surprise - Bits[5:5], RW_O, default = 1'b0 
       This field indicates that a device in this slot may be removed from the system 
       without prior notification. This field is initialized by BIOS. 
       0: indicates that hot-plug surprise is not supported
       1: indicates that hot-plug surprise is supported
       Generally this bit is not expected to be set because the only know usage case 
       for this is the ExpressCard FF. But that is not really expected usage in the 
       processor context. But this bit is present regardless to allow a usage if it 
       arises. 
       This bit is used by IIO hardware to determine if a transition from DL_active to 
       DL_Inactive is to be treated as a surprise down error or not. If a port is 
       associated with a hotpluggable slot and the hotplug surprise bit is set, then 
       any transition to DL_Inactive is not considered an error. Refer to PCI Express 
       Base Specification, Revision 2.0 for further details. 
     */
    UINT32 hot_plug_capable : 1;
    /* hot_plug_capable - Bits[6:6], RW_O, default = 1'b0 
       This field defines hot-plug support capabilities for the PCI Express port.
       0: indicates that this slot is not capable of supporting Hot-plug operations.
       1: indicates that this slot is capable of supporting Hot-plug operations
       This bit is programed by BIOS based on the system design. This bit must be 
       programmed by bios to be consistent with the VPP enable bit for the port. 
     */
    UINT32 slot_power_limit_value : 8;
    /* slot_power_limit_value - Bits[14:7], RW_O, default = 8'b00000000  */
    UINT32 slot_power_limit_scale : 2;
    /* slot_power_limit_scale - Bits[16:15], RW_O, default = 2'b00  */
    UINT32 electromechanical_interlock_present : 1;
    /* electromechanical_interlock_present - Bits[17:17], RW_O, default = 1'b0 
       This bit when set indicates that an Electromechanical Interlock is implemented 
       on the chassis for this slot and that lock is controlled by bit 11 in Slot 
       Control register. This field is initialized by BIOS based on the system 
       architecture. 
       BIOS note: this capability is not set if the Electromechanical Interlock control 
       is connected to main slot power control. 
       This is expected to be used only for Express Module hotpluggable slots.
     */
    UINT32 command_complete_not_capable : 1;
    /* command_complete_not_capable - Bits[18:18], RO, default = 1'b0 
       The processor is capable of command complete interrupt.
     */
    UINT32 physical_slot_number : 13;
    /* physical_slot_number - Bits[31:19], RW_O, default = 13'b0000000000000 
       This field indicates the physical slot number of the slot connected to the PCI 
       Express port and is initialized by BIOS. 
     */
  } Bits;
  UINT32 Data;
} SLTCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SLTCON_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x200100A8)                                                     */
/* Register default value:              0x07C0                                */
#define SLTCON_IIO_PCIEIOSF_REG 0x140020A8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Any write to this register will set the Command Completed bit in the SLTSTS 
 * register, ONLY if the VPP enable bit for the port is set. If the port's VPP 
 * enable bit is set (i.e. hotplug for that slot is enabled), then the required 
 * actions on VPP are completed before the Command Completed bit is set in the 
 * SLTSTS register. If the VPP enable bit for the port is clear, then the write 
 * simply updates this register (see individual bit definitions for details) but 
 * the Command Completed bit in the SLTSTS register is not set 
 */
typedef union {
  struct {
    UINT16 attention_button_pressed_enable : 1;
    /* attention_button_pressed_enable - Bits[0:0], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via an 
       attention button pressed event. 
       0: disables generation of hot-plug interrupts or wake messages when the 
       attention button is pressed. 
       1: Enables generation of hot-plug interrupts or wake messages when the attention 
       button is pressed. 
     */
    UINT16 power_fault_detected_enable : 1;
    /* power_fault_detected_enable - Bits[1:1], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       power fault event. 
       0: disables generation of hot-plug interrupts or wake messages when a power 
       fault event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when a power fault 
       event happens. 
     */
    UINT16 mrl_sensor_changed_enable : 1;
    /* mrl_sensor_changed_enable - Bits[2:2], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       MRL Sensor changed event. 
       0: disables generation of hot-plug interrupts or wake messages when an MRL 
       Sensor changed event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when an MRL Sensor 
       changed event happens. 
     */
    UINT16 presence_detect_changed_enable : 1;
    /* presence_detect_changed_enable - Bits[3:3], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       presence detect changed event. 
       0: disables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
       1- Enables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
     */
    UINT16 command_completed_interrupt_enable : 1;
    /* command_completed_interrupt_enable - Bits[4:4], RW, default = 1'b0 
       This field enables software notification (Interrupt - MSI/INTx or WAKE) when a 
       command is completed by the Hot-plug controller connected to the PCI Express 
       port 
       0: disables hot-plug interrupts on a command completion by a hot-plug Controller
       1: Enables hot-plug interrupts on a command completion by a hot-plug Controller
     */
    UINT16 hot_plug_interrupt_enable : 1;
    /* hot_plug_interrupt_enable - Bits[5:5], RW, default = 1'b0 
       When set to 1b, this bit enables generation of Hot-Plug interrupt (MSI or INTx 
       interrupt depending on the setting of the MSI enable bit on enabled Hot-Plug 
       events, provided ACPI mode for hotplug is disabled. 
       0: disables interrupt generation on Hot-plug events
       1: enables interrupt generation on Hot-plug events
     */
    UINT16 attention_indicator_control : 2;
    /* attention_indicator_control - Bits[7:6], RW, default = 2'b11 
       If an Attention Indicator is implemented, writes to this field will set the 
       Attention Indicator to the written state. Reads of this field reflect the value 
       from the latest write, even if the corresponding hot-plug command is not 
       executed yet at the VPP, unless software issues a write without waiting for the 
       previous command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (Processor drives 1 Hz square wave)
       11: Off
       IIO does not generated the Attention_Indicator_On/Off/Blink messages on PCI 
       Express when this field is written to by software. 
     */
    UINT16 power_indicator_control : 2;
    /* power_indicator_control - Bits[9:8], RW, default = 2'b11 
       If a Power Indicator is implemented, writes to this field will set the Power 
       Indicator to the written state. Reads of this field must reflect the value from 
       the latest write, even if the corresponding hot-plug command is not executed yet 
       at the VPP, unless software issues a write without waiting for the previous 
       command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (IIO drives 1 Hz square wave for Chassis mounted LEDs)
       11: Off
       IIO does not generated the Power_Indicator_On/Off/Blink messages on PCI Express 
       when this field is written to by software. 
     */
    UINT16 power_controller_control : 1;
    /* power_controller_control - Bits[10:10], RWS, default = 1'b1 
       If a power controller is implemented, when writes to this field will set the 
       power state of the slot per the defined encodings. Reads of this field must 
       reflect the value from the latest write, even if the corresponding hot-plug 
       command is not executed yet at the VPP, unless software issues a write without 
       waiting for the previous command to complete in which case the read value is 
       undefined. 
       0: Power On
       1: Power Off
       Note: If the link experiences an unexpected DL_Down condition that is not the 
       result of a Hot Plug removal, the processor follows the PCI Express 
       specification for logging Surprise Link Down. SW is required to set SLTCON[10] 
       to 0 (Power On) in all devices that do not connect to a slot that supports 
       Hot-Plug to enable logging of this error in that device. 
       For devices connected to slots supporting Hot-Plug operations, SLTCON[10] usage 
       to control PWREN# assertion is as described elsewhere. 
     */
    UINT16 electromechanical_interlock_control : 1;
    /* electromechanical_interlock_control - Bits[11:11], RW, default = 1'b0 
       When software writes either a 1 to this bit, IIO pulses the EMIL pin per PCI 
       Express Server/Workstation Module Electromechanical Spec Rev 1.0. Write of 0 has 
       no effect. This bit always returns a 0 when read. If electromechanical lock is 
       not implemented, then either a write of 1 or 0 to this register has no effect. 
     */
    UINT16 data_link_layer_state_changed_enable : 1;
    /* data_link_layer_state_changed_enable - Bits[12:12], RWS, default = 1'b0 
       When set to 1, this field enables software notification when Data Link Layer 
       Link Active bit in the LNKSTS register changes state 
     */
    UINT16 rsvd : 3;
    /* rsvd - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTCON_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SLTSTS_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x200100AA)                                                     */
/* Register default value:              0x0000                                */
#define SLTSTS_IIO_PCIEIOSF_REG 0x140020AA

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0aa
 */
typedef union {
  struct {
    UINT16 attention_button_pressed : 1;
    /* attention_button_pressed - Bits[0:0], RW1C, default = 1'b0 
       This bit is set by IIO when the attention button is pressed. It is subsequently 
       cleared by software after the field has been read and processed.Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
       IIO silently discards the Attention_Button_Pressed message if received from PCI 
       Express link without updating this bit. 
     */
    UINT16 power_fault_detected : 1;
    /* power_fault_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit is set by IIO when a power fault event is detected by the power 
       controller (which is reported via the VPP bit stream). It is subsequently 
       cleared by software after the field has been read and processed. Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
     */
    UINT16 mrl_sensor_changed : 1;
    /* mrl_sensor_changed - Bits[2:2], RW1C, default = 1'b0 
       This bit is set if the value reported in bit 5 changes. It is subsequently 
       cleared by software after the field has been read and processed. 
     */
    UINT16 presence_detect_changed : 1;
    /* presence_detect_changed - Bits[3:3], RW1C, default = 1'b0 
       This bit is set by IIO when the value reported in bit 6 is changes. It is 
       subsequently cleared by software after the field has been read and processed. 
     */
    UINT16 command_completed : 1;
    /* command_completed - Bits[4:4], RW1C, default = 1'b0 
       This bit is set by IIO when the hot-plug command has completed and the hot-plug 
       controller is ready to accept a subsequent command. It is subsequently cleared 
       by software after the field has been read and processed. This bit provides no 
       guarantee that the action corresponding to the command is complete. Any write to 
       SLTCON (regardless of the port is capable or enabled for hot-plug) is considered 
       a 'hot-plug' command. 
       If the port is not hot-plug capable or hot-plug enabled, then the hot-plug 
       command does not trigger any action on the VPP port but the command is still 
       completed via this bit. 
     */
    UINT16 mrl_sensor_state : 1;
    /* mrl_sensor_state - Bits[5:5], RO_V, default = 1'b0 
       This bit reports the status of an MRL sensor if it is implemented.
       0: MRL Closed
       1: MRL Open
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 presence_detect_state : 1;
    /* presence_detect_state - Bits[6:6], RO_V, default = 1'b0 
       For ports with slots (where the Slot Implemented bit of the PCI Express 
       Capabilities Registers is 1b), this field is the logical OR of the Presence 
       Detect status determined via an in-band mechanism and sideband Present Detect 
       pins. Refer to how PCI Express Base Specification, Revision 2.0 for how the 
       inband presence detect mechanism works (certain states in the LTSSM constitute 
       'card present' and others don't). 
       0: Card/Module slot empty
       1: Card/module Present in slot (powered or unpowered)
       For ports with no slots, IIO hardwires this bit to 1b.
       Note: OS could get confused when it sees an empty PCI Express root port i.e. 'no 
       slots + no presence', since this is now disallowed in the spec. So bios must 
       hide all unused root ports devices in IIO config space, via the DEVHIDE 
       register. 
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 electromechanical_latch_status : 1;
    /* electromechanical_latch_status - Bits[7:7], RO_V, default = 1'b0 
       When read this register returns the current state of the Electromechanical 
       Interlock (the EMILS pin) which has the defined encodings as: 
       0: Electromechanical Interlock Disengaged
       1: Electromechanical Interlock Engaged
     */
    UINT16 data_link_layer_state_changed : 1;
    /* data_link_layer_state_changed - Bits[8:8], RW1C, default = 1'b0 
       This bit is set (if it is not already set) when the state of the Data Link Layer 
       Link Active bit in the Link Status register changes. Software must read Data 
       Link Layer Active field to determine the link state before initiating 
       configuration cycles to the hot plugged device. 
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ROOTCON_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x200100AC)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCON_IIO_PCIEIOSF_REG 0x140020AC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0ac
 */
typedef union {
  struct {
    UINT16 seceen : 1;
    /* seceen - Bits[0:0], RW, default = 1'b0  */
    UINT16 senfeen : 1;
    /* senfeen - Bits[1:1], RW, default = 1'b0  */
    UINT16 sefeen : 1;
    /* sefeen - Bits[2:2], RW, default = 1'b0  */
    UINT16 pmeinten : 1;
    /* pmeinten - Bits[3:3], RW, default = 1'b0 
       This field controls the generation of MSI interrupts/INTx interrupts for PME 
       messages. 
       
       1: Enables interrupt generation upon receipt of a PME message
       0: Disables interrupt generation for PME messages
     */
    UINT16 crsswvisen : 1;
    /* crsswvisen - Bits[4:4], RW, default = 1'b0  */
    UINT16 rsvd : 11;
    /* rsvd - Bits[15:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCON_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ROOTCAP_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x200100AE)                                                     */
/* Register default value:              0x0001                                */
#define ROOTCAP_IIO_PCIEIOSF_REG 0x140020AE

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0ae
 */
typedef union {
  struct {
    UINT16 crs_software_visibility : 1;
    /* crs_software_visibility - Bits[0:0], RO, default = 1'b1 
       This bit, when set, indicates that the Root Port is capable of returning 
       Configuration Request Retry Status (CRS) Completion Status to software. The 
       processor supports this capability. 
     */
    UINT16 rsvd : 15;
    /* rsvd - Bits[15:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ROOTSTS_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x400100B0)                                                     */
/* Register default value:              0x00000000                            */
#define ROOTSTS_IIO_PCIEIOSF_REG 0x140040B0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0b0
 */
typedef union {
  struct {
    UINT32 pme_requester_id : 16;
    /* pme_requester_id - Bits[15:0], RO_V, default = 16'b0000000000000000 
       This field indicates the PCI requester ID of the last PME requestor. If the root 
       port itself was the source of the (virtual) PME message, then a RequesterID of 
       CPUBUSNO0:DevNo:FunctionNo is logged in this field. 
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[16:16], RW1C, default = 1'b0 
       This field indicates a PM_PME message (either from the link or internally from 
       within that root port) was received at the port.1: PME was asserted by a 
       requester as indicated by the PME Requester ID field 
       This bit is cleared by software by writing a '1'. Note that the root port itself 
       could be the source of a PME event when a hotplug event is observed when the 
       port is in D3hot state. 
     */
    UINT32 pme_pending : 1;
    /* pme_pending - Bits[17:17], RO_V, default = 1'b0 
       This field indicates that another PME is pending when the PME Status bit is set. 
       When the PME Status bit is cleared by software; the pending PME is delivered by 
       hardware by setting the PME Status bit again and updating the Requestor ID 
       appropriately. The PME pending bit is cleared by hardware if no more PMEs are 
       pending. 
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ROOTSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCAP2_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x400100B4)                                                     */
/* Register default value:              0x000013BE                            */
#define DEVCAP2_IIO_PCIEIOSF_REG 0x140040B4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0b4
 */
typedef union {
  struct {
    UINT32 cmpltovalsup : 4;
    /* cmpltovalsup - Bits[3:0], RO, default = 4'b1110  */
    UINT32 cmpltodissup : 1;
    /* cmpltodissup - Bits[4:4], RO, default = 1'b1  */
    UINT32 ari_en : 1;
    /* ari_en - Bits[5:5], RW_LB, default = 1'b1 
       1
     */
    UINT32 atomicroutsup : 1;
    /* atomicroutsup - Bits[6:6], RO, default = 1'b0  */
    UINT32 atomic32bcompsup : 1;
    /* atomic32bcompsup - Bits[7:7], RO, default = 1'b1  */
    UINT32 atomic64bcompsup : 1;
    /* atomic64bcompsup - Bits[8:8], RO, default = 1'b1  */
    UINT32 atomic128bcascompsup : 1;
    /* atomic128bcascompsup - Bits[9:9], RO, default = 1'b1  */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ltr_en : 1;
    /* ltr_en - Bits[11:11], RW_LB, default = 1'b0  */
    UINT32 tph_completer_supported : 2;
    /* tph_completer_supported - Bits[13:12], RW_LB, default = 2'b01 
       1
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCTRL2_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x200100B8)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL2_IIO_PCIEIOSF_REG 0x140020B8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0b8
 */
typedef union {
  struct {
    UINT16 compltoval : 4;
    /* compltoval - Bits[3:0], RW_V, default = 4'b0000  */
    UINT16 compltodis : 1;
    /* compltodis - Bits[4:4], RW_V, default = 1'b0  */
    UINT16 ari : 1;
    /* ari - Bits[5:5], RW_L, default = 1'b0 
       Alternative RID InterpretationEnable
       Applies only to root ports. When set to 1b, ARI is enabled for the Root Port. 
       For Device#0 in DMI mode, this bit is ignored. 
     */
    UINT16 atomicreqen : 1;
    /* atomicreqen - Bits[6:6], RO, default = 1'b0  */
    UINT16 atomicegressblock : 1;
    /* atomicegressblock - Bits[7:7], RO, default = 1'b0  */
    UINT16 rsvd_8 : 2;
    /* rsvd_8 - Bits[9:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 ltr_en : 1;
    /* ltr_en - Bits[10:10], RW_LV, default = 1'b0  */
    UINT16 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCAP2_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x400100BC)                                                     */
/* Register default value:              0x00000000                            */
#define LNKCAP2_IIO_PCIEIOSF_REG 0x140040BC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0bc
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lnkspdvec : 7;
    /* lnkspdvec - Bits[7:1], RW_O, default = 7'b0000000  */
    UINT32 rsvd_8 : 24;
    /* rsvd_8 - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCAP2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCON2_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x200100C0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON2_IIO_PCIEIOSF_REG 0x140020C0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0c0
 */
typedef union {
  struct {
    UINT16 target_link_speed : 4;
    /* target_link_speed - Bits[3:0], RO, default = 4'b0000  */
    UINT16 enter_compliance : 1;
    /* enter_compliance - Bits[4:4], RO, default = 1'b0  */
    UINT16 hardware_autonomous_speed_disable : 1;
    /* hardware_autonomous_speed_disable - Bits[5:5], RO, default = 1'b0  */
    UINT16 selectable_de_emphasis : 1;
    /* selectable_de_emphasis - Bits[6:6], RO, default = 1'b0  */
    UINT16 transmit_margin : 3;
    /* transmit_margin - Bits[9:7], RO, default = 3'b000  */
    UINT16 enter_modified_compliance : 1;
    /* enter_modified_compliance - Bits[10:10], RO, default = 1'b0  */
    UINT16 compliance_sos : 1;
    /* compliance_sos - Bits[11:11], RO, default = 1'b0  */
    UINT16 compliance_de_emphasis : 4;
    /* compliance_de_emphasis - Bits[15:12], RO, default = 4'b0000  */
  } Bits;
  UINT16 Data;
} LNKCON2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PMCAP_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x400100E0)                                                     */
/* Register default value:              0xC8030001                            */
#define PMCAP_IIO_PCIEIOSF_REG 0x140040E0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0e0
 */
typedef union {
  struct {
    UINT32 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000001 
       Provides the PM capability ID assigned by PCI-SIG.
     */
    UINT32 next_capability_pointer : 8;
    /* next_capability_pointer - Bits[15:8], RO, default = 8'b00000000 
       This is the last capability in the chain and hence set to 0.
     */
    UINT32 version : 3;
    /* version - Bits[18:16], RO, default = 3'b011 
       This field is set to 3h (PM 1.2 compliant) as version number.
     */
    UINT32 pme_clock : 1;
    /* pme_clock - Bits[19:19], RO, default = 1'b0 
       This field is hardwired to 0h as it does not apply to PCI Express.
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[20:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 device_specific_initialization : 1;
    /* device_specific_initialization - Bits[21:21], RO, default = 1'b0  */
    UINT32 aux_current : 3;
    /* aux_current - Bits[24:22], RO, default = 3'b000  */
    UINT32 d1_support : 1;
    /* d1_support - Bits[25:25], RO, default = 1'b0 
       I/OxAPIC does not support power management state D1.
     */
    UINT32 d2_support : 1;
    /* d2_support - Bits[26:26], RO, default = 1'b0 
       I/OxAPIC does not support power management state D2.
     */
    UINT32 pme_support : 5;
    /* pme_support - Bits[31:27], RO_V, default = 5'b11001 
       Bits 31, 30 and 27 must be set to \q1\q for PCI-PCI bridge structures 
       representing ports on root complexes. 
     */
  } Bits;
  UINT32 Data;
} PMCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PMCSR_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x400100E4)                                                     */
/* Register default value:              0x00000008                            */
#define PMCSR_IIO_PCIEIOSF_REG 0x140040E4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x0e4
 */
typedef union {
  struct {
    UINT32 power_state : 2;
    /* power_state - Bits[1:0], RW, default = 2'b00 
       This 2-bit field is used to determine the current power state of the function 
       and to set a new power state as well. 
       00: D0
       01: D1 (not supported by IOAPIC)
       10: D2 (not supported by IOAPIC)
       11: D3_hot
       If Software tries to write 01 or 10 to this field, the power state does not 
       change from the existing power state (which is either D0 or D3hot) and nor do 
       these bits1:0 change value. 
       When in D3hot state, I/OxAPIC will
       a) respond to only Type 0 configuration transactions targeted at the device's 
       configuration space, when in D3hot state 
       c) will not respond to memory (i.e. D3hot state is equivalent to MSE ), accesses 
       to MBAR region (note: ABAR region access still go through in D3hot state, if it 
       enabled) 
       d) will not generate any MSI writes
     */
    UINT32 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 no_soft_reset : 1;
    /* no_soft_reset - Bits[3:3], RW_O, default = 1'b1 
       Indicates I/OxAPIC does not reset its registers when transitioning from D3hot to 
       D0. 
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pme_enable : 1;
    /* pme_enable - Bits[8:8], RWS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data_select : 4;
    /* data_select - Bits[12:9], RO, default = 4'b0000 
       Not relevant for I/OxAPIC
     */
    UINT32 data_scale : 2;
    /* data_scale - Bits[14:13], RO, default = 2'b00 
       Not relevant for I/OxAPIC
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[15:15], RW1CS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 rsvd_16 : 6;
    /* rsvd_16 - Bits[21:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 b2_b3_support : 1;
    /* b2_b3_support - Bits[22:22], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 bus_power_clock_control_enable : 1;
    /* bus_power_clock_control_enable - Bits[23:23], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data : 8;
    /* data - Bits[31:24], RO, default = 8'b00000000 
       Not relevant for I/OxAPIC
     */
  } Bits;
  UINT32 Data;
} PMCSR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPREUT_HDR_EXT_IIO_PCIEIOSF_REG supported on:                              */
/*       BDX (0x40010100)                                                     */
/* Register default value:              0x1101000B                            */
#define XPREUT_HDR_EXT_IIO_PCIEIOSF_REG 0x14004100

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x100
 */
typedef union {
  struct {
    UINT32 pciecapid : 16;
    /* pciecapid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 pciecapversion : 4;
    /* pciecapversion - Bits[19:16], RO, default = 4'b0001  */
    UINT32 pcienextptr : 12;
    /* pcienextptr - Bits[31:20], RO, default = 12'b000100010000  */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_EXT_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPREUT_HDR_CAP_IIO_PCIEIOSF_REG supported on:                              */
/*       BDX (0x40010104)                                                     */
/* Register default value:              0x00C00002                            */
#define XPREUT_HDR_CAP_IIO_PCIEIOSF_REG 0x14004104

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x104
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000010  */
    UINT32 vsecidrev : 4;
    /* vsecidrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclength : 12;
    /* vseclength - Bits[31:20], RO, default = 12'b000000001100  */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_CAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPREUT_HDR_LEF_IIO_PCIEIOSF_REG supported on:                              */
/*       BDX (0x40010108)                                                     */
/* Register default value:              0x00003807                            */
#define XPREUT_HDR_LEF_IIO_PCIEIOSF_REG 0x14004108

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x108
 */
typedef union {
  struct {
    UINT32 leafreutengid : 8;
    /* leafreutengid - Bits[7:0], RO_V, default = 8'b00000111  */
    UINT32 leafreutdevnum : 8;
    /* leafreutdevnum - Bits[15:8], RO_V, default = 8'b00111000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_LEF_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ACSCAPHDR_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x40010110)                                                     */
/* Register default value:              0x1481000D                            */
#define ACSCAPHDR_IIO_PCIEIOSF_REG 0x14004110

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x110
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000001101  */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO_V, default = 12'b000101001000  */
  } Bits;
  UINT32 Data;
} ACSCAPHDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ACSCAP_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x20010114)                                                     */
/* Register default value:              0x001F                                */
#define ACSCAP_IIO_PCIEIOSF_REG 0x14002114

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x114
 */
typedef union {
  struct {
    UINT16 v : 1;
    /* v - Bits[0:0], RO_V, default = 1'b1  */
    UINT16 b : 1;
    /* b - Bits[1:1], RO_V, default = 1'b1  */
    UINT16 r : 1;
    /* r - Bits[2:2], RO_V, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS P2P 
       Request Redirect. 
     */
    UINT16 c : 1;
    /* c - Bits[3:3], RO_V, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS P2P 
       Completion Redirect. 
     */
    UINT16 u : 1;
    /* u - Bits[4:4], RO_V, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS Upstream 
       Forwarding. 
     */
    UINT16 e : 1;
    /* e - Bits[5:5], RO, default = 1'b0 
       Applies only to root portsIndicates that the component does not implement ACS 
       P2P Egress Control. 
     */
    UINT16 t : 1;
    /* t - Bits[6:6], RO, default = 1'b0 
       Applies only to root portsIndicates that the component does not implement ACS 
       Direct Translated P2P. 
     */
    UINT16 rsvd : 1;
    /* rsvd - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 egress_control_vector_size : 8;
    /* egress_control_vector_size - Bits[15:8], RO, default = 8'b00000000 
       N/A for IIO
     */
  } Bits;
  UINT16 Data;
} ACSCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ACSCTRL_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x20010116)                                                     */
/* Register default value:              0x0000                                */
#define ACSCTRL_IIO_PCIEIOSF_REG 0x14002116

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x116
 */
typedef union {
  struct {
    UINT16 v : 1;
    /* v - Bits[0:0], RW_L, default = 1'b0 
       Applies only to root portsWhen set, the component validates the Bus Number from 
       the Requester ID of upstream Requests against the secondary / subordinate Bus 
       Numbers. 
     */
    UINT16 b : 1;
    /* b - Bits[1:1], RW_L, default = 1'b0 
       Applies only to root portsWhen set, the component blocks all upstream Memory 
       Requests whose Address Translation (AT) field is not set to the default value. 
     */
    UINT16 r : 1;
    /* r - Bits[2:2], RW_L, default = 1'b0 
       When this bit is set, transactions arriving from a root port that target the 
       same port back down, will be forwarded. Normally such traffic would be aborted. 
       Applies only to root ports. 
     */
    UINT16 c : 1;
    /* c - Bits[3:3], RW_L, default = 1'b0 
       Applies only to root portsDetermines when the component redirects peer-to-peer 
       Completions upstream; applicable only to Read Completions whose Relaxed Ordering 
       Attribute is clear. 
     */
    UINT16 u : 1;
    /* u - Bits[4:4], RW_L, default = 1'b0 
       When this bit is set, transactions arriving from a root port that target the 
       same port back down, will be forwarded. Normally such traffic would be aborted. 
       Applies only to root ports. 
     */
    UINT16 e : 1;
    /* e - Bits[5:5], RO, default = 1'b0 
       Applies only to root portsThe component does not implement ACS P2P Egress 
       Control and hence this bit should not be used by SW. 
     */
    UINT16 t : 1;
    /* t - Bits[6:6], RO, default = 1'b0 
       Applies only to root portsThis is hardwired to 0b as the component does not 
       implement ACS Direct Translated P2P. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[15:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ACSCTRL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* APICBASE_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x20010140)                                                     */
/* Register default value:              0x0000                                */
#define APICBASE_IIO_PCIEIOSF_REG 0x14002140

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x140
 */
typedef union {
  struct {
    UINT16 en : 1;
    /* en - Bits[0:0], RW, default = 1'b0 
       enables the decode of the APIC window
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a don't care for address 
       decode. Address decoding to the APIC range is done as APICBASE.ADDR[31:8] &lt;= 
       A[31:8] &lt;= APICLIMIT.ADDR[31:8]. 
       
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if bit 0 is set, even if the MSE bit of the root port is clear or the 
       root port itself is in D3hot state. 
     */
    UINT16 rsvd : 4;
    /* rsvd - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICBASE_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* APICLIMIT_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x20010142)                                                     */
/* Register default value:              0x0000                                */
#define APICLIMIT_IIO_PCIEIOSF_REG 0x14002142

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x142
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Applies only to root ports.
       
       Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a don't care for address 
       decode. Address decoding to the APIC range is done as APICBASE.ADDR[31:8] &lt;= 
       A[31:8] &lt;= APICLIMIT.ADDR[31:8]. 
       
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if the range is enabled, even if the MSE bit of the root port is clear 
       or the root port itself is in D3hot state. 
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICLIMIT_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRCAPHDR_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x40010148)                                                     */
/* Register default value:              0x1D010001                            */
#define ERRCAPHDR_IIO_PCIEIOSF_REG 0x14004148

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x148
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000000001  */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000111010000  */
  } Bits;
  UINT32 Data;
} ERRCAPHDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCERRSTS_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x4001014C)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRSTS_IIO_PCIEIOSF_REG 0x1400414C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x14c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 ecrc_error_status : 1;
    /* ecrc_error_status - Bits[19:19], RW1CS, default = 1'b0  */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCERRMSK_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x40010150)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRMSK_IIO_PCIEIOSF_REG 0x14004150

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x150
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_mask : 1;
    /* ecrc_error_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCERRSEV_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x40010154)                                                     */
/* Register default value:              0x00062030                            */
#define UNCERRSEV_IIO_PCIEIOSF_REG 0x14004154

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x154
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 ecrc_error_severity : 1;
    /* ecrc_error_severity - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CORERRSTS_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x40010158)                                                     */
/* Register default value:              0x00000000                            */
#define CORERRSTS_IIO_PCIEIOSF_REG 0x14004158

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x158
 */
typedef union {
  struct {
    UINT32 receiver_error_status : 1;
    /* receiver_error_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_status : 1;
    /* bad_tlp_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 bad_dllp_status : 1;
    /* bad_dllp_status - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 replay_num_rollover_status : 1;
    /* replay_num_rollover_status - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_status : 1;
    /* replay_timer_time_out_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_status : 1;
    /* advisory_non_fatal_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CORERRMSK_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x4001015C)                                                     */
/* Register default value:              0x00002000                            */
#define CORERRMSK_IIO_PCIEIOSF_REG 0x1400415C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x15c
 */
typedef union {
  struct {
    UINT32 receiver_error_mask : 1;
    /* receiver_error_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_mask : 1;
    /* bad_tlp_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_mask : 1;
    /* bad_dllp_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_mask : 1;
    /* replay_num_rollover_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_mask : 1;
    /* replay_timer_time_out_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_mask : 1;
    /* advisory_non_fatal_error_mask - Bits[13:13], RWS, default = 1'b1  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRCAP_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x40010160)                                                     */
/* Register default value:              0x00000000                            */
#define ERRCAP_IIO_PCIEIOSF_REG 0x14004160

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x160
 */
typedef union {
  struct {
    UINT32 first_error_pointer : 5;
    /* first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000  */
    UINT32 rsvd : 27;
    /* rsvd - Bits[31:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ERRCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG0_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010164)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG0_IIO_PCIEIOSF_REG 0x14004164

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x164
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG1_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010168)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG1_IIO_PCIEIOSF_REG 0x14004168

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x168
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG2_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x4001016C)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG2_IIO_PCIEIOSF_REG 0x1400416C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x16c
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG3_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010170)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG3_IIO_PCIEIOSF_REG 0x14004170

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x170
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG3_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPERRCMD_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x40010174)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRCMD_IIO_PCIEIOSF_REG 0x14004174

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x174
 */
typedef union {
  struct {
    UINT32 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on correctable errors when set.
     */
    UINT32 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on a non-fatal error when set.
     */
    UINT32 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Applies to root ports onlyEnable MSI/INTx interrupt on fatal errors when set.
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPERRCMD_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPERRSTS_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x40010178)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRSTS_IIO_PCIEIOSF_REG 0x14004178

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x178
 */
typedef union {
  struct {
    UINT32 correctable_error_received : 1;
    /* correctable_error_received - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 multiple_correctable_error_received : 1;
    /* multiple_correctable_error_received - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 error_fatal_nonfatal_received : 1;
    /* error_fatal_nonfatal_received - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 multiple_error_fatal_nonfatal_received : 1;
    /* multiple_error_fatal_nonfatal_received - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 first_uncorrectable_fatal : 1;
    /* first_uncorrectable_fatal - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 non_fatal_error_messages_received : 1;
    /* non_fatal_error_messages_received - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 fatal_error_messages_received : 1;
    /* fatal_error_messages_received - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 rsvd : 20;
    /* rsvd - Bits[26:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 advanced_error_interrupt_message_number : 5;
    /* advanced_error_interrupt_message_number - Bits[31:27], RO, default = 5'b00000  */
  } Bits;
  UINT32 Data;
} RPERRSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRSID_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x4001017C)                                                     */
/* Register default value:              0x00000000                            */
#define ERRSID_IIO_PCIEIOSF_REG 0x1400417C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x17c
 */
typedef union {
  struct {
    UINT32 correctable_error_source_id : 16;
    /* correctable_error_source_id - Bits[15:0], ROS_V, default = 16'b0000000000000000  */
    UINT32 fatal_non_fatal_error_source_id : 16;
    /* fatal_non_fatal_error_source_id - Bits[31:16], ROS_V, default = 16'b0000000000000000  */
  } Bits;
  UINT32 Data;
} ERRSID_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PERFCTRLSTS_0_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010180)                                                     */
/* Register default value:              0x00183091                            */
#define PERFCTRLSTS_0_IIO_PCIEIOSF_REG 0x14004180

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x180
 */
typedef union {
  struct {
    UINT32 read_stream_policy : 1;
    /* read_stream_policy - Bits[0:0], RW, default = 1'b1  */
    UINT32 read_passing_read_disable : 1;
    /* read_passing_read_disable - Bits[1:1], RW, default = 1'b0  */
    UINT32 nosnoopoprden : 1;
    /* nosnoopoprden - Bits[2:2], RW, default = 1'b0  */
    UINT32 nosnoopopwren : 1;
    /* nosnoopopwren - Bits[3:3], RW, default = 1'b0  */
    UINT32 read_stream_interleave_size : 1;
    /* read_stream_interleave_size - Bits[4:4], RW, default = 1'b1  */
    UINT32 rsvd_5 : 2;
    /* rsvd_5 - Bits[6:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 use_allocating_flow_wr : 1;
    /* use_allocating_flow_wr - Bits[7:7], RW, default = 1'b1  */
    UINT32 outstanding_requests_gen2 : 6;
    /* outstanding_requests_gen2 - Bits[13:8], RW, default = 6'b110000  */
    UINT32 rsvd_14 : 2;
    /* rsvd_14 - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outstanding_requests_gen1 : 5;
    /* outstanding_requests_gen1 - Bits[20:16], RW, default = 5'b11000  */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PERFCTRLSTS_1_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010184)                                                     */
/* Register default value:              0x00000000                            */
#define PERFCTRLSTS_1_IIO_PCIEIOSF_REG 0x14004184

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x184
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[3:3], RW, default = 1'b0  */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dca_reqid_override : 1;
    /* dca_reqid_override - Bits[8:8], RW, default = 1'b0  */
    UINT32 tphdis : 1;
    /* tphdis - Bits[9:9], RW, default = 1'b0  */
    UINT32 partial_cohrd_op : 2;
    /* partial_cohrd_op - Bits[11:10], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need less than 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 full_cohrd_op : 2;
    /* full_cohrd_op - Bits[13:12], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need all 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MISCCTRLSTS_0_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010188)                                                     */
/* Register default value:              0x60101000                            */
#define MISCCTRLSTS_0_IIO_PCIEIOSF_REG 0x14004188

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x188
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 inbound_configuration_enable : 1;
    /* inbound_configuration_enable - Bits[1:1], RW_O, default = 1'b0  */
    UINT32 enable_acpi_mode_for_pm : 1;
    /* enable_acpi_mode_for_pm - Bits[2:2], RW, default = 1'b0  */
    UINT32 enable_acpi_mode_for_hotplug : 1;
    /* enable_acpi_mode_for_hotplug - Bits[3:3], RW, default = 1'b0  */
    UINT32 enable_system_error_only_for_aer : 1;
    /* enable_system_error_only_for_aer - Bits[4:4], RW, default = 1'b0  */
    UINT32 send_pme_turn_off_message : 1;
    /* send_pme_turn_off_message - Bits[5:5], RW_V, default = 1'b0  */
    UINT32 enable_timeout_for_receiving_pme_to_ack : 1;
    /* enable_timeout_for_receiving_pme_to_ack - Bits[6:6], RW, default = 1'b0  */
    UINT32 pme2acktoctrl : 2;
    /* pme2acktoctrl - Bits[8:7], RW, default = 2'b00  */
    UINT32 dispdspolling : 1;
    /* dispdspolling - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_ob_parity_check : 1;
    /* disable_ob_parity_check - Bits[12:12], RWS, default = 1'b1  */
    UINT32 tlp_on_any_lane : 1;
    /* tlp_on_any_lane - Bits[13:13], RWS, default = 1'b0  */
    UINT32 allow_one_np_os : 1;
    /* allow_one_np_os - Bits[14:14], RWS, default = 1'b0  */
    UINT32 dis_hdr_storage : 1;
    /* dis_hdr_storage - Bits[15:15], RWS, default = 1'b0  */
    UINT32 force_ep_biterr : 1;
    /* force_ep_biterr - Bits[16:16], RO, default = 1'b0  */
    UINT32 force_data_perr : 1;
    /* force_data_perr - Bits[17:17], RO, default = 1'b0  */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maltlp_32baddr64bhdr_en : 1;
    /* maltlp_32baddr64bhdr_en - Bits[20:20], RW, default = 1'b1  */
    UINT32 zero_ob_tc : 1;
    /* zero_ob_tc - Bits[21:21], RW_O, default = 1'b0  */
    UINT32 check_cpl_tc : 1;
    /* check_cpl_tc - Bits[22:22], RWS, default = 1'b0  */
    UINT32 phold_disable : 1;
    /* phold_disable - Bits[23:23], RW, default = 1'b0  */
    UINT32 peer2peer_memory_read_disable : 1;
    /* peer2peer_memory_read_disable - Bits[24:24], RW, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 eoifd : 1;
    /* eoifd - Bits[26:26], RW_LV, default = 1'b0  */
    UINT32 system_interrupt_only_on_link_bw_management_status : 1;
    /* system_interrupt_only_on_link_bw_management_status - Bits[27:27], RWS, default = 1'b0  */
    UINT32 to_dis : 1;
    /* to_dis - Bits[28:28], RW, default = 1'b0  */
    UINT32 cfg_to_en : 1;
    /* cfg_to_en - Bits[29:29], RW, default = 1'b1  */
    UINT32 inbound_io_disable : 1;
    /* inbound_io_disable - Bits[30:30], RW_O, default = 1'b1  */
    UINT32 disable_l0s_on_transmitter : 1;
    /* disable_l0s_on_transmitter - Bits[31:31], RW, default = 1'b0 
       L0s is not supported on the processor.
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MISCCTRLSTS_1_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x4001018C)                                                     */
/* Register default value:              0x00000000                            */
#define MISCCTRLSTS_1_IIO_PCIEIOSF_REG 0x1400418C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x18c
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0  */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 disable_mctp_broadcast_to_this_link : 1;
    /* disable_mctp_broadcast_to_this_link - Bits[5:5], RW, default = 1'b0  */
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0  */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0  */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 rsvd_18 : 12;
    /* rsvd_18 - Bits[29:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_sending_pme_to_port : 1;
    /* disable_sending_pme_to_port - Bits[30:30], RW, default = 1'b0  */
    UINT32 mimic_pme_to_ack_received : 1;
    /* mimic_pme_to_ack_received - Bits[31:31], RW, default = 1'b0  */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PCIE_IOU_BIF_CTRL_IIO_PCIEIOSF_REG supported on:                           */
/*       BDX (0x20010190)                                                     */
/* Register default value:              0x0003                                */
#define PCIE_IOU_BIF_CTRL_IIO_PCIEIOSF_REG 0x14002190

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU.  
 */
typedef union {
  struct {
    UINT16 iou_bifurcation_control : 3;
    /* iou_bifurcation_control - Bits[2:0], RO, default = 3'b011 
       To select a IOU bifurcation, software sets this field and then either
       a) sets bit 3 in this register to initiate training OR
       b) resets the entire processor and on exit from that reset,
       The processor will bifurcate the ports per the setting in this field.
       For IOSF, default to
       011: x8x8 (operate lanes 15:8 as x8, 7:0 as x8)
     */
    UINT16 iou_start_bifurcation : 1;
    /* iou_start_bifurcation - Bits[3:3], WO, default = 1'b0 
       When software writes a 1 to this bit, IIO starts the port 0 bifurcation process. 
       After writing to this bit, software can poll the Data Link Layer link active bit 
       in the LNKSTS register to determine if a port is up and running. Once a port 
       bifurcation has been initiated by writing a 1 to this bit, software cannot 
       initiate any more write-1 to this bit (write of 0 is ok). 
       Notes:
       That this bit can be written to a 1 in the same write that changes values for 
       bits 2:0 in this register and in that case, the new value from the write to bits 
       2:0 take effect. 
       This bit always reads a 0b.
     */
    UINT16 iou_start_cbdma : 1;
    /* iou_start_cbdma - Bits[4:4], WO, default = 1'b0 
       When software writes a 1 to this bit, IIO starts the port 0 (cbdma) IOSF 
       initialization. 
     */
    UINT16 iou_start_gbe : 1;
    /* iou_start_gbe - Bits[5:5], WO, default = 1'b0 
       When software writes a 1 to this bit, IIO starts the port 2 (gbe) IOSF 
       initialization. 
     */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCIE_IOU_BIF_CTRL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRINJCAP_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x400101D0)                                                     */
/* Register default value:              0x2501000B                            */
#define ERRINJCAP_IIO_PCIEIOSF_REG 0x140041D0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x1d0
 */
typedef union {
  struct {
    UINT32 extcapid : 16;
    /* extcapid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001001010000  */
  } Bits;
  UINT32 Data;
} ERRINJCAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRINJHDR_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x400101D4)                                                     */
/* Register default value:              0x00A10003                            */
#define ERRINJHDR_IIO_PCIEIOSF_REG 0x140041D4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x1d4
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000011  */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0001  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000001010  */
  } Bits;
  UINT32 Data;
} ERRINJHDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRINJCON_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x200101D8)                                                     */
/* Register default value:              0x0000                                */
#define ERRINJCON_IIO_PCIEIOSF_REG 0x140021D8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x1d8
 */
typedef union {
  struct {
    UINT16 errinjdis : 1;
    /* errinjdis - Bits[0:0], RW_O, default = 1'b0  */
    UINT16 cause_rcverr : 1;
    /* cause_rcverr - Bits[1:1], RW, default = 1'b0  */
    UINT16 cause_ctoerr : 1;
    /* cause_ctoerr - Bits[2:2], RW, default = 1'b0  */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ERRINJCON_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CTOCTRL_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x400101E0)                                                     */
/* Register default value:              0x00000000                            */
#define CTOCTRL_IIO_PCIEIOSF_REG 0x140041E0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x1e0
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    /* rsvd_0 - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 xp_to_pcie_timeout_select : 2;
    /* xp_to_pcie_timeout_select - Bits[9:8], RW, default = 2'b00  */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CTOCTRL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPCORERRSTS_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010200)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRSTS_IIO_PCIEIOSF_REG 0x14004200

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x200
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPCORERRMSK_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010204)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRMSK_IIO_PCIEIOSF_REG 0x14004204

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x204
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRSTS_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010208)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRSTS_IIO_PCIEIOSF_REG 0x14004208

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x208
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected : 1;
    /* outbound_switch_fifo_data_parity_error_detected - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort : 1;
    /* sent_completion_with_completer_abort - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request : 1;
    /* sent_completion_with_unsupported_request - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status : 1;
    /* received_pcie_completion_with_ca_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status : 1;
    /* received_pcie_completion_with_ur_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data : 1;
    /* received_msi_writes_greater_than_a_dword_data - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 outbound_poisoned_data : 1;
    /* outbound_poisoned_data - Bits[9:9], RW1CS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRMSK_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x4001020C)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRMSK_IIO_PCIEIOSF_REG 0x1400420C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x20c
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detected_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_mask : 1;
    /* sent_completion_with_completer_abort_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_mask : 1;
    /* sent_completion_with_unsupported_request_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRSEV_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010210)                                                     */
/* Register default value:              0x00000002                            */
#define XPUNCERRSEV_IIO_PCIEIOSF_REG 0x14004210

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x210
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_severity : 1;
    /* outbound_switch_fifo_data_parity_error_detected_severity - Bits[1:1], RWS, default = 1'b1  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_severity : 1;
    /* sent_completion_with_completer_abort_severity - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_severity : 1;
    /* sent_completion_with_unsupported_request_severity - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_severity : 1;
    /* received_pcie_completion_with_ca_status_severity - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_severity : 1;
    /* received_pcie_completion_with_ur_status_severity - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_severity : 1;
    /* received_msi_writes_greater_than_a_dword_data_severity - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_severity : 1;
    /* outbound_poisoned_data_severity - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSEV_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRPTR_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x10010214)                                                     */
/* Register default value:              0x00                                  */
#define XPUNCERRPTR_IIO_PCIEIOSF_REG 0x14001214

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x214
 */
typedef union {
  struct {
    UINT8 xp_uncorrectable_first_error_pointer : 5;
    /* xp_uncorrectable_first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000  */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} XPUNCERRPTR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCEDMASK_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x40010218)                                                     */
/* Register default value:              0x00000000                            */
#define UNCEDMASK_IIO_PCIEIOSF_REG 0x14004218

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x218
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_detect_mask : 1;
    /* ecrc_error_detect_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* COREDMASK_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x4001021C)                                                     */
/* Register default value:              0x00000000                            */
#define COREDMASK_IIO_PCIEIOSF_REG 0x1400421C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x21c
 */
typedef union {
  struct {
    UINT32 receiver_error_detect_mask : 1;
    /* receiver_error_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_detect_mask : 1;
    /* bad_tlp_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_detect_mask : 1;
    /* bad_dllp_detect_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_detect_mask : 1;
    /* replay_num_rollover_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_detect_mask : 1;
    /* replay_timer_time_out_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_detect_mask : 1;
    /* advisory_non_fatal_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} COREDMASK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPEDMASK_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x40010220)                                                     */
/* Register default value:              0x00000000                            */
#define RPEDMASK_IIO_PCIEIOSF_REG 0x14004220

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x220
 */
typedef union {
  struct {
    UINT32 correctable_error_detected_status_mask : 1;
    /* correctable_error_detected_status_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 non_fatal_error_detected_status_mask : 1;
    /* non_fatal_error_detected_status_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 fatal_error_detected_status_mask : 1;
    /* fatal_error_detected_status_mask - Bits[2:2], RWS, default = 1'b0  */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPEDMASK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCEDMASK_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010224)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCEDMASK_IIO_PCIEIOSF_REG 0x14004224

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x224
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detect_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detect_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_detect_mask : 1;
    /* sent_completion_with_completer_abort_detect_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_detect_mask : 1;
    /* sent_completion_with_unsupported_request_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_detect_mask : 1;
    /* received_pcie_completion_with_ca_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_detect_mask : 1;
    /* received_pcie_completion_with_ur_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_detect_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_detect_mask : 1;
    /* outbound_poisoned_data_detect_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCEDMASK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPCOREDMASK_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010228)                                                     */
/* Register default value:              0x00000000                            */
#define XPCOREDMASK_IIO_PCIEIOSF_REG 0x14004228

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x228
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPGLBERRSTS_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x20010230)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRSTS_IIO_PCIEIOSF_REG 0x14002230

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x230
 */
typedef union {
  struct {
    UINT16 pcie_aer_fatal_error : 1;
    /* pcie_aer_fatal_error - Bits[0:0], RW1CS, default = 1'b0  */
    UINT16 pcie_aer_non_fatal_error : 1;
    /* pcie_aer_non_fatal_error - Bits[1:1], RW1CS, default = 1'b0  */
    UINT16 pcie_aer_correctable_error : 1;
    /* pcie_aer_correctable_error - Bits[2:2], RW1CS, default = 1'b0  */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPGLBERRPTR_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x20010232)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRPTR_IIO_PCIEIOSF_REG 0x14002232

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x232
 */
typedef union {
  struct {
    UINT16 xp_cluster_global_first_error_pointer : 3;
    /* xp_cluster_global_first_error_pointer - Bits[2:0], ROS_V, default = 3'b000  */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRPTR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_CAP_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010280)                                                     */
/* Register default value:              0x2981000B                            */
#define LER_CAP_IIO_PCIEIOSF_REG 0x14004280

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x280
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001010011000 
       May not point to 0x298 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} LER_CAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_HDR_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010284)                                                     */
/* Register default value:              0x01830005                            */
#define LER_HDR_IIO_PCIEIOSF_REG 0x14004284

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x284
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000101  */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0011  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000011000  */
  } Bits;
  UINT32 Data;
} LER_HDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_CTRLSTS_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x40010288)                                                     */
/* Register default value:              0x00000000                            */
#define LER_CTRLSTS_IIO_PCIEIOSF_REG 0x14004288

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x288
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0  */
    UINT32 ler_ss_severity_en : 1;
    /* ler_ss_severity_en - Bits[1:1], RWS, default = 1'b0  */
    UINT32 ler_ss_drop_txn : 1;
    /* ler_ss_drop_txn - Bits[2:2], RWS, default = 1'b0  */
    UINT32 ler_ss_inten : 1;
    /* ler_ss_inten - Bits[3:3], RWS, default = 1'b0  */
    UINT32 rsvd : 26;
    /* rsvd - Bits[29:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ler_ss_lnk_up_ok : 1;
    /* ler_ss_lnk_up_ok - Bits[30:30], ROS_V, default = 1'b0  */
    UINT32 ler_ss_status : 1;
    /* ler_ss_status - Bits[31:31], RW1CS, default = 1'b0  */
  } Bits;
  UINT32 Data;
} LER_CTRLSTS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_UNCERRMSK_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x4001028C)                                                     */
/* Register default value:              0x00000000                            */
#define LER_UNCERRMSK_IIO_PCIEIOSF_REG 0x1400428C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x28c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_err_mask : 1;
    /* ecrc_err_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_XPUNCERRMSK_IIO_PCIEIOSF_REG supported on:                             */
/*       BDX (0x40010290)                                                     */
/* Register default value:              0x00000000                            */
#define LER_XPUNCERRMSK_IIO_PCIEIOSF_REG 0x14004290

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x290
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 sent_completion_with_ca_mask : 1;
    /* sent_completion_with_ca_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_ur_mask : 1;
    /* sent_completion_with_ur_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_XPUNCERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_RPERRMSK_IIO_PCIEIOSF_REG supported on:                                */
/*       BDX (0x40010294)                                                     */
/* Register default value:              0x00000000                            */
#define LER_RPERRMSK_IIO_PCIEIOSF_REG 0x14004294

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x294
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 non_fatal_error_message_received_mask : 1;
    /* non_fatal_error_message_received_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 fatal_error_message_received_mask : 1;
    /* fatal_error_message_received_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 25;
    /* rsvd_7 - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_RPERRMSK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_CAP_IIO_PCIEIOSF_REG supported on:                                */
/*       BDX (0x40010298)                                                     */
/* Register default value:              0x3001000B                            */
#define RPPIOERR_CAP_IIO_PCIEIOSF_REG 0x14004298

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * PCIe spec-defined capability register for enhanced root port PIO error 
 * reporting. 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe extended capability ID.
       Set to 0xb for vendor-specific capability.
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability version.
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001100000000 
       Next capability pointer.
       May not point to 0x300 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_CAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDR_IIO_PCIEIOSF_REG supported on:                                */
/*       BDX (0x4001029C)                                                     */
/* Register default value:              0x02400007                            */
#define RPPIOERR_HDR_IIO_PCIEIOSF_REG 0x1400429C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * PCIe spec-defined vendor-specific header register for enhanced root port PIO 
 * error reporting. 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000111 
       Vendor-specific capability ID. Intel defines 0x7 as the ID for enhanced root 
       port PIO error reporting. 
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000 
       VSEC revision.
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000100100 
       VSEC length.
       Length of the RP_PIO_ERR capability in bytes, starting from the capability ID.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HF_IIO_PCIEIOSF_REG supported on:                                 */
/*       BDX (0x400102A0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HF_IIO_PCIEIOSF_REG 0x140042A0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Register that controls which PIO errors should cause a poison indication.
 */
typedef union {
  struct {
    UINT32 cfg_ur_hf : 1;
    /* cfg_ur_hf - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all configuration requests targeting 
       the PCIe hierarchy below the Root Port will be treated as UR, and will return 
       poison if this bit is set. 
     */
    UINT32 cfg_ca_hf : 1;
    /* cfg_ca_hf - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 cfg_to_hf : 1;
    /* cfg_to_hf - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_hf : 1;
    /* io_ur_hf - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all IO requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 io_ca_hf : 1;
    /* io_ca_hf - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 io_to_hf : 1;
    /* io_to_hf - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_hf : 1;
    /* mem_ur_hf - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all memory requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 mem_ca_hf : 1;
    /* mem_ca_hf - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 mem_to_hf : 1;
    /* mem_to_hf - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HF_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_STATUS_IIO_PCIEIOSF_REG supported on:                             */
/*       BDX (0x400102A4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_STATUS_IIO_PCIEIOSF_REG 0x140042A4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Register that logs the PIO errors.  Note that PIO UR errors that occur after LER 
 * has been triggered will not update this register. 
 * If a PIO error is detected and the corresponding RPPIOERR_MASK bit is cleared, 
 * then LER will be triggered if LER is enabled, and pio_err_first_header and 
 * RPPIOERR_HDRLOG[0-3] may update. 
 * Regardless of the state of the corresponding RPPIOERR_MASK bit, a PIO error may 
 * update its status bit in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_err : 1;
    /* cfg_ur_err - Bits[0:0], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ur_mask). 
     */
    UINT32 cfg_ca_err : 1;
    /* cfg_ca_err - Bits[1:1], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ca_mask). 
     */
    UINT32 cfg_to_err : 1;
    /* cfg_to_err - Bits[2:2], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_err : 1;
    /* io_ur_err - Bits[8:8], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ur_mask). 
     */
    UINT32 io_ca_err : 1;
    /* io_ca_err - Bits[9:9], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ca_mask). 
     */
    UINT32 io_to_err : 1;
    /* io_to_err - Bits[10:10], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.io_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_err : 1;
    /* mem_ur_err - Bits[16:16], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ur_mask). 
     */
    UINT32 mem_ca_err : 1;
    /* mem_ca_err - Bits[17:17], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ca_mask). 
     */
    UINT32 mem_to_err : 1;
    /* mem_to_err - Bits[18:18], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 pio_err_first_header : 5;
    /* pio_err_first_header - Bits[23:19], RW1CS, default = 5'b00000 
       These 5 bits identify the first unmasked (by rppioerr_mask) RPPIO error that was 
       observed. The encoding is as follows: 
       00: No Error
       01: CFG_UR_ERR
       02: CFG_CA_ERR
       03: CFG_TO_ERR
       04: IO_UR_ERR
       05: IO_CA_ERR
       06: IO_TO_ERR
       07: MEM_UR_ERR
       08: MEM_CA_ERR
       09: MEM_TO_ERR
       Others: undefined
       Note these bits will not record subsequent errors until the first error is 
       cleared by SW. 
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_STATUS_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_MASK_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x400102A8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_MASK_IIO_PCIEIOSF_REG 0x140042A8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Register that masks triggering of LER on PIO errors.  When clear, LER will be 
 * triggered when LER is enabled and an error sets the corresponding bit in the 
 * RPPIOERR_STATUS. 
 * When RPPIOERR_STATUS is used to trigger LER, it is expected the end user will 
 * program the LER_XPUNCERRMSK and XPUNCERRMSK registers correctly so that they do 
 * not trigger a LER event also. 
 * If LER_CTRLSTS.LER_Enable is not set, LER will not be triggered, regardless of 
 * the setting of the RPPIOERR_MASK registers. 
 * Poison may still be returned to the requester, based on the RPPIOERR_HF 
 * register, even when the corresponding error is masked in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_mask : 1;
    /* cfg_ur_mask - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_ca_mask : 1;
    /* cfg_ca_mask - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_to_mask : 1;
    /* cfg_to_mask - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_mask : 1;
    /* io_ur_mask - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_ca_mask : 1;
    /* io_ca_mask - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_to_mask : 1;
    /* io_to_mask - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_mask : 1;
    /* mem_ur_mask - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_ca_mask : 1;
    /* mem_ca_mask - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_to_mask : 1;
    /* mem_to_mask - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_MASK_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG0_IIO_PCIEIOSF_REG supported on:                            */
/*       BDX (0x400102AC)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG0_IIO_PCIEIOSF_REG 0x140042AC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 0 ([31:24]), 1 ([23:16]), 2 ([15:8]), and 3 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG1_IIO_PCIEIOSF_REG supported on:                            */
/*       BDX (0x400102B0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG1_IIO_PCIEIOSF_REG 0x140042B0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 4 ([31:24]), 5 ([23:16]), 6 ([15:8]), and 7 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG2_IIO_PCIEIOSF_REG supported on:                            */
/*       BDX (0x400102B4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG2_IIO_PCIEIOSF_REG 0x140042B4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 8 ([31:24]), 9 ([23:16]), 10 ([15:8]), and 11 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG3_IIO_PCIEIOSF_REG supported on:                            */
/*       BDX (0x400102B8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG3_IIO_PCIEIOSF_REG 0x140042B8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 12 ([31:24]), 13 ([23:16]), 14 ([15:8]), and 15 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG3_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */










/* MCAST_CAP_HDR_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010300)                                                     */
/* Register default value:              0x0001000B                            */
#define MCAST_CAP_HDR_IIO_PCIEIOSF_REG 0x14004300

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Capability Header Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_HDR_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CAP_EXT_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010304)                                                     */
/* Register default value:              0x03800008                            */
#define MCAST_CAP_EXT_IIO_PCIEIOSF_REG 0x14004304

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Extended Capability Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000001000 
       Vendor-specific capability ID. Intel defines 0x8 as the ID for dualcast.
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000111000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_EXT_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CAP_IIO_PCIEIOSF_REG supported on:                                   */
/*       BDX (0x2001030C)                                                     */
/* Register default value:              0x000F                                */
#define MCAST_CAP_IIO_PCIEIOSF_REG 0x1400230C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Capability Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Capability Register (see section 7.21.2 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_max_group : 6;
    /* mc_max_group - Bits[5:0], RO, default = 6'b001111  */
    UINT16 rsvd_6 : 2;
    /* rsvd_6 - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_window_size_req : 6;
    /* mc_window_size_req - Bits[13:8], RO, default = 6'b000000  */
    UINT16 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_ecrc_regen_sup : 1;
    /* mc_ecrc_regen_sup - Bits[15:15], RO, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CAP_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CTRL_IIO_PCIEIOSF_REG supported on:                                  */
/*       BDX (0x2001030E)                                                     */
/* Register default value:              0x0000                                */
#define MCAST_CTRL_IIO_PCIEIOSF_REG 0x1400230E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Control Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Control Register (see section 7.21.3 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_num_group : 6;
    /* mc_num_group - Bits[5:0], RW_L, default = 6'b000000 
       This field only supports and implements bits [3:0]. Bits [5:4] are not 
       supported. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[14:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_enable : 1;
    /* mc_enable - Bits[15:15], RW_L, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CTRL_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_BASE_N0_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010310)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N0_IIO_PCIEIOSF_REG 0x14004310

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Base Address Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_index_position : 6;
    /* mc_index_position - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 rsvd : 6;
    /* rsvd - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mc_base_address : 20;
    /* mc_base_address - Bits[31:12], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_BASE_N1_IIO_PCIEIOSF_REG supported on:                               */
/*       BDX (0x40010314)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N1_IIO_PCIEIOSF_REG 0x14004314

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Base Address Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_base_address : 32;
    /* mc_base_address - Bits[31:0], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_RCV_N0_IIO_PCIEIOSF_REG supported on:                                */
/*       BDX (0x40010318)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_RCV_N0_IIO_PCIEIOSF_REG 0x14004318

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Receive Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Receive Register (see section 7.21.5 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_rcv : 16;
    /* mc_rcv - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_RCV_N0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




/* MCAST_BLK_ALL_N0_IIO_PCIEIOSF_REG supported on:                            */
/*       BDX (0x40010320)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_ALL_N0_IIO_PCIEIOSF_REG 0x14004320

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Block All Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_All Register (see section 7.21.6 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_all : 16;
    /* mc_blk_all - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_ALL_N0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




/* MCAST_BLK_UNT_N0_IIO_PCIEIOSF_REG supported on:                            */
/*       BDX (0x40010328)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_UNT_N0_IIO_PCIEIOSF_REG 0x14004328

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Block Untranslated Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_Untranslated Register (see section 7.21.7 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_unt : 16;
    /* mc_blk_unt - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_UNT_N0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




/* MCAST_OVERLAY_BAR_N0_IIO_PCIEIOSF_REG supported on:                        */
/*       BDX (0x40010330)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N0_IIO_PCIEIOSF_REG 0x14004330

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Overlay Bar Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_size : 6;
    /* mc_overlay_size - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 mc_overlay_addr : 26;
    /* mc_overlay_addr - Bits[31:6], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_OVERLAY_BAR_N1_IIO_PCIEIOSF_REG supported on:                        */
/*       BDX (0x40010334)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N1_IIO_PCIEIOSF_REG 0x14004334

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * Dualcast Overlay Bar Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_addr : 32;
    /* mc_overlay_addr - Bits[31:0], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMDL0_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010480)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMDL0_IIO_PCIEIOSF_REG 0x14004480

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_data_counter_low_value : 32;
    /* pm_data_counter_low_value - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} XPPMDL0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMDL1_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010484)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMDL1_IIO_PCIEIOSF_REG 0x14004484

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_data_counter_low_value : 32;
    /* pm_data_counter_low_value - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} XPPMDL1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMCL0_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x40010488)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL0_IIO_PCIEIOSF_REG 0x14004488

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_compare_low_value : 32;
    /* pm_compare_low_value - Bits[31:0], RW_V, default = 32'b11111111111111111111111111111111  */
  } Bits;
  UINT32 Data;
} XPPMCL0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMCL1_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x4001048C)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL1_IIO_PCIEIOSF_REG 0x1400448C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_compare_low_value : 32;
    /* pm_compare_low_value - Bits[31:0], RW_V, default = 32'b11111111111111111111111111111111  */
  } Bits;
  UINT32 Data;
} XPPMCL1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMDH_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x20010490)                                                     */
/* Register default value:              0x0000                                */
#define XPPMDH_IIO_PCIEIOSF_REG 0x14002490

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT16 high_nibble_pex_counter0_value : 4;
    /* high_nibble_pex_counter0_value - Bits[3:0], RW_V, default = 4'b0000  */
    UINT16 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 high_nibble_pex_counter1_value : 4;
    /* high_nibble_pex_counter1_value - Bits[11:8], RW_V, default = 4'b0000  */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPPMDH_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMCH_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x20010492)                                                     */
/* Register default value:              0x0F0F                                */
#define XPPMCH_IIO_PCIEIOSF_REG 0x14002492

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT16 high_nibble_pex_compare0_value : 4;
    /* high_nibble_pex_compare0_value - Bits[3:0], RW_V, default = 4'b1111  */
    UINT16 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 high_nibble_pex_compare1_value : 4;
    /* high_nibble_pex_compare1_value - Bits[11:8], RW_V, default = 4'b1111  */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPPMCH_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMR0_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x40010494)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMR0_IIO_PCIEIOSF_REG 0x14004494

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 counter_reset : 1;
    /* counter_reset - Bits[0:0], RW, default = 1'b0  */
    UINT32 overflow_status_bit : 1;
    /* overflow_status_bit - Bits[1:1], RW1C, default = 1'b0  */
    UINT32 compare_status : 1;
    /* compare_status - Bits[2:2], RW1C, default = 1'b0  */
    UINT32 cto : 2;
    /* cto - Bits[4:3], RW, default = 2'b00  */
    UINT32 pm_status_signal_output : 1;
    /* pm_status_signal_output - Bits[5:5], RW, default = 1'b0  */
    UINT32 compare_mode : 2;
    /* compare_mode - Bits[7:6], RW, default = 2'b00  */
    UINT32 reset_event_select : 3;
    /* reset_event_select - Bits[10:8], RW, default = 3'b000  */
    UINT32 counter_enable_source : 3;
    /* counter_enable_source - Bits[13:11], RW, default = 3'b000  */
    UINT32 count_mode : 2;
    /* count_mode - Bits[15:14], RW, default = 2'b00  */
    UINT32 event_polarity_invert : 1;
    /* event_polarity_invert - Bits[16:16], RW, default = 1'b0  */
    UINT32 count_event_select : 2;
    /* count_event_select - Bits[18:17], RW, default = 2'b00  */
    UINT32 event_group_selection : 2;
    /* event_group_selection - Bits[20:19], RW, default = 2'b00  */
    UINT32 local_dft_event_select : 1;
    /* local_dft_event_select - Bits[21:21], RW, default = 1'b0  */
    UINT32 rsvd_22 : 2;
    UINT32 rsvd_24 : 3;
    /* rsvd_24 - Bits[26:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 reset_pulse_enable : 1;
    /* reset_pulse_enable - Bits[27:27], RW, default = 1'b0  */
    UINT32 latched_count_enable_select : 1;
    /* latched_count_enable_select - Bits[28:28], RW, default = 1'b0  */
    UINT32 force_pmd_counter_to_add_zero_to_input : 1;
    /* force_pmd_counter_to_add_zero_to_input - Bits[29:29], RW, default = 1'b0  */
    UINT32 not_greater_than_comparison : 1;
    /* not_greater_than_comparison - Bits[30:30], RW, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMR0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMR1_IIO_PCIEIOSF_REG supported on:                                      */
/*       BDX (0x40010498)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMR1_IIO_PCIEIOSF_REG 0x14004498

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 counter_reset : 1;
    /* counter_reset - Bits[0:0], RW, default = 1'b0  */
    UINT32 overflow_status_bit : 1;
    /* overflow_status_bit - Bits[1:1], RW1C, default = 1'b0  */
    UINT32 compare_status : 1;
    /* compare_status - Bits[2:2], RW1C, default = 1'b0  */
    UINT32 cto : 2;
    /* cto - Bits[4:3], RW, default = 2'b00  */
    UINT32 pm_status_signal_output : 1;
    /* pm_status_signal_output - Bits[5:5], RW, default = 1'b0  */
    UINT32 compare_mode : 2;
    /* compare_mode - Bits[7:6], RW, default = 2'b00  */
    UINT32 reset_event_select : 3;
    /* reset_event_select - Bits[10:8], RW, default = 3'b000  */
    UINT32 counter_enable_source : 3;
    /* counter_enable_source - Bits[13:11], RW, default = 3'b000  */
    UINT32 count_mode : 2;
    /* count_mode - Bits[15:14], RW, default = 2'b00  */
    UINT32 event_polarity_invert : 1;
    /* event_polarity_invert - Bits[16:16], RW, default = 1'b0  */
    UINT32 count_event_select : 2;
    /* count_event_select - Bits[18:17], RW, default = 2'b00  */
    UINT32 event_group_selection : 2;
    /* event_group_selection - Bits[20:19], RW, default = 2'b00  */
    UINT32 local_dft_event_select : 1;
    /* local_dft_event_select - Bits[21:21], RW, default = 1'b0  */
    UINT32 rsvd_22 : 2;
    UINT32 rsvd_24 : 3;
    /* rsvd_24 - Bits[26:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 reset_pulse_enable : 1;
    /* reset_pulse_enable - Bits[27:27], RW, default = 1'b0  */
    UINT32 latched_count_enable_select : 1;
    /* latched_count_enable_select - Bits[28:28], RW, default = 1'b0  */
    UINT32 force_pmd_counter_to_add_zero_to_input : 1;
    /* force_pmd_counter_to_add_zero_to_input - Bits[29:29], RW, default = 1'b0  */
    UINT32 not_greater_than_comparison : 1;
    /* not_greater_than_comparison - Bits[30:30], RW, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMR1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMEVL0_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x4001049C)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVL0_IIO_PCIEIOSF_REG 0x1400449C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 for_completion_packet_or_message_encoding_for_request_packet : 4;
    /* for_completion_packet_or_message_encoding_for_request_packet - Bits[3:0], RW, default = 4'b0000  */
    UINT32 data_length : 7;
    /* data_length - Bits[10:4], RW, default = 7'b0000000  */
    UINT32 fmttyp : 5;
    /* fmttyp - Bits[15:11], RW, default = 5'b00000  */
    UINT32 cfgtyp : 2;
    /* cfgtyp - Bits[17:16], RW, default = 2'b00  */
    UINT32 extended_addressing_header : 2;
    /* extended_addressing_header - Bits[19:18], RW, default = 2'b00  */
    UINT32 lock_attribute_selection : 2;
    /* lock_attribute_selection - Bits[21:20], RW, default = 2'b00  */
    UINT32 request_packet_only : 2;
    /* request_packet_only - Bits[23:22], RW, default = 2'b00  */
    UINT32 read_or_write_selection : 2;
    /* read_or_write_selection - Bits[25:24], RW, default = 2'b00  */
    UINT32 request_or_completion_packet_selection : 2;
    /* request_or_completion_packet_selection - Bits[27:26], RW, default = 2'b00  */
    UINT32 snoop_attribute : 2;
    /* snoop_attribute - Bits[29:28], RW, default = 2'b00  */
    UINT32 data_or_no_data_attribute : 2;
    /* data_or_no_data_attribute - Bits[31:30], RW, default = 2'b00  */
  } Bits;
  UINT32 Data;
} XPPMEVL0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMEVL1_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x400104A0)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVL1_IIO_PCIEIOSF_REG 0x140044A0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 for_completion_packet_or_message_encoding_for_request_packet : 4;
    /* for_completion_packet_or_message_encoding_for_request_packet - Bits[3:0], RW, default = 4'b0000  */
    UINT32 data_length : 7;
    /* data_length - Bits[10:4], RW, default = 7'b0000000  */
    UINT32 fmttyp : 5;
    /* fmttyp - Bits[15:11], RW, default = 5'b00000  */
    UINT32 cfgtyp : 2;
    /* cfgtyp - Bits[17:16], RW, default = 2'b00  */
    UINT32 extended_addressing_header : 2;
    /* extended_addressing_header - Bits[19:18], RW, default = 2'b00  */
    UINT32 lock_attribute_selection : 2;
    /* lock_attribute_selection - Bits[21:20], RW, default = 2'b00  */
    UINT32 cmpreq : 2;
    /* cmpreq - Bits[23:22], RW, default = 2'b00  */
    UINT32 read_or_write_selection : 2;
    /* read_or_write_selection - Bits[25:24], RW, default = 2'b00  */
    UINT32 request_or_completion_packet_selection : 2;
    /* request_or_completion_packet_selection - Bits[27:26], RW, default = 2'b00  */
    UINT32 snoop_attribute : 2;
    /* snoop_attribute - Bits[29:28], RW, default = 2'b00  */
    UINT32 data_or_no_data_attribute : 2;
    /* data_or_no_data_attribute - Bits[31:30], RW, default = 2'b00  */
  } Bits;
  UINT32 Data;
} XPPMEVL1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMEVH0_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x400104A4)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVH0_IIO_PCIEIOSF_REG 0x140044A4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 inbound_or_outbound_selection : 2;
    /* inbound_or_outbound_selection - Bits[1:0], RW, default = 2'b00  */
    UINT32 global_event_selection : 6;
    /* global_event_selection - Bits[7:2], RW, default = 6'b000000  */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMEVH0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMEVH1_IIO_PCIEIOSF_REG supported on:                                    */
/*       BDX (0x400104A8)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVH1_IIO_PCIEIOSF_REG 0x140044A8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 inbound_or_outbound_selection : 2;
    /* inbound_or_outbound_selection - Bits[1:0], RW, default = 2'b00  */
    UINT32 global_event_selection : 6;
    /* global_event_selection - Bits[7:2], RW, default = 6'b000000  */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMEVH1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMER0_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x400104AC)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMER0_IIO_PCIEIOSF_REG 0x140044AC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000  */
    UINT32 flowcntrclass : 2;
    /* flowcntrclass - Bits[7:6], RW, default = 2'b00  */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 link_send_utilization : 4;
    /* link_send_utilization - Bits[16:13], RW, default = 4'b0000  */
    UINT32 xp_resource_assignment : 4;
    /* xp_resource_assignment - Bits[20:17], RW, default = 4'b0000  */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMER0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPPMER1_IIO_PCIEIOSF_REG supported on:                                     */
/*       BDX (0x400104B0)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMER1_IIO_PCIEIOSF_REG 0x140044B0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000  */
    UINT32 flowcntrclass : 2;
    /* flowcntrclass - Bits[7:6], RW, default = 2'b00  */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 link_send_utilization : 4;
    /* link_send_utilization - Bits[16:13], RW, default = 4'b0000  */
    UINT32 xp_resource_assignment : 4;
    /* xp_resource_assignment - Bits[20:17], RW, default = 4'b0000  */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMER1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLSR0_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x400104B4)                                                     */
/* Register default value:              0x00000000                            */
#define PLSR0_IIO_PCIEIOSF_REG 0x140044B4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x4b4
 */
typedef union {
  struct {
    UINT32 poison_log_type : 2;
    /* poison_log_type - Bits[1:0], ROS_V, default = 2'b00 
       Value of 00 = IIO generated inbound poison
       Value of 01 = Inbound from PCIe
       Value of 10 = Poison coming from ring
       Value of 11 = IIO generated outbound poison
     */
    UINT32 poison_log_rid : 16;
    /* poison_log_rid - Bits[17:2], ROS_V, default = 16'b0000000000000000 
       Requestor id
     */
    UINT32 poison_log_len : 10;
    /* poison_log_len - Bits[27:18], ROS_V, default = 10'b0000000000 
       Request Length
     */
    UINT32 poison_log_addr_vld : 1;
    /* poison_log_addr_vld - Bits[28:28], RW1CS_LBV, default = 1'b0 
       If this bit is set then it indicates that the address logged in the plsr1 and 
       plsr2 is valid. 
     */
    UINT32 poison_log_overflow : 1;
    /* poison_log_overflow - Bits[29:29], RW1CS_LBV, default = 1'b0 
       Poison detection event was observed when valid=1. In this case, the register 
       will retain the information about the first error. This is consistent with 
       UCNA/UCNA overwrite rules in Machine Check Architecture. 
     */
    UINT32 poison_log_valid : 1;
    /* poison_log_valid - Bits[30:30], RW1CS_LBV, default = 1'b0 
       If Valid=0, the log does not contain any valid information.
       If Valid=1, the log contain valid information. Any additional ring poison 
       detection events will set overflow bit. 
     */
    UINT32 poison_log_en : 1;
    /* poison_log_en - Bits[31:31], RWS_L, default = 1'b0 
       This bit indicates if the shadow logging is enabled or disabled. A value of 0 is 
       disabled and a value of 1 is enabled. If not enabled no logging takes place in 
       this register. 
     */
  } Bits;
  UINT32 Data;
} PLSR0_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLSR1_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x400104B8)                                                     */
/* Register default value:              0x00000000                            */
#define PLSR1_IIO_PCIEIOSF_REG 0x140044B8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x4b8
 */
typedef union {
  struct {
    UINT32 poison_log_addr_lo : 32;
    /* poison_log_addr_lo - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Address 31:0 associated with the poison data (e.g. Address field in poisoned BL 
       packet). 
     */
  } Bits;
  UINT32 Data;
} PLSR1_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLSR2_IIO_PCIEIOSF_REG supported on:                                       */
/*       BDX (0x400104BC)                                                     */
/* Register default value:              0x00000000                            */
#define PLSR2_IIO_PCIEIOSF_REG 0x140044BC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.0.IOSF.xml.
 * generated by critter 02_0_0x4bc
 */
typedef union {
  struct {
    UINT32 poison_log_addr_hi : 32;
    /* poison_log_addr_hi - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Address 63:32 associated with the poison data
     */
  } Bits;
  UINT32 Data;
} PLSR2_IIO_PCIEIOSF_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




#endif /* IIO_PCIEIOSF_h */
