/* Date Stamp: 8/23/2014 */

#ifndef IIO_VTD_h
#define IIO_VTD_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* IIO_VTD_DEV 5                                                              */
/* IIO_VTD_FUN 0                                                              */

/* VID_IIO_VTD_REG supported on:                                              */
/*       IVT_EP (0x20028000)                                                  */
/*       IVT_EX (0x20028000)                                                  */
/*       HSX (0x20028000)                                                     */
/*       BDX (0x20028000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_VTD_REG 0x09002000
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* DID_IIO_VTD_REG supported on:                                              */
/*       IVT_EP (0x20028002)                                                  */
/*       IVT_EX (0x20028002)                                                  */
/*       HSX (0x20028002)                                                     */
/*       BDX (0x20028002)                                                     */
/* Register default value on IVT_EP:    0x0E28                                */
/* Register default value on IVT_EX:    0x0E28                                */
/* Register default value on HSX:       0x2F28                                */
/* Register default value on BDX:       0x6F28                                */
#define DID_IIO_VTD_REG 0x09002002
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'b0110111100101000 
       Device ID values vary from function to function. Bits 15:8 are equal to 0x6F for 
       the processor. The following list is a breakdown of the function groups. 
       0x6F00 - 0x6F1F : PCI Express and DMI ports
       0x6F20 - 0x6F3F : IO Features (Intel QuickData Technology, APIC, VT, RAS, Intel 
       TXT) 
       0x6F40 - 0x6F5F : Performance Monitors
       0x6F60 - 0x6F7F : DFX
       0x6F80 - 0x6F9F : Intel QPI
       0x6FA0 - 0x6FBF : Home Agent/Memory Controller
       0x6FC0 - 0x6FDF : Power Management
       0x6FE0 - 0x6FFF : Cbo/Ring
       
       Default value may vary based on bus, device, and function of this CSR location.
     */
  } Bits;
  UINT16 Data;
} DID_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* PCICMD_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x20028004)                                                  */
/*       IVT_EX (0x20028004)                                                  */
/*       HSX (0x20028004)                                                     */
/*       BDX (0x20028004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_VTD_REG 0x09002004
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x004
 */
typedef union {
  struct {
    UINT16 io_space_enable : 1;
    /* io_space_enable - Bits[0:0], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any IO BARs
     */
    UINT16 memory_space_enable : 1;
    /* memory_space_enable - Bits[1:1], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any memory BARs
     */
    UINT16 bus_master_enable : 1;
    /* bus_master_enable - Bits[2:2], RO, default = 1'b0 
       Hardwired to 0 since these devices don't generate any transactions
     */
    UINT16 special_cycle_enable : 1;
    /* special_cycle_enable - Bits[3:3], RO, default = 1'b0 
       Not applicable. Hardwired to 0.
     */
    UINT16 memory_write_and_invalidate_enable : 1;
    /* memory_write_and_invalidate_enable - Bits[4:4], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 parity_error_response : 1;
    /* parity_error_response - Bits[6:6], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 serr_enable : 1;
    /* serr_enable - Bits[8:8], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0
     */
    UINT16 intx_disable : 1;
    /* intx_disable - Bits[10:10], RO, default = 1'b0 
       N/A for these devices
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* PCISTS_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x20028006)                                                  */
/*       IVT_EX (0x20028006)                                                  */
/*       HSX (0x20028006)                                                     */
/*       BDX (0x20028006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_VTD_REG 0x09002006
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x006
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure
     */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 master_data_parity_error : 1;
    /* master_data_parity_error - Bits[8:8], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 signaled_target_abort : 1;
    /* signaled_target_abort - Bits[11:11], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_target_abort : 1;
    /* received_target_abort - Bits[12:12], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_master_abort : 1;
    /* received_master_abort - Bits[13:13], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 signaled_system_error : 1;
    /* signaled_system_error - Bits[14:14], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 detected_parity_error : 1;
    /* detected_parity_error - Bits[15:15], RO, default = 1'b0 
       This bit is set when the device receives a packet on the primary side with an 
       uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
       R2PCIe will never set this bit. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* RID_IIO_VTD_REG supported on:                                              */
/*       IVT_EP (0x10028008)                                                  */
/*       IVT_EX (0x10028008)                                                  */
/*       HSX (0x10028008)                                                     */
/*       BDX (0x10028008)                                                     */
/* Register default value:              0x00                                  */
#define RID_IIO_VTD_REG 0x09001008
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * "PCIe header Revision ID register"
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], ROS_V, default = 8'b00000000 
       Reflects the Uncore Revision ID after reset.
       Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID 
       register in the processor uncore. 
       
     */
  } Bits;
  UINT8 Data;
} RID_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* CCR_N0_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x10028009)                                                  */
/*       IVT_EX (0x10028009)                                                  */
/*       HSX (0x10028009)                                                     */
/*       BDX (0x10028009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_VTD_REG 0x09001009


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT8 register_level_programming_interface : 8;
    /* register_level_programming_interface - Bits[7:0], RO_V, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} CCR_N0_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* CCR_N1_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x2002800A)                                                  */
/*       IVT_EX (0x2002800A)                                                  */
/*       HSX (0x2002800A)                                                     */
/*       BDX (0x2002800A)                                                     */
/* Register default value:              0x0880                                */
#define CCR_N1_IIO_VTD_REG 0x0900200A
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO_V, default = 8'b10000000 
       The value changes dependent upon the dev/func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h80 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h01. 
                 dev-0x0 through 0x7 (return 0x4, d0f0 return 0x0 under default 
       settings) 
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO_V, default = 8'b00001000 
       The value changes dependent upon the dev-func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h08 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h11. 
                 dev-0x0 through 0x7 (return 0x6)
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
  } Bits;
  UINT16 Data;
} CCR_N1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* CLSR_IIO_VTD_REG supported on:                                             */
/*       IVT_EP (0x1002800C)                                                  */
/*       IVT_EX (0x1002800C)                                                  */
/*       HSX (0x1002800C)                                                     */
/*       BDX (0x1002800C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_VTD_REG 0x0900100C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only. Cacheline size for 
       processor is always 64B. 
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* HDR_IIO_VTD_REG supported on:                                              */
/*       IVT_EP (0x1002800E)                                                  */
/*       IVT_EX (0x1002800E)                                                  */
/*       HSX (0x1002800E)                                                     */
/*       BDX (0x1002800E)                                                     */
/* Register default value:              0x80                                  */
#define HDR_IIO_VTD_REG 0x0900100E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x00e
 */
typedef union {
  struct {
    UINT8 configuration_layout : 7;
    /* configuration_layout - Bits[6:0], RO, default = 7'b0000000 
       This field identifies the format of the configuration header layout. It is Type 
       0 for all these devices. The default is 00h, indicating a 'endpoint device'. 
     */
    UINT8 multi_function_device : 1;
    /* multi_function_device - Bits[7:7], RO, default = 1'b1 
       This bit defaults to 1b since all these devices are multi-function
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* SVID_IIO_VTD_REG supported on:                                             */
/*       IVT_EP (0x2002802C)                                                  */
/*       IVT_EX (0x2002802C)                                                  */
/*       HSX (0x2002802C)                                                     */
/*       BDX (0x2002802C)                                                     */
/* Register default value:              0x0000                                */
#define SVID_IIO_VTD_REG 0x0900202C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_identification_number : 16;
    /* subsystem_vendor_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       The default value specifies Intel but can be set to any value once after reset.
     */
  } Bits;
  UINT16 Data;
} SVID_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* SDID_IIO_VTD_REG supported on:                                             */
/*       IVT_EP (0x2002802E)                                                  */
/*       IVT_EX (0x2002802E)                                                  */
/*       HSX (0x2002802E)                                                     */
/*       BDX (0x2002802E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_VTD_REG 0x0900202E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_identification_number : 16;
    /* subsystem_device_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       Assigned by the subsystem vendor to uniquely identify the subsystem
     */
  } Bits;
  UINT16 Data;
} SDID_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* CAPPTR_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x10028034)                                                  */
/*       IVT_EX (0x10028034)                                                  */
/*       HSX (0x10028034)                                                     */
/*       BDX (0x10028034)                                                     */
/* Register default value:              0x40                                  */
#define CAPPTR_IIO_VTD_REG 0x09001034
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'b01000000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* INTL_IIO_VTD_REG supported on:                                             */
/*       IVT_EP (0x1002803C)                                                  */
/*       IVT_EX (0x1002803C)                                                  */
/*       HSX (0x1002803C)                                                     */
/*       BDX (0x1002803C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_VTD_REG 0x0900103C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* INTPIN_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x1002803D)                                                  */
/*       IVT_EX (0x1002803D)                                                  */
/*       HSX (0x1002803D)                                                     */
/*       BDX (0x1002803D)                                                     */
/* Register default value:              0x00                                  */
#define INTPIN_IIO_VTD_REG 0x0900103D
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x03d
 */
typedef union {
  struct {
    UINT8 interrupt_pin : 8;
    /* interrupt_pin - Bits[7:0], RO, default = 8'b00000000 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* PXPCAPID_IIO_VTD_REG supported on:                                         */
/*       IVT_EP (0x10028040)                                                  */
/*       IVT_EX (0x10028040)                                                  */
/*       HSX (0x10028040)                                                     */
/*       BDX (0x10028040)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_VTD_REG 0x09001040
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x040
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* PXPNXTPTR_IIO_VTD_REG supported on:                                        */
/*       IVT_EP (0x10028041)                                                  */
/*       IVT_EX (0x10028041)                                                  */
/*       HSX (0x10028041)                                                     */
/*       BDX (0x10028041)                                                     */
/* Register default value:              0x00                                  */
#define PXPNXTPTR_IIO_VTD_REG 0x09001041
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x041
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b00000000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* PXPCAP_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x20028042)                                                  */
/*       IVT_EX (0x20028042)                                                  */
/*       HSX (0x20028042)                                                     */
/*       BDX (0x20028042)                                                     */
/* Register default value:              0x0092                                */
#define PXPCAP_IIO_VTD_REG 0x09002042
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x042
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RO, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure. Set 
       to 2h for PCI Express and DMA devices for compliance with the extended base 
       registers. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO, default = 4'b1001 
       This field identifies the type of device. It is set to for the DMA to indicate 
       root complex integrated endpoint device. 
     */
    UINT16 slot_implemented_n_a : 1;
    /* slot_implemented_n_a - Bits[8:8], RO, default = 1'b0  */
    UINT16 interrupt_message_number_n_a : 5;
    /* interrupt_message_number_n_a - Bits[13:9], RO, default = 5'b00000  */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* HDRTYPECTRL_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x10028080)                                                  */
/*       IVT_EX (0x10028080)                                                  */
/*       HSX (0x10028080)                                                     */
/*       BDX (0x10028080)                                                     */
/* Register default value:              0x00                                  */
#define HDRTYPECTRL_IIO_VTD_REG 0x09001080
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x080
 */
typedef union {
  struct {
    UINT8 clr_hdrmfd : 3;
    /* clr_hdrmfd - Bits[2:0], RW, default = 3'b000 
       When set, function#0 with in the indicated device shows a value of 0 for bit 7 
       of the HDR register, indicating a single function device. BIOS sets this bit, 
       when only function#0 is visible within the device, either because SKU reasons or 
       BIOS has hidden all functions but function#0 within the device via the DEVHIDE 
       register. 
       
       Bit 0 is for Device#1
       Bit 1 is for Device#2
       Bit 3 is for Device#3
       
       Currently this is defined only for devices 1, 2 and 3 because in other devices 
       it is expected that at least 2 functions are visible to OS or the entire device 
       is hidden. 
     */
    UINT8 rsvd : 5;
    /* rsvd - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} HDRTYPECTRL_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* MMCFG_BASE_N0_IIO_VTD_REG supported on:                                    */
/*       HSX (0x40028090)                                                     */
/*       BDX (0x40028090)                                                     */
/* Register default value:              0x7FFFFFC000000                       */
#define MMCFG_BASE_N0_IIO_VTD_REG 0x09004090

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * MMCFG Address Base.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mmcfg_base_addr : 6;
    /* mmcfg_base_addr - Bits[31:26], RW_LB, default = 25'b1111111111111111111111111 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Indicates the base address which is aligned to a 64 MB boundary.
     */
  } Bits;
  UINT32 Data;
} MMCFG_BASE_N0_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MMCFG_BASE_N1_IIO_VTD_REG supported on:                                    */
/*       HSX (0x40028094)                                                     */
/*       BDX (0x40028094)                                                     */
/* Register default value:              0x01FFFFFF                            */
#define MMCFG_BASE_N1_IIO_VTD_REG 0x09004094

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * MMCFG Address Base.
 */
typedef union {
  struct {
    UINT32 mmcfg_base_addr : 19;
    /* mmcfg_base_addr - Bits[18:0], RW_LB, default = 25'b1111111111111111111111111 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Indicates the base address which is aligned to a 64 MB boundary.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMCFG_BASE_N1_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MMCFG_LIMIT_N0_IIO_VTD_REG supported on:                                   */
/*       HSX (0x40028098)                                                     */
/*       BDX (0x40028098)                                                     */
/* Register default value:              0x00000000                            */
#define MMCFG_LIMIT_N0_IIO_VTD_REG 0x09004098

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * MMCFG Address Limit.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mmcfg_limit_addr : 6;
    /* mmcfg_limit_addr - Bits[31:26], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Indicates the limit address which is aligned to a 64MB boundary. Any access that 
       decodes to be between MMCFG.BASE &lt;= Addr &lt;= MMCFG.LIMIT targets the MMCFG 
       region and is aborted by IIO. 
       Address bits[25:0] are ignored and may be any value.
       Address bits[63:32] must be 0.
       Setting the MMCFG.BASE greater than MMCFG.LIMIT, disables this region.
     */
  } Bits;
  UINT32 Data;
} MMCFG_LIMIT_N0_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* MMCFG_LIMIT_N1_IIO_VTD_REG supported on:                                   */
/*       HSX (0x4002809C)                                                     */
/*       BDX (0x4002809C)                                                     */
/* Register default value:              0x00000000                            */
#define MMCFG_LIMIT_N1_IIO_VTD_REG 0x0900409C

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * MMCFG Address Limit.
 */
typedef union {
  struct {
    UINT32 mmcfg_limit_addr : 19;
    /* mmcfg_limit_addr - Bits[18:0], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Indicates the limit address which is aligned to a 64MB boundary. Any access that 
       decodes to be between MMCFG.BASE &lt;= Addr &lt;= MMCFG.LIMIT targets the MMCFG 
       region and is aborted by IIO. 
       Address bits[25:0] are ignored and may be any value.
       Address bits[63:32] must be 0.
       Setting the MMCFG.BASE greater than MMCFG.LIMIT, disables this region.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMCFG_LIMIT_N1_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* TOMMIOL_OB_IIO_VTD_REG supported on:                                       */
/*       HSX (0x400280A4)                                                     */
/*       BDX (0x400280A4)                                                     */
/* Register default value:              0xFBF00000                            */
#define TOMMIOL_OB_IIO_VTD_REG 0x090040A4

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0a4
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 tommiol_ob : 12;
    /* tommiol_ob - Bits[31:20], RW_LB, default = 12'b111110111111 
       This field is used to prevent non-DMI links, along with CBDMA/APIC/NTB primary 
       BARs, from claiming outbound addresses 
       starting above this address and ending at 0xffff_ffff. Bits 19:0 are zero and 
       not writable, and are treated as 1's (like TOLM and TOHM). 
       Set this to 0xfff to disable TOMMIOL_OB. This is intended to be set consistently 
       with TOMMIOL, but the two can be different if needed. 
     */
  } Bits;
  UINT32 Data;
} TOMMIOL_OB_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* TSEG_N0_IIO_VTD_REG supported on:                                          */
/*       IVT_EP (0x400280A8)                                                  */
/*       IVT_EX (0x400280A8)                                                  */
/*       HSX (0x400280A8)                                                     */
/*       BDX (0x400280A8)                                                     */
/* Register default value:              0xFE000000                            */
#define TSEG_N0_IIO_VTD_REG 0x090040A8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0a8
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base : 12;
    /* base - Bits[31:20], RW_LB, default = 12'b111111100000 
       Indicates the base address which is aligned to a 1MB boundary. Bits [31:20] 
       corresponds to A[31:20] address bits. 
     */
  } Bits;
  UINT32 Data;
} TSEG_N0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* TSEG_N1_IIO_VTD_REG supported on:                                          */
/*       IVT_EP (0x400280AC)                                                  */
/*       IVT_EX (0x400280AC)                                                  */
/*       HSX (0x400280AC)                                                     */
/*       BDX (0x400280AC)                                                     */
/* Register default value:              0x00000000                            */
#define TSEG_N1_IIO_VTD_REG 0x090040AC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0a8
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit : 12;
    /* limit - Bits[31:20], RW_LB, default = 12'b000000000000 
       Indicates the limit address which is aligned to a 1MB boundary.
       
       Any access to falls within TSEG.BASE[31:20] &lt;= Addr[31:20] &lt;= 
       TSEG.LIMIT[31:20] is considered to target the Tseg region and IIO aborts it. 
       
       Note that address bits 19:0 are ignored and not compared. The result is that 
       BASE[19:0] is effectively 00000h and LIMIT is effectively FFFFFh. 
       
       Setting the TSEG.BASE greater than the limit, disable this region.
       
       Note that setting BASE[31:20] = LIMIT[31:0] opens a 1MB window due to address 
       bits [19:0] being ignored for this comparison. 
     */
  } Bits;
  UINT32 Data;
} TSEG_N1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE1_BASE_0_IIO_VTD_REG supported on:                             */
/*       IVT_EP (0x400280B0)                                                  */
/*       IVT_EX (0x400280B0)                                                  */
/*       HSX (0x400280B0)                                                     */
/*       BDX (0x400280B0)                                                     */
/* Register default value:              0xFFFF0000                            */
#define GENPROTRANGE1_BASE_0_IIO_VTD_REG 0x090040B0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Generic Protected Memory Range X Base Address. 
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 16'b1111111111111111 
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] &lt;= Address [63:16] &lt;= GenProtRange.Limit [63:16], 
       are completer aborted by IIO. 
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to Intel VT-d 
       spec defined protected address range. 
       Since this register provides for a generic range, it can be used to protect any 
       system dram region or MMIO region from DMA accesses. But the expected usage for 
       this range is to abort all PCIe* accesses to the PCI-Segments region. 
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_BASE_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE1_BASE_1_IIO_VTD_REG supported on:                             */
/*       IVT_EP (0x400280B4)                                                  */
/*       IVT_EX (0x400280B4)                                                  */
/*       HSX (0x400280B4)                                                     */
/*       BDX (0x400280B4)                                                     */
/* Register default value:              0x0007FFFF                            */
#define GENPROTRANGE1_BASE_1_IIO_VTD_REG 0x090040B4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0b4
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 19'b1111111111111111111 
       Upper bits of genprotrange1_base_0.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], RO, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_BASE_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE1_LIMIT_0_IIO_VTD_REG supported on:                            */
/*       IVT_EP (0x400280B8)                                                  */
/*       IVT_EX (0x400280B8)                                                  */
/*       HSX (0x400280B8)                                                     */
/*       BDX (0x400280B8)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE1_LIMIT_0_IIO_VTD_REG 0x090040B8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Generic Protected Memory Range X Limit Address.
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 16'b0000000000000000 
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] &lt;= Address [63:16] &lt;= GenProtRange.Limit [63:16], 
       are completer aborted by IIO. 
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. 
       Note that this range is orthogonal to Intel VT-d spec defined protected address 
       range. This register is programmed once at boot time and does not change after 
       that, including any quiesce flows. Since this register provides for a generic 
       range, it can be used to protect any system dram region from DMA accesses. The 
       expected usage for this range is to abort all PCIe* accesses to the PCI-Segments 
       region. 
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_LIMIT_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE1_LIMIT_1_IIO_VTD_REG supported on:                            */
/*       IVT_EP (0x400280BC)                                                  */
/*       IVT_EX (0x400280BC)                                                  */
/*       HSX (0x400280BC)                                                     */
/*       BDX (0x400280BC)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE1_LIMIT_1_IIO_VTD_REG 0x090040BC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0bc
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 19'b0000000000000000000 
       Upper bits of genprotrange1_limit_0.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], RO, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_LIMIT_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE2_BASE_0_IIO_VTD_REG supported on:                             */
/*       IVT_EP (0x400280C0)                                                  */
/*       IVT_EX (0x400280C0)                                                  */
/*       HSX (0x400280C0)                                                     */
/*       BDX (0x400280C0)                                                     */
/* Register default value:              0xFFFF0000                            */
#define GENPROTRANGE2_BASE_0_IIO_VTD_REG 0x090040C0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Generic Protected Memory Range 2 Base Address.
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 16'b1111111111111111 
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] &lt;= Address [63:16] &lt;= GenProtRange.Limit [63:16], 
       are completer aborted by IIO. 
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. 
       Note that this range is orthogonal to Intel VT-d spec defined protected address 
       range. This register is programmed once at boot time and does not change after 
       that, including any quiesce flows. 
       This region is expected to be used to protect against PAM region accesses 
       inbound, but could also be used for other purposes, if needed. 
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_BASE_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE2_BASE_1_IIO_VTD_REG supported on:                             */
/*       IVT_EP (0x400280C4)                                                  */
/*       IVT_EX (0x400280C4)                                                  */
/*       HSX (0x400280C4)                                                     */
/*       BDX (0x400280C4)                                                     */
/* Register default value:              0x0007FFFF                            */
#define GENPROTRANGE2_BASE_1_IIO_VTD_REG 0x090040C4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0c4
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 19'b1111111111111111111 
       Upper bits of genprotrange2_base_0.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], RO, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_BASE_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE2_LIMIT_0_IIO_VTD_REG supported on:                            */
/*       IVT_EP (0x400280C8)                                                  */
/*       IVT_EX (0x400280C8)                                                  */
/*       HSX (0x400280C8)                                                     */
/*       BDX (0x400280C8)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE2_LIMIT_0_IIO_VTD_REG 0x090040C8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Generic Protected Memory Range 2 Limit Address. 
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 16'b0000000000000000 
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] &lt;= Address [63:16] &lt;= GenProtRange. Limit 
       [63:16], are completer aborted by IIO. 
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. 
       Note that this range is orthogonal to Intel VT-d spec defined protected address 
       range. This register is programmed once at boot time and does not change after 
       that, including any quiesce flows. 
       This region is expected to be used to protect against PAM region accesses 
       inbound, but could also be used for other purposes, if needed. 
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_LIMIT_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE2_LIMIT_1_IIO_VTD_REG supported on:                            */
/*       IVT_EP (0x400280CC)                                                  */
/*       IVT_EX (0x400280CC)                                                  */
/*       HSX (0x400280CC)                                                     */
/*       BDX (0x400280CC)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE2_LIMIT_1_IIO_VTD_REG 0x090040CC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0cc
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 19'b0000000000000000000 
       Upper bits of genprotrange2_limit_0.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], RO, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_LIMIT_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* TOLM_IIO_VTD_REG supported on:                                             */
/*       IVT_EP (0x400280D0)                                                  */
/*       IVT_EX (0x400280D0)                                                  */
/*       HSX (0x400280D0)                                                     */
/*       BDX (0x400280D0)                                                     */
/* Register default value:              0x00000000                            */
#define TOLM_IIO_VTD_REG 0x090040D0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Top of Low Memory.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b000000 
       TOLM Address. Indicates the top of low dram memory which is aligned to a 64MB 
       boundary. A 32 bit transaction that satisfies 0 &lt;= Address[31:26] &lt;= 
       TOLM[31:26] is a transaction towards main memory. 
     */
  } Bits;
  UINT32 Data;
} TOLM_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* TOHM_0_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x400280D4)                                                  */
/*       IVT_EX (0x400280D4)                                                  */
/*       HSX (0x400280D4)                                                     */
/*       BDX (0x400280D4)                                                     */
/* Register default value:              0x00000000                            */
#define TOHM_0_IIO_VTD_REG 0x090040D4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Top of High Memory.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b000000 
       TOHM Address. Indicates the limit of an aligned 64 MB granular region that 
       decodes &gt;4 GB addresses towards system dram memory. A 64-bit transaction that 
       satisfies '4G &lt;= A[63:26] &lt;= TOHM[63:26]' is a transaction towards main 
       memory. This register is programmed once at boot time and does not change after 
       that, including during quiesce flows. 
     */
  } Bits;
  UINT32 Data;
} TOHM_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* TOHM_1_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x400280D8)                                                  */
/*       IVT_EX (0x400280D8)                                                  */
/*       HSX (0x400280D8)                                                     */
/*       BDX (0x400280D8)                                                     */
/* Register default value:              0x00000000                            */
#define TOHM_1_IIO_VTD_REG 0x090040D8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0d8
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b00000000000000000000000000000000 
       Upper bits of tohm_0.
     */
  } Bits;
  UINT32 Data;
} TOHM_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* TOMMIOL_IIO_VTD_REG supported on:                                          */
/*       HSX (0x400280DC)                                                     */
/*       BDX (0x400280DC)                                                     */
/* Register default value:              0xFBF00000                            */
#define TOMMIOL_IIO_VTD_REG 0x090040DC

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0dc
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 tommiol : 12;
    /* tommiol - Bits[31:20], RW_LB, default = 12'b111110111111 
       This field is used to abort inbound MRd/MWr/atomic accesses starting above this 
       address and ending at 0xffff_ffff, 
       exclusive of the interrupt hole (0xfeex_xxxx). Bits 19:0 are zero and not 
       writable, and are treated as 1's (like TOLM and TOHM). 
       Set this to 0xfff to disable TOMMIOL.
     */
  } Bits;
  UINT32 Data;
} TOMMIOL_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* NCMEM_BASE_0_IIO_VTD_REG supported on:                                     */
/*       IVT_EP (0x400280E0)                                                  */
/*       IVT_EX (0x400280E0)                                                  */
/*       HSX (0x400280E0)                                                     */
/*       BDX (0x400280E0)                                                     */
/* Register default value:              0xFC000000                            */
#define NCMEM_BASE_0_IIO_VTD_REG 0x090040E0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Noncoherent memory base address. Describes the base address of a 64MB aligned 
 * dram memory region on Intel QPI that is not coherent. Address bits [63:26] of an 
 * inbound address if it satisfies (NcMem.Base[63:26] &lt;= A[63:26] &lt;= 
 * NcMem.Limit[63:26]) is considered to be towards the noncoherent Intel QPI memory 
 * region. This means that IIO cannot ever use 'allocating' write commands for 
 * accesses to this region, over IDI. This, in effect, means that DCA/TH writes 
 * cannot ever target this address region.  
 * The range indicated by the noncoherent memory base and limit registers does not 
 * necessarily fall within the low dram or high dram memory regions as described 
 * via the corresponding base and limit registers.  
 * Usage Model for this range is ROL. Accesses to this range default to NSWr and 
 * NSRd accesses on Intel QPI. But accesses to this range will use non-allocating 
 * reads and writes, when enabled.  
 * This register is programmed once at boot time and does not change after that, 
 * including any quiesce flows.  
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b111111  */
  } Bits;
  UINT32 Data;
} NCMEM_BASE_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* NCMEM_BASE_1_IIO_VTD_REG supported on:                                     */
/*       IVT_EP (0x400280E4)                                                  */
/*       IVT_EX (0x400280E4)                                                  */
/*       HSX (0x400280E4)                                                     */
/*       BDX (0x400280E4)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define NCMEM_BASE_1_IIO_VTD_REG 0x090040E4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0e4
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b11111111111111111111111111111111 
       Upper bits of ncmem_base_0.
     */
  } Bits;
  UINT32 Data;
} NCMEM_BASE_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* NCMEM_LIMIT_0_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x400280E8)                                                  */
/*       IVT_EX (0x400280E8)                                                  */
/*       HSX (0x400280E8)                                                     */
/*       BDX (0x400280E8)                                                     */
/* Register default value:              0x00000000                            */
#define NCMEM_LIMIT_0_IIO_VTD_REG 0x090040E8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Noncoherent Memory Limit.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b000000 
       Noncoherent memory limit address. Describes the limit address of a 64 MB aligned 
       dram memory region on Intel QPI that is noncoherent. Address bits [63:26] of an 
       inbound address if it satisfies 'NcMem.Base[63:26] &lt;= A[63:26] &lt;= 
       NcMem.Limit[63:26]' is considered to be towards the noncoherent Intel QPI memory 
       region. This means that IIO cannot ever use 'allocating' write commands for 
       accesses to this region, over IDI. This in effect means that DCA/TH writes 
       cannot ever target this address region. 
       The range indicated by the noncoherent memory base and limit registers does not 
       necessarily fall within the low dram or high dram memory regions as described 
       via the corresponding base and limit registers. 
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
  } Bits;
  UINT32 Data;
} NCMEM_LIMIT_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* NCMEM_LIMIT_1_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x400280EC)                                                  */
/*       IVT_EX (0x400280EC)                                                  */
/*       HSX (0x400280EC)                                                     */
/*       BDX (0x400280EC)                                                     */
/* Register default value:              0x00000000                            */
#define NCMEM_LIMIT_1_IIO_VTD_REG 0x090040EC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0ec
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b00000000000000000000000000000000 
       Upper bits of ncmem_limit_0.
     */
  } Bits;
  UINT32 Data;
} NCMEM_LIMIT_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* MENCMEM_BASE_0_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x400280F0)                                                  */
/*       IVT_EX (0x400280F0)                                                  */
/*       HSX (0x400280F0)                                                     */
/*       BDX (0x400280F0)                                                     */
/* Register default value:              0xFFF80000                            */
#define MENCMEM_BASE_0_IIO_VTD_REG 0x090040F0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Intel Management Engine (Intel ME) noncoherent memory base address.
 */
typedef union {
  struct {
    UINT32 rsvd : 19;
    /* rsvd - Bits[18:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 13;
    /* addr - Bits[31:19], RW_LB, default = 13'b1111111111111 
       Intel Management Engine (Intel ME) UMA Base Address. Indicates the base address 
       which is aligned to a 1MB boundary. Bits [63:19] corresponds to A[63:19] address 
       bits. 
     */
  } Bits;
  UINT32 Data;
} MENCMEM_BASE_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* MENCMEM_BASE_1_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x400280F4)                                                  */
/*       IVT_EX (0x400280F4)                                                  */
/*       HSX (0x400280F4)                                                     */
/*       BDX (0x400280F4)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define MENCMEM_BASE_1_IIO_VTD_REG 0x090040F4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0f4
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b11111111111111111111111111111111 
       Upper bits of mencmem_base_0.
     */
  } Bits;
  UINT32 Data;
} MENCMEM_BASE_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* MENCMEM_LIMIT_0_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x400280F8)                                                  */
/*       IVT_EX (0x400280F8)                                                  */
/*       HSX (0x400280F8)                                                     */
/*       BDX (0x400280F8)                                                     */
/* Register default value:              0x00000000                            */
#define MENCMEM_LIMIT_0_IIO_VTD_REG 0x090040F8
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Intel Management Engine (Intel ME) noncoherent Memory Base Limit.
 */
typedef union {
  struct {
    UINT32 rsvd : 19;
    /* rsvd - Bits[18:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 13;
    /* addr - Bits[31:19], RW_LB, default = 13'b0000000000000 
       Intel ME UMA Limit Address. Indicates the limit address which is aligned to a 
       1MB boundary. Bits [63:19] corresponds to A[63:19] address bits. Any address 
       that falls within MENCMEMBASE &lt;= Addr &lt;= MENCMEMLIMIT range is considered 
       to target the UMA range. Setting the MCNCMEM_BASE greater than the MCNCMEM_LIMIT 
       disables this range. 
       The range indicated by this register must fall within the low dram or high dram 
       memory regions as described via the corresponding base and limit registers. 
     */
  } Bits;
  UINT32 Data;
} MENCMEM_LIMIT_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* MENCMEM_LIMIT_1_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x400280FC)                                                  */
/*       IVT_EX (0x400280FC)                                                  */
/*       HSX (0x400280FC)                                                     */
/*       BDX (0x400280FC)                                                     */
/* Register default value:              0x00000000                            */
#define MENCMEM_LIMIT_1_IIO_VTD_REG 0x090040FC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x0fc
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b00000000000000000000000000000000 
       Upper bits of mencmem_limit_0.
     */
  } Bits;
  UINT32 Data;
} MENCMEM_LIMIT_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* PXPEXTCAP_IIO_VTD_REG supported on:                                        */
/*       HSX (0x40028100)                                                     */
/*       BDX (0x40028100)                                                     */
/* Register default value:              0x00000000                            */
#define PXPEXTCAP_IIO_VTD_REG 0x09004100

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * This field implements the extended capability header required by 7.9.1 in the 
 * PCIe 3.0 spec. 
 */
typedef union {
  struct {
    UINT32 extended_capability_id : 16;
    /* extended_capability_id - Bits[15:0], RO, default = 16'b0000000000000000 
       Indicates there are no extended capability structures for this dev/fn.
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0000 
       Indicates there are no extended capability structures for this dev/fn.
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000000000000 
       Indicates there are no extended capability structures for this dev/fn.
     */
  } Bits;
  UINT32 Data;
} PXPEXTCAP_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* CPUBUSNO_IIO_VTD_REG supported on:                                         */
/*       IVT_EP (0x40028108)                                                  */
/*       IVT_EX (0x40028108)                                                  */
/*       HSX (0x40028108)                                                     */
/*       BDX (0x40028108)                                                     */
/* Register default value:              0x00000000                            */
#define CPUBUSNO_IIO_VTD_REG 0x09004108
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * CPU internal bus numbers.
 */
typedef union {
  struct {
    UINT32 bus0 : 8;
    /* bus0 - Bits[7:0], RW_LB, default = 8'b00000000 
       Is the internal bus# of IIO and also PCH. Configuration requests that target 
       Devices 16-31 on this bus number must be forwarded to the PCH by the IIO. 
       Devices 0-15 on this bus number are claimed by the UBOX to send to IIO internal 
       registers. UBOX master aborts devices 8-15 automatically, since these devices do 
       not exist. 
     */
    UINT32 bus1 : 8;
    /* bus1 - Bits[15:8], RW_LB, default = 8'b00000000 
       Is the internal bus# of rest of uncore. All devices are claimed by UBOX on 
       behalf of this component. Devices that do not exist within this component on 
       this bus number are master aborted by the UBOX. 
     */
    UINT32 valid : 1;
    /* valid - Bits[16:16], RW_LB, default = 1'b0 
       1: IIO claims PCI config accesses from ring if:
       the bus# matches the value in bits 7:0 of this register and Dev# >= 16
       OR
       the bus# does not match either the value in bits 7:0 or 15:8 of this register
       
       0: IIO does not claim PCI config accesses from ring
     */
    UINT32 segment : 8;
    /* segment - Bits[24:17], RW_LB, default = 8'b00000000  */
    UINT32 rsvd : 7;
    /* rsvd - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPUBUSNO_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* LMMIOL_BASE_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x2002810C)                                                  */
/*       IVT_EX (0x2002810C)                                                  */
/*       HSX (0x2002810C)                                                     */
/*       BDX (0x2002810C)                                                     */
/* Register default value:              0x0000                                */
#define LMMIOL_BASE_IIO_VTD_REG 0x0900210C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Local MMIO Low Base.
 */
typedef union {
  struct {
    UINT16 rsvd : 8;
    /* rsvd - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 base : 8;
    /* base - Bits[15:8], RW_LB, default = 8'b00000000 
       Corresponds to A[31:24] of MMIOL base address. An inbound memory address that 
       satisfies ?local MMIOL base[15:8] <= A[31:24] <= local MMIOL limit[15:8]? is 
       treated as a local peer-to-peer transaction that do not cross coherent 
       interface. 
       Note:
       Setting LMMIOL.BASE greater than LMMIOL.LIMIT disables local MMIOL peer-to-peer.
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
  } Bits;
  UINT16 Data;
} LMMIOL_BASE_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* LMMIOL_LIMIT_IIO_VTD_REG supported on:                                     */
/*       IVT_EP (0x2002810E)                                                  */
/*       IVT_EX (0x2002810E)                                                  */
/*       HSX (0x2002810E)                                                     */
/*       BDX (0x2002810E)                                                     */
/* Register default value:              0x0000                                */
#define LMMIOL_LIMIT_IIO_VTD_REG 0x0900210E
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Local MMIO Low Limit.
 */
typedef union {
  struct {
    UINT16 rsvd : 8;
    /* rsvd - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 limit : 8;
    /* limit - Bits[15:8], RW_LB, default = 8'b00000000 
       Corresponds to A[31:24] of MMIOL limit. An inbound memory address that satisfies 
       ?local MMIOL base[15:8] <= A[31:24] <= local MMIOL limit[15:8]? is treated as a 
       local peer-to-peer transaction that does not cross the coherent interface. 
       Note:
       Setting LMMIOL.BASE greater than LMMIOL.LIMIT disables local MMIOL peer-to-peer.
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
  } Bits;
  UINT16 Data;
} LMMIOL_LIMIT_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* LMMIOH_BASE_N0_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x40028110)                                                  */
/*       IVT_EX (0x40028110)                                                  */
/*       HSX (0x40028110)                                                     */
/*       BDX (0x40028110)                                                     */
/* Register default value:              0x00000000                            */
#define LMMIOH_BASE_N0_IIO_VTD_REG 0x09004110
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Local MMIO Low Base.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base : 6;
    /* base - Bits[31:26], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Corresponds to A[50:26] of MMIOH base. An inbound memory address that satisfies 
       local MMIOH base [50:26] &lt;= A[63:26] &lt;= local MMIOH limit [50:26] is 
       treated as a local peer2peer transaction that does not cross the coherent 
       interface. 
       
       Notes:
       Setting LMMIOH.BASE greater than LMMIOH.LIMIT disables local MMIOH peer2peer.
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
  } Bits;
  UINT32 Data;
} LMMIOH_BASE_N0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* LMMIOH_BASE_N1_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x40028114)                                                  */
/*       IVT_EX (0x40028114)                                                  */
/*       HSX (0x40028114)                                                     */
/*       BDX (0x40028114)                                                     */
/* Register default value:              0x00000000                            */
#define LMMIOH_BASE_N1_IIO_VTD_REG 0x09004114
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Local MMIO Low Base.
 */
typedef union {
  struct {
    UINT32 base : 19;
    /* base - Bits[18:0], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Corresponds to A[50:26] of MMIOH base. An inbound memory address that satisfies 
       local MMIOH base [50:26] &lt;= A[63:26] &lt;= local MMIOH limit [50:26] is 
       treated as a local peer2peer transaction that does not cross the coherent 
       interface. 
       
       Notes:
       Setting LMMIOH.BASE greater than LMMIOH.LIMIT disables local MMIOH peer2peer.
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LMMIOH_BASE_N1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* LMMIOH_LIMIT_N0_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x40028118)                                                  */
/*       IVT_EX (0x40028118)                                                  */
/*       HSX (0x40028118)                                                     */
/*       BDX (0x40028118)                                                     */
/* Register default value:              0x00000000                            */
#define LMMIOH_LIMIT_N0_IIO_VTD_REG 0x09004118
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Local MMIO Low Limit.
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit : 6;
    /* limit - Bits[31:26], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Corresponds to A[50:26] of MMIOH limit. An inbound memory address that satisfies 
       local MMIOH base [50:26] &lt;= A[63:26] &lt;= local MMIOH limit [50:26] is 
       treated as local a peer2peer transactions that does not cross the coherent 
       interface. 
       
       Notes:
       Setting LMMIOH.BASE greater than LMMIOH.LIMIT disables local MMIOH peer2peer.
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
  } Bits;
  UINT32 Data;
} LMMIOH_LIMIT_N0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* LMMIOH_LIMIT_N1_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x4002811C)                                                  */
/*       IVT_EX (0x4002811C)                                                  */
/*       HSX (0x4002811C)                                                     */
/*       BDX (0x4002811C)                                                     */
/* Register default value:              0x00000000                            */
#define LMMIOH_LIMIT_N1_IIO_VTD_REG 0x0900411C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Local MMIO Low Limit.
 */
typedef union {
  struct {
    UINT32 limit : 19;
    /* limit - Bits[18:0], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Corresponds to A[50:26] of MMIOH limit. An inbound memory address that satisfies 
       local MMIOH base [50:26] &lt;= A[63:26] &lt;= local MMIOH limit [50:26] is 
       treated as local a peer2peer transactions that does not cross the coherent 
       interface. 
       
       Notes:
       Setting LMMIOH.BASE greater than LMMIOH.LIMIT disables local MMIOH peer2peer.
       This register is programmed once at boot time and does not change after that, 
       including any quiesce flows. 
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LMMIOH_LIMIT_N1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE0_BASE_0_IIO_VTD_REG supported on:                             */
/*       IVT_EP (0x40028120)                                                  */
/*       IVT_EX (0x40028120)                                                  */
/*       HSX (0x40028120)                                                     */
/*       BDX (0x40028120)                                                     */
/* Register default value:              0xFFFF0000                            */
#define GENPROTRANGE0_BASE_0_IIO_VTD_REG 0x09004120
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Generic Protected Memory Range X Base Address. 
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 16'b1111111111111111 
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] &lt;= Address [63:16] &lt;= GenProtRange.Limit [63:16], 
       are completer aborted by IIO. 
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to Intel VT-d 
       spec defined protected address range. 
       Since this register provides for a generic range, it can be used to protect any 
       system dram region or MMIO region from DMA accesses. But the expected usage for 
       this range is to abort all PCIe* accesses to the PCI-Segments region. 
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_BASE_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE0_BASE_1_IIO_VTD_REG supported on:                             */
/*       IVT_EP (0x40028124)                                                  */
/*       IVT_EX (0x40028124)                                                  */
/*       HSX (0x40028124)                                                     */
/*       BDX (0x40028124)                                                     */
/* Register default value:              0x0007FFFF                            */
#define GENPROTRANGE0_BASE_1_IIO_VTD_REG 0x09004124
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x124
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 19'b1111111111111111111 
       Upper bits of genprotrange0_base_0.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], RO, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_BASE_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE0_LIMIT_0_IIO_VTD_REG supported on:                            */
/*       IVT_EP (0x40028128)                                                  */
/*       IVT_EX (0x40028128)                                                  */
/*       HSX (0x40028128)                                                     */
/*       BDX (0x40028128)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE0_LIMIT_0_IIO_VTD_REG 0x09004128
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Generic Protected Memory Range X Limit Address.
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 16'b0000000000000000 
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] &lt;= Address [63:16] &lt;= GenProtRange.Limit [63:16], 
       are completer aborted by IIO. 
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. 
       Note that this range is orthogonal to Intel VT-d spec defined protected address 
       range. This register is programmed once at boot time and does not change after 
       that, including any quiesce flows. Since this register provides for a generic 
       range, it can be used to protect any system dram region from DMA accesses. The 
       expected usage for this range is to abort all PCIe* accesses to the PCI-Segments 
       region. 
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_LIMIT_0_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* GENPROTRANGE0_LIMIT_1_IIO_VTD_REG supported on:                            */
/*       IVT_EP (0x4002812C)                                                  */
/*       IVT_EX (0x4002812C)                                                  */
/*       HSX (0x4002812C)                                                     */
/*       BDX (0x4002812C)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE0_LIMIT_1_IIO_VTD_REG 0x0900412C
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x12c
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 19'b0000000000000000000 
       Upper bits of genprotrange0_limit_0.
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], RO, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_LIMIT_1_IIO_VTD_STRUCT;
#endif /* ASM_INC */






/* CIPCTRL_IIO_VTD_REG supported on:                                          */
/*       IVT_EP (0x40028140)                                                  */
/*       IVT_EX (0x40028140)                                                  */
/*       HSX (0x40028140)                                                     */
/*       BDX (0x40028140)                                                     */
/* Register default value on IVT_EP:    0x00000040                            */
/* Register default value on IVT_EX:    0x00000040                            */
/* Register default value on HSX:       0x00008600                            */
/* Register default value on BDX:       0x00008600                            */
#define CIPCTRL_IIO_VTD_REG 0x09004140


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x140
 */
typedef union {
  struct {
    UINT32 numrtids_isoc_pool0 : 4;
    /* numrtids_isoc_pool0 - Bits[3:0], RW_LB, default = 4'b0000 
       Limits the number of RTIDs used for VC1/VCp/VCm isoch by HA pool 0. BIOS 
       programs value into this register based on SKU. 
       An encoding of 0 in either numrtids_isoc_pool0 or numrtids_isoc_pool1 disables 
       IIO isoch RTID allocation (useful for VCm in non-isoch systems or for debug). 
       12-15 are illegal values for this register.
     */
    UINT32 numrtids_isoc_pool1 : 4;
    /* numrtids_isoc_pool1 - Bits[7:4], RW_LB, default = 4'b0000 
       Limits the number of RTIDs used for VC1/VCp/VCm isoch by HA pool 1. BIOS 
       programs value into this register based on SKU. 
       An encoding of 0 in either numrtids_isoc_pool0 or numrtids_isoc_pool1 disables 
       IIO isoch RTID allocation (useful for VCm in non-isoch systems or for debug). 
       12-15 are illegal values for this register.
     */
    UINT32 diswrcomb : 1;
    /* diswrcomb - Bits[8:8], RW, default = 1'b0 
       Disables wr->wr, rd->rd, and rd->wr transfers. This bit is a don't-care if 
       rd_merge_enable==1. 
       Setting diswrcomb==1 and rd_merge_enable==0 disables all entry to entry 
       transfers in IRP (causing a Cbo request for every switch request). 
     */
    UINT32 vc1_pri_en : 1;
    /* vc1_pri_en - Bits[9:9], RW_LB, default = 1'b1 
       Give VC1/m transactions high priority in IRP and set pri=3 when issuing VC1/m 
       transactions to the ring. 
     */
    UINT32 vcp_pri_en : 1;
    /* vcp_pri_en - Bits[10:10], RW_LB, default = 1'b1 
       Give VCp transactions high priority in IRP and set pri=3 when issuing VCp 
       transactions to the ring. 
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dcaen : 1;
    /* dcaen - Bits[12:12], RW_LB, default = 1'b0 
       When clear, PrefetchHint will not be sent on the coherent interface.
       The CIPDCASAD table is programmed by BIOS and this bit is set when the table is 
       valid. 
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rd_merge_enable : 1;
    /* rd_merge_enable - Bits[15:15], RW, default = 1'b1 
       Enables all entry to entry transfer flows in IRP (those enabled by ~diswrcomb, 
       plus wr->rd). 
     */
    UINT32 rsvd_16 : 12;
    /* rsvd_16 - Bits[27:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 diswrupdtflow : 1;
    /* diswrupdtflow - Bits[28:28], RW, default = 1'b0 
       When set, PCIWriteUpdate command is never issued on IDI and the writes that 
       triggered this flow would be treated as 'normal' writes and the rules 
       corresponding to the 'normal writes' apply. 
     */
    UINT32 rsvd_29 : 1;
    /* rsvd_29 - Bits[29:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 adr_snapshot_req : 1;
    /* adr_snapshot_req - Bits[30:30], RW, default = 1'b0 
       Whenever this bit is written to 1, this implies wr$ snapshot request was due to 
       ADR. This is a status indication and does not cause the snapshot to occur. 
     */
    UINT32 flushpendwr : 1;
    /* flushpendwr - Bits[31:31], RW, default = 1'b0 
       Whenever this bit is written to 1 (regardless what the current value of this bit 
       is), IRP block first clears bit 0 in CIPSTS register and takes a snapshot of the 
       currently pending write transactions to dram in Write Cache, wait for them to 
       complete fully (i.e. deallocate the corresponding Write Cache/RRB entry) and 
       then set bit 0 in CIPSTS register. 
     */
  } Bits;
  UINT32 Data;
} CIPCTRL_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* CIPSTS_IIO_VTD_REG supported on:                                           */
/*       IVT_EP (0x40028144)                                                  */
/*       IVT_EX (0x40028144)                                                  */
/*       HSX (0x40028144)                                                     */
/*       BDX (0x40028144)                                                     */
/* Register default value:              0x00000006                            */
#define CIPSTS_IIO_VTD_REG 0x09004144
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Coherent Interface Protocol Status.
 */
typedef union {
  struct {
    UINT32 flush_pending_writes : 1;
    /* flush_pending_writes - Bits[0:0], RO_V, default = 1'b0 
       This bit gets cleared whenever bit 31 in CPICTRL is written to 1 by software and 
       gets set by h/w when the pending writes in the Write Cache (at the time bit 31 
       in CIPCTRL is written to 1 by software) complete i.e. the Write Cache/RRB entry 
       is deallocated for all those writes. 
     */
    UINT32 rrb_empty : 1;
    /* rrb_empty - Bits[1:1], RO_V, default = 1'b1 
       This indicates that there are no pending requests in the RRB.0 - Pending RRB 
       requests 
       1 - RRB Empty
       This is a live bit and hence can toggle clock by clock. This is provided mostly 
       as a debug visibility feature. 
     */
    UINT32 rrb_non_phold_arb_empty : 1;
    /* rrb_non_phold_arb_empty - Bits[2:2], RO_V, default = 1'b1 
       This indicates that there are no pending requests in the RRB with the exception 
       of ProcLock/Unlock* messages to the lock arbiter. 
       0 - Pending RRB requests
       1 - RRB Empty except for any pending Proclock* /Unlock
       This is a live bit and hence can toggle clock by clock. This is provided mostly 
       as a debug visibility feature. 
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CIPSTS_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* CIPDCASAD_IIO_VTD_REG supported on:                                        */
/*       IVT_EP (0x40028148)                                                  */
/*       IVT_EX (0x40028148)                                                  */
/*       HSX (0x40028148)                                                     */
/*       BDX (0x40028148)                                                     */
/* Register default value:              0x00000000                            */
#define CIPDCASAD_IIO_VTD_REG 0x09004148


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x148
 */
typedef union {
  struct {
    UINT32 dcalt0 : 4;
    /* dcalt0 - Bits[3:0], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 0. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt1 : 4;
    /* dcalt1 - Bits[7:4], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 1. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt2 : 4;
    /* dcalt2 - Bits[11:8], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 2. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt3 : 4;
    /* dcalt3 - Bits[15:12], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 3. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt4 : 4;
    /* dcalt4 - Bits[19:16], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 4. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt5 : 4;
    /* dcalt5 - Bits[23:20], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 5. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt6 : 4;
    /* dcalt6 - Bits[27:24], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 6. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt7 : 4;
    /* dcalt7 - Bits[31:28], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 7. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
  } Bits;
  UINT32 Data;
} CIPDCASAD_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* CIPINTRC_IIO_VTD_REG supported on:                                         */
/*       HSX (0x4002814C)                                                     */
/*       BDX (0x4002814C)                                                     */
/* Register default value:              0x00003F00                            */
#define CIPINTRC_IIO_VTD_REG 0x0900414C

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Coherent Interface Protocol Interrupt Control.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    UINT32 logical : 1;
    /* logical - Bits[1:1], RW, default = 1'b0  */
    UINT32 rsvd_2 : 5;
    /* rsvd_2 - Bits[6:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_7 : 1;
    UINT32 nmi_mask : 1;
    /* nmi_mask - Bits[8:8], RW, default = 1'b1 
       NMI Mask
     */
    UINT32 init_mask : 1;
    /* init_mask - Bits[9:9], RW, default = 1'b1 
       INIT Mask
     */
    UINT32 smi_mask : 1;
    /* smi_mask - Bits[10:10], RW, default = 1'b1 
       SMI Mask
     */
    UINT32 intr_mask : 1;
    /* intr_mask - Bits[11:11], RW, default = 1'b1 
       INTR Mask
     */
    UINT32 rsvd_12 : 4;
    UINT32 nmi_msi_en : 1;
    /* nmi_msi_en - Bits[16:16], RW, default = 1'b0 
       NMI MSI Enable
     */
    UINT32 init_msi_en : 1;
    /* init_msi_en - Bits[17:17], RW, default = 1'b0 
       INIT MSI Enable
     */
    UINT32 smi_msi_en : 1;
    /* smi_msi_en - Bits[18:18], RW, default = 1'b0 
       SMI MSI Enable
     */
    UINT32 rsvd_19 : 5;
    /* rsvd_19 - Bits[23:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 route_nmi2mca : 1;
    /* route_nmi2mca - Bits[24:24], RW, default = 1'b0 
       Route NMI to MCA
     */
    UINT32 dis_intx_route2ich : 1;
    /* dis_intx_route2ich - Bits[25:25], RW, default = 1'b0 
       Disable INTx Route to PCH
     */
    UINT32 rsvd_26 : 6;
    /* rsvd_26 - Bits[31:26], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CIPINTRC_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* CIPINTRS_IIO_VTD_REG supported on:                                         */
/*       IVT_EP (0x40028154)                                                  */
/*       IVT_EX (0x40028154)                                                  */
/*       HSX (0x40028154)                                                     */
/*       BDX (0x40028154)                                                     */
/* Register default value:              0x00000000                            */
#define CIPINTRS_IIO_VTD_REG 0x09004154
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * This register is to be polled by BIOS to determine if internal pending system 
 * interrupts are drained out of IIO. General usage model is for software to 
 * quiesce the source (e.g. IOM global error logic) of a system event like SMI, 
 * then poll this register till this register indicates that the event is not 
 * pending inside IIO. One additional read is required from software, after the 
 * register first reads 0 for the associated event.end_description: 
 */
typedef union {
  struct {
    UINT32 vlw_msgpend : 1;
    /* vlw_msgpend - Bits[0:0], RO_V, default = 1'b0 
       VLW Message Pending (either generated internally or externally)
     */
    UINT32 nmi_evt_pending : 1;
    /* nmi_evt_pending - Bits[1:1], RO_V, default = 1'b0 
       NMI Event Pending
     */
    UINT32 init_evt_pending : 1;
    /* init_evt_pending - Bits[2:2], RO_V, default = 1'b0 
       INIT Event Pending
     */
    UINT32 rsvd_3 : 1;
    UINT32 intr_evt_pending : 1;
    /* intr_evt_pending - Bits[4:4], RO_V, default = 1'b0 
       INTR Event Pending
     */
    UINT32 smi_ras_evt_pending : 1;
    /* smi_ras_evt_pending - Bits[5:5], RO_V, default = 1'b0 
       SMI RAS Event Pending
     */
    UINT32 nmi_ras_evt_pending : 1;
    /* nmi_ras_evt_pending - Bits[6:6], RO_V, default = 1'b0 
       NMI RAS Event Pending
     */
    UINT32 mca_ras_evt_pending : 1;
    /* mca_ras_evt_pending - Bits[7:7], RO_V, default = 1'b0 
       MCA RAS Event Pending
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[29:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nmi : 1;
    /* nmi - Bits[30:30], RW1CS, default = 1'b0 
       This is set whenever IIO forwards a VLW from PCH that had the NMI bit assserted.
     */
    UINT32 smi : 1;
    /* smi - Bits[31:31], RW1CS, default = 1'b0 
       This is set whenever IIO forwards a VLW from PCH that had the SMI bit assserted.
     */
  } Bits;
  UINT32 Data;
} CIPINTRS_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* VTBAR_IIO_VTD_REG supported on:                                            */
/*       IVT_EP (0x40028180)                                                  */
/*       IVT_EX (0x40028180)                                                  */
/*       HSX (0x40028180)                                                     */
/*       BDX (0x40028180)                                                     */
/* Register default value:              0x00000000                            */
#define VTBAR_IIO_VTD_REG 0x09004180
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x180
 */
typedef union {
  struct {
    UINT32 vtd_chipset_base_address_enable : 1;
    /* vtd_chipset_base_address_enable - Bits[0:0], RW_LB, default = 1'b0 
       Note that accesses to registers pointed to by VTBAR are accessible via message 
       channel or JTAG mini-port, irrespective of the setting of this enable bit i.e. 
       even if this bit is clear, read/write to VT-d registers are completed normally 
       (writes update registers and reads return the value of the register) for 
       accesses from message channel or JTAG mini-port. 
       
       This bit is RW-LB (i.e. lock is determined based on the 'trusted' bit in message 
       channel) when VTGENCTRL.lockvtd is clear, else it is RO. 
     */
    UINT32 rsvd : 12;
    /* rsvd - Bits[12:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtd_chipset_base_address : 19;
    /* vtd_chipset_base_address - Bits[31:13], RW_LB, default = 19'b0000000000000000000 
       Provides an aligned 8K base address for IIO registers relating to VT-d. All 
       inbound accesses to this region are completer aborted by the IIO. 
     */
  } Bits;
  UINT32 Data;
} VTBAR_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* VTGENCTRL_IIO_VTD_REG supported on:                                        */
/*       IVT_EP (0x20028184)                                                  */
/*       IVT_EX (0x20028184)                                                  */
/*       HSX (0x40028184)                                                     */
/*       BDX (0x40028184)                                                     */
/* Register default value on IVT_EP:    0x00A8                                */
/* Register default value on IVT_EX:    0x00A8                                */
/* Register default value on HSX:       0x007000A8                            */
/* Register default value on BDX:       0x007000A8                            */
#define VTGENCTRL_IIO_VTD_REG 0x0900C000


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x184
 */
typedef union {
  struct {
    UINT32 gpa_limit : 4;
    /* gpa_limit - Bits[3:0], RW_LB, default = 4'b1000 
       Represents the guest virtual addressing limit for the non-Isoch VT-d engine.
       
       0000: 2^40 (i.e. bits 39:0)
       0001: 2^41 (i.e. bits 40:0)
       ..
       0111: 2^47
       1000: 2^48
       Others: Reserved
       
       When VT-d translation is enabled, all incoming guest addresses from PCI Express, 
       associated with the non-isoch VT-d engine, that go beyond the limit specified in 
       this register will be aborted by IIO and a UR response returned. This register 
       is not used when translation is not enabled. Note that 'translated' and 
       'pass-through' addresses are in the 'host-addressing' domain and NOT 
       'guest-addressing' domain and hence GPA_LIMIT checking on those accesses are 
       bypassed and instead HPA_LIMIT checking applies. 
     */
    UINT32 hpa_limit : 4;
    /* hpa_limit - Bits[7:4], RW_LB, default = 4'b1010 
       Represents the host processor addressing limit
       
       0000: 2^36 (i.e. bits 35:0)
       0001: 2^37 (i.e. bits 36:0)
       ...
       1010: 2^46 (i.e. bits 45:0)
       
       When VT-d translation is enabled on a VT-d engine (isoch or non-isoch), all host 
       addresses (during page walks) that go beyond the limit specified in this 
       register will be aborted by IIO. Note that pass-through and 'translated' ATS 
       accesses carry the host-address directly in the access and are subject to this 
       check as well. 
     */
    UINT32 rsvd_8 : 7;
    /* rsvd_8 - Bits[14:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lockvtd : 1;
    /* lockvtd - Bits[15:15], RW_O, default = 1'b0 
       When this bit is 0, VTBAR.vtd_chipset_base_address_enable is RW-LB, else it is 
       RO. 
     */
    UINT32 rsvd_16 : 7;
    UINT32 reset_pf_miss_ctr : 1;
    /* reset_pf_miss_ctr - Bits[23:23], WO_L, default = 1'b0 
       One-shot bit to reset the counter used by VTDGENCTRL2.tlb_p_np_pf_limit to track 
       prefetches that missed the TLB. 
       This is LT-locked, but wo-lb is not supported in crgen.
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VTGENCTRL_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* VTISOCHCTRL_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x40028188)                                                  */
/*       IVT_EX (0x40028188)                                                  */
/*       HSX (0x40028188)                                                     */
/*       BDX (0x40028188)                                                     */
/* Register default value:              0x00000001                            */
#define VTISOCHCTRL_IIO_VTD_REG 0x09004188
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x188
 */
typedef union {
  struct {
    UINT32 azaliausenonisochvtd : 1;
    /* azaliausenonisochvtd - Bits[0:0], RW_LB, default = 1'b1 
       When set, causes Azalia traffic to use the Non-Isoch VTd engine
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 numisochl1entries : 3;
    /* numisochl1entries - Bits[4:2], RW_LB, default = 3'b000 
       000: 16 entries (when ISOCH is enabled only)
       001: 1 entry
       010: 2 entries
       011: 4 entries
       100: 8 entries
       101: 16 entries
       Others: Reserved
     */
    UINT32 nel3 : 3;
    /* nel3 - Bits[7:5], RW_LB, default = 3'b000 
       Number of Isoch L3 entries reserved for Azalia and non-Azalia VCp.
       
       USB VCp would use these reseved entries only when Isoch enginve is enabled and 
       USB VCP is set to take High priority switch path. 
       
       000: 16 entries when Isoch engine is enabled.
       001: 1 entry
       010: 2 entries
       011: 4 entries
       100: 8 entries
       101: 16 entries
       Others: Reserved
     */
    UINT32 azalia_on_vcp : 1;
    /* azalia_on_vcp - Bits[8:8], RW_LB, default = 1'b0 
       1: all VCp traffic uses the Azalia optimizations in VTd pagewalk request.
       0: non-Azalia VCp traffic uses VC0 channel for VTd pagewalk request.
       
       This bit should be set whenever Azalia traffic is sharing VCp with non-Azalia 
       rather than running on VC1 to avoid and non-Azalia to Azalia dependencies that 
       can crop up when Azalia traffic is also on VCp. 
       
       When this bit is cleared, VC0 can block non-Azalia VCp traffic. If Azalia 
       traffic is running on VCp, then VCp traffic can block Azalia. Therefore VC0 can 
       block Azalia traffic. 
       
       Azalia traffic will always use the optimizations regardless of the value of this 
       bit. This bit makes it is possible to allow non-Azalia VCp to also use the 
       Azalia optimizations. 
     */
    UINT32 rsvd_9 : 23;
    /* rsvd_9 - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VTISOCHCTRL_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* VTGENCTRL2_IIO_VTD_REG supported on:                                       */
/*       IVT_EP (0x4002818C)                                                  */
/*       IVT_EX (0x4002818C)                                                  */
/*       HSX (0x4002818C)                                                     */
/*       BDX (0x4002818C)                                                     */
/* Register default value on IVT_EP:    0x002803A0                            */
/* Register default value on IVT_EX:    0x002803A0                            */
/* Register default value on HSX:       0x003883A0                            */
/* Register default value on BDX:       0x003883A0                            */
#define VTGENCTRL2_IIO_VTD_REG 0x0900418C


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * Intel VT-d General Control 2.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dontevictleafat01 : 1;
    /* dontevictleafat01 - Bits[1:1], RW_LB, default = 1'b0 
       Don not mark leaf entries with U=0 on translation requests with AT=01 for early 
       eviction 
     */
    UINT32 evictnonleafat01 : 1;
    /* evictnonleafat01 - Bits[2:2], RW_LB, default = 1'b0 
       Mark non-leaf entries on translation requests with AT=01 for early eviction
     */
    UINT32 ignoreubitleafeviction : 1;
    /* ignoreubitleafeviction - Bits[3:3], RW_LB, default = 1'b0 
       Don not use U bit in leaf entry for leaf eviction policy on untranslated DMA 
       requests (AT=00b) 
     */
    UINT32 rsvd_4 : 1;
    /* rsvd_4 - Bits[4:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_5 : 2;
    UINT32 lt : 4;
    /* lt - Bits[10:7], RW_LB, default = 4'b0111 
       Controls the rate at which the LRU buckets should degrade.
       If we are in "Cycles" mode (LRUCTRL = 0), then we will degrade LRU after 256 * N 
       requests where N is the value of this field. 
       If we are in "Request" mode (CRUCTRL = 1), then we will degrade LRU after 16 * N 
       cycles where N is the value of this field. 
       The default value of 0x7 (along with LRUCTRL=0) will give us a default behavior 
       of decreasing the LRU buckets every 112 requests. 
     */
    UINT32 lructrl : 1;
    /* lructrl - Bits[11:11], RW_LB, default = 1'b0 
       Controls what increments the LRU counter that is used to degrade the LRU bits in 
       the IOTLB, L1/L2, and L3 caches. 
       0: Count Cycles (same as TB)
       1: Count Requests
     */
    UINT32 tlb_free_entry_limit : 7;
    /* tlb_free_entry_limit - Bits[18:12], RW_LB, default = 7'b0001000 
       Retry prefetch request when number of entries available for allocation in the 
       IOTLB is less than the programmed value. Set this to 0 to disable it. 
     */
    UINT32 rsvd_19 : 2;
    UINT32 en_lock_rsvd_ent : 1;
    /* en_lock_rsvd_ent - Bits[21:21], RW_L, default = 1'b1 
       Chicken bit to enable a dedicated P F TLB entry for an agent under lock.
       Recommended BIOS setting: 1
       EDS visibility: No
     */
    UINT32 rsvd_22 : 10;
  } Bits;
  UINT32 Data;
} VTGENCTRL2_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* VTGENCTRL3_IIO_VTD_REG supported on:                                       */
/*       HSX (0x40028190)                                                     */
/*       BDX (0x40028190)                                                     */
/* Register default value:              0x00010000                            */
#define VTGENCTRL3_IIO_VTD_REG 0x09004190

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x190
 */
typedef union {
  struct {
    UINT32 en_agt_rsvd_p_f_ent_tlb0 : 7;
    /* en_agt_rsvd_p_f_ent_tlb0 - Bits[6:0], RW_L, default = 7'b0000000 
       Enable a reserved TLB entry for P F RFTs from the given agent. FW may need to 
       enable this on a problematic port (card with an illegal P->P dependency). 
       Mapping:
       0 -> d2f0
       1 -> d2f1
       2 -> d2f2
       3 -> d2f3
       4 -> IOAPIC
       5 -> CBDMA
       6 -> ME (unused)
       Recommended BIOS setting: 0
       EDS visibility: No
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en_agt_rsvd_p_f_ent_tlb1 : 9;
    /* en_agt_rsvd_p_f_ent_tlb1 - Bits[16:8], RW_L, default = 9'b100000000 
       Enable a reserved TLB entry for P F RFTs from the given agent. FW may need to 
       enable this on a problematic port (card with an illegal P->P dependency). 
       Mapping:
       0 -> d3f0
       1 -> d3f1
       2 -> d3f2
       3 -> d3f3
       4 -> d1f0
       5 -> d1f1
       6 -> d0f0 VC0
       7 -> d0f0 VC1
       8 -> d0f0 VCp
       Recommended BIOS setting: 0x100
       EDS visibility: No
     */
    UINT32 rsvd_17 : 15;
    /* rsvd_17 - Bits[31:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VTGENCTRL3_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */


/* IOTLBPARTITION_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x40028194)                                                  */
/*       IVT_EX (0x40028194)                                                  */
/*       HSX (0x40028194)                                                     */
/*       BDX (0x40028194)                                                     */
/* Register default value:              0x00000000                            */
#define IOTLBPARTITION_IIO_VTD_REG 0x09004194
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * IOTLB Partitioning Control.
 */
typedef union {
  struct {
    UINT32 iotlb_parten : 1;
    /* iotlb_parten - Bits[0:0], RW_LB, default = 1'b0 
       IOTLB Partitioning Enable
       0: Disabled
       1: Enabled
     */
    UINT32 rsvd_1 : 8;
    /* rsvd_1 - Bits[8:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rangesel_intr : 2;
    /* rangesel_intr - Bits[10:9], RW, default = 2'b00 
       Range Selection for INTR
     */
    UINT32 rangesel_cb : 2;
    /* rangesel_cb - Bits[12:11], RW, default = 2'b00 
       Range Selection for Intel QuickData Technology.
     */
    UINT32 rangesel_me : 2;
    /* rangesel_me - Bits[14:13], RW, default = 2'b00 
       Range Selection for ME
     */
    UINT32 rsvd_15 : 8;
    /* rsvd_15 - Bits[22:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rangesel_iou23_upper_x2 : 2;
    /* rangesel_iou23_upper_x2 - Bits[24:23], RW, default = 2'b00 
       Range Selection for IOU23 upper X2 link
     */
    UINT32 rangesel_iou24_upper_x2 : 2;
    /* rangesel_iou24_upper_x2 - Bits[26:25], RW, default = 2'b00 
       Range Selection for IOU24 upper X2 link
     */
    UINT32 rangesel_dmi_20_22 : 2;
    /* rangesel_dmi_20_22 - Bits[28:27], RW, default = 2'b00 
       Range Selection for DMI[20:22]
     */
    UINT32 rsvd_29 : 3;
    /* rsvd_29 - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IOTLBPARTITION_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* VTUNCERRSTS_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x400281A8)                                                  */
/*       IVT_EX (0x400281A8)                                                  */
/*       HSX (0x400281A8)                                                     */
/*       BDX (0x400281A8)                                                     */
/* Register default value:              0x00000000                            */
#define VTUNCERRSTS_IIO_VTD_REG 0x090041A8


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * Intel VT-d Uncorrectable Error Status.
 */
typedef union {
  struct {
    UINT32 perr_context_cache : 1;
    /* perr_context_cache - Bits[0:0], RW1CS, default = 1'b0 
       Data Parity error while doing a context cache lookup status.
     */
    UINT32 perr_l2_lookup : 1;
    /* perr_l2_lookup - Bits[1:1], RW1CS, default = 1'b0 
       Data Parity error while doing a L2 lookup status.
       Note the mapping of this register field varies over the mapping in vtuncerrmsk 
       and vtuncerrsev. 
     */
    UINT32 perr_l1_lookup : 1;
    /* perr_l1_lookup - Bits[2:2], RW1CS, default = 1'b0 
       Data Parity error while doing a L1 lookup status.
       Note the mapping of this register field varies over the mapping in vtuncerrmsk 
       and vtuncerrsev. 
     */
    UINT32 perr_l3_lookup : 1;
    /* perr_l3_lookup - Bits[3:3], RW1CS, default = 1'b0 
       Data Parity error while doing a L3 lookup status.
     */
    UINT32 perr_tlb0 : 1;
    /* perr_tlb0 - Bits[4:4], RW1CS, default = 1'b0 
       TLB0 Parity Error Status.
     */
    UINT32 perr_tlb1 : 1;
    /* perr_tlb1 - Bits[5:5], RW1CS, default = 1'b0 
       TLB1 Parity Error Status.
     */
    UINT32 unsucc_ci_rdcp : 1;
    /* unsucc_ci_rdcp - Bits[6:6], RW1CS, default = 1'b0 
       Unsuccessful status received in the coherent interface read completion status.
     */
    UINT32 miscerrs : 1;
    /* miscerrs - Bits[7:7], RW1CS, default = 1'b0 
       This error bit is set:
       1. When TE is off DMA/INTR request has AT set to nonzero value.
       2. When TE is on is set to 1:
       a. The DMA read request is in interrupt address range 0XFEE.
       b. The DMA request is a translated write request(AT=10)
       
     */
    UINT32 protmemviol : 1;
    /* protmemviol - Bits[8:8], RW1CS, default = 1'b0 
       Protected memory region space violated status
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[30:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtderr : 1;
    /* vtderr - Bits[31:31], RW1CS, default = 1'b0 
       When set, this bit is set when a VT-d spec defined error has been detected (and 
       logged in the VT-d fault registers) 
     */
  } Bits;
  UINT32 Data;
} VTUNCERRSTS_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* VTUNCERRMSK_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x400281AC)                                                  */
/*       IVT_EX (0x400281AC)                                                  */
/*       HSX (0x400281AC)                                                     */
/*       BDX (0x400281AC)                                                     */
/* Register default value:              0x80000000                            */
#define VTUNCERRMSK_IIO_VTD_REG 0x090041AC
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Intel VT-d Uncorrectable Error Mask.
 * Mask out error reporting to IIO.  Bit [31] should always be set to 1.  We 
 * recommend that the other bits be left as zero so these internal errors are 
 * reported out. 
 * 
 * Setting bits will not prevent any error collecting inside of VTd (in the VTd 
 * Fault Recording Registers).   
 */
typedef union {
  struct {
    UINT32 perr_context_cache_msk : 1;
    /* perr_context_cache_msk - Bits[0:0], RWS, default = 1'b0 
       Data Parity error while doing a context cache lookup mask.
     */
    UINT32 perr_l1_lookup_msk : 1;
    /* perr_l1_lookup_msk - Bits[1:1], RWS, default = 1'b0 
       Data Parity error while doing a L1 lookup mask
     */
    UINT32 perr_l2_lookup_msk : 1;
    /* perr_l2_lookup_msk - Bits[2:2], RWS, default = 1'b0 
       Data Parity error while doing a L2 lookup mask
     */
    UINT32 perr_l3_lookup_msk : 1;
    /* perr_l3_lookup_msk - Bits[3:3], RWS, default = 1'b0 
       Data Parity error while doing a L3 lookup mask
     */
    UINT32 perr_tlb0_msk : 1;
    /* perr_tlb0_msk - Bits[4:4], RWS, default = 1'b0 
       TLB0 Parity Error mask
     */
    UINT32 perr_tlb1_msk : 1;
    /* perr_tlb1_msk - Bits[5:5], RWS, default = 1'b0 
       TLB1 Parity Error mask
     */
    UINT32 unsucc_ci_rdcp_msk : 1;
    /* unsucc_ci_rdcp_msk - Bits[6:6], RWS, default = 1'b0 
       Unsuccessful status received in the coherent interface read completion mask.
     */
    UINT32 miscerrm : 1;
    /* miscerrm - Bits[7:7], RWS, default = 1'b0 
       miscerrm mask
     */
    UINT32 protmemviol_msk : 1;
    /* protmemviol_msk - Bits[8:8], RWS, default = 1'b0 
       Protected memory region space violated mask
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[30:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtderr_msk : 1;
    /* vtderr_msk - Bits[31:31], RWS, default = 1'b1 
       This bit should be set to 1 by BIOS. It is highly recommended that this bit is 
       never set to 0. 
       
       If VTd errors are configured to be fatal, leaving this bit set to 0 will cause 
       Fatal errors to be reported when devices send illegal requests. This is 
       generally undesireable. 
       
       
     */
  } Bits;
  UINT32 Data;
} VTUNCERRMSK_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* VTUNCERRSEV_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x400281B0)                                                  */
/*       IVT_EX (0x400281B0)                                                  */
/*       HSX (0x400281B0)                                                     */
/*       BDX (0x400281B0)                                                     */
/* Register default value:              0x000001BF                            */
#define VTUNCERRSEV_IIO_VTD_REG 0x090041B0
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Intel VT-d Uncorrectable Error Severity.
 */
typedef union {
  struct {
    UINT32 perr_context_cache_sev : 1;
    /* perr_context_cache_sev - Bits[0:0], RWS, default = 1'b1 
       Data Parity error while doing a context cache lookup severity.
     */
    UINT32 perr_l1_lookup_sev : 1;
    /* perr_l1_lookup_sev - Bits[1:1], RWS, default = 1'b1 
       Data Parity error while doing a L1 lookup severity.
     */
    UINT32 perr_l2_lookup_sev : 1;
    /* perr_l2_lookup_sev - Bits[2:2], RWS, default = 1'b1 
       Data Parity error while doing a L2 lookup severity.
     */
    UINT32 perr_l3_lookup_sev : 1;
    /* perr_l3_lookup_sev - Bits[3:3], RWS, default = 1'b1 
       Data Parity error while doing a L3 lookup severity.
     */
    UINT32 perr_tlb0_sev : 1;
    /* perr_tlb0_sev - Bits[4:4], RWS, default = 1'b1 
       TLB1 Parity Error severity.
     */
    UINT32 perr_tlb1_sev : 1;
    /* perr_tlb1_sev - Bits[5:5], RWS, default = 1'b1 
       TLB1 Parity Error severity.
     */
    UINT32 unsucc_ci_rdcp_sev : 1;
    /* unsucc_ci_rdcp_sev - Bits[6:6], RWS, default = 1'b0 
       Unsuccessful status received in the coherent interface read completion severity.
     */
    UINT32 miscerrsev : 1;
    /* miscerrsev - Bits[7:7], RWS, default = 1'b1 
       miscerrsev severity.
     */
    UINT32 protmemviol_sev : 1;
    /* protmemviol_sev - Bits[8:8], RWS, default = 1'b1 
       Protected memory region space violated severity.
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[30:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtderr_sev : 1;
    /* vtderr_sev - Bits[31:31], RWS, default = 1'b0 
       When set, this bit escalates reporting of VT-d spec defined errors, as FATAL 
       errors. When clear, those errors are escalated as Nonfatal errors. 
       
       Setting this bit to a 1 can allow a guest VM to trigger an unrecoverable FATAL 
       error at the platform. It is HIGHLY recommended that BIOS keep this bit set to 
       0, as such behavior is generally undesirable. 
     */
  } Bits;
  UINT32 Data;
} VTUNCERRSEV_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* VTUNCERRPTR_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x100281B4)                                                  */
/*       IVT_EX (0x100281B4)                                                  */
/*       HSX (0x100281B4)                                                     */
/*       BDX (0x100281B4)                                                     */
/* Register default value:              0x00                                  */
#define VTUNCERRPTR_IIO_VTD_REG 0x090011B4
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Intel VT-d Uncorrectable Error Pointer.
 */
typedef union {
  struct {
    UINT8 vt_uncferr_ptr : 5;
    /* vt_uncferr_ptr - Bits[4:0], ROS_V, default = 5'b00000 
       This field points to which of the unmasked uncorrectable errors happened first. 
       This field is only valid when the corresponding error is unmasked and the status 
       bit is set and this field is rearmed to load again when the status bit indicated 
       to by this pointer is cleared by software from 1 to 0. 
       
       Value of 0x0 corresponds to bit 0 in VTUNCERRSTS register, value of 0x1 
       corresponds to bit 1 etc. 
     */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} VTUNCERRPTR_IIO_VTD_STRUCT;
#endif /* ASM_INC */


/* IIOMISCCTRL_N0_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x400281C0)                                                  */
/*       IVT_EX (0x400281C0)                                                  */
/*       HSX (0x400281C0)                                                     */
/*       BDX (0x400281C0)                                                     */
/* Register default value:              0x42050270                            */
#define IIOMISCCTRL_N0_IIO_VTD_REG 0x090041C0


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * IIO MISC Control.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    UINT32 uniphy_disable : 1;
    /* uniphy_disable - Bits[1:1], RWS_O, default = 1'b0 
       Place entire UNIPHY in L2 (for when no ports are used, as in some multi-socket 
       configurations) 
     */
    UINT32 en1k : 1;
    /* en1k - Bits[2:2], RW, default = 1'b0 
       This bit when set, enables 1K granularity for I/O space decode in each of the 
       virtual P2P bridges corresponding to root ports, and DMI ports. 
     */
    UINT32 tocm : 5;
    /* tocm - Bits[7:3], RW, default = 5'b01110 
       Indicates the top of Core physical addressability limit.
       
       00000-00100: Reserved
       00101: 2^37
       00110: 2^38
       ...
       1110: 2^46
       01111 -11111: Reserved
       
       iio uses this to abort all inbound transactions that cross this limit.
     */
    UINT32 tocmvalid : 1;
    /* tocmvalid - Bits[8:8], RW, default = 1'b0 
       Enables the TOCM field.
     */
    UINT32 azalia_on_vcp : 1;
    /* azalia_on_vcp - Bits[9:9], RW, default = 1'b1 
       This bit indicates whether Isoch Azalia traffic from PCH will use the VCp 
       channel or the VC1 channel. It is used to optimized isoch traffic flow. 
       
       0: Isoch Azalia traffic optimized for VC1 - only VC1 traffic will use the low 
       latency paths 
       1: Isoch Azalia traffic optimized for VCp - VC1 and VCp will use the low latency 
       paths 
     */
    UINT32 rsvd_10 : 1;
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_12 : 3;
    UINT32 dmi_vc1_vt_d_fetch_ordering : 1;
    /* dmi_vc1_vt_d_fetch_ordering - Bits[15:15], RW, default = 1'b0 
       This mode is to allow VC1 VT-d conflicts with outstanding VC0 VT-d reads on IDI 
       to be pipelined. This can occur when VT-d tables are shared between Azalia (VC1) 
       and other devices. To ensure QoS the VT-d reads from VC1 need to be issued in 
       parallel with non-Isoc accesses to the same cacheline. 
       
       0: Serialize all IDI address conflicts to DRAM
       1: Pipeline VT-d reads from VC1 with address conflict on IDI
       
       Notes:
       A maximum of 1 VC1 VT-d read and 1 non-VC1 VT-d read to the same address can be 
       outstanding on IDI. 
     */
    UINT32 rsvd_16 : 3;
    UINT32 rvgaen : 1;
    /* rvgaen - Bits[19:19], RW, default = 1'b0 
       Remote VGA EnableEnables VGA accesses to be sent to remote node.
       If set, accesses to the VGA region (A_0000 to B_FFFF) will be forwarded to the 
       CBo where it will determine the node ID where the VGA region resides. It will 
       then be forwarded to the given remote node. 
       If clear, then VGA accesses will be forwarded to the local PCIe port that has 
       it's VGAEN set. If none have their VGAEN set, then the request will be forwarded 
       to the local DMI port, if operating in DMI mode. If it is not operating in DMI 
       mode, then the request will be aborted. 
     */
    UINT32 switch_arbitration_weight_for_cb_dma : 1;
    /* switch_arbitration_weight_for_cb_dma - Bits[20:20], RW, default = 1'b0 
       It is recommended that this bit never be set.
     */
    UINT32 rsvd_21 : 1;
    /* rsvd_21 - Bits[21:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_22 : 2;
    UINT32 disable_all_allocating_flows : 1;
    /* disable_all_allocating_flows - Bits[24:24], RW, default = 1'b0 
       When this bit is set, IIO will not issue any new inbound IDI command that can 
       allocate into LLC. Instead, all the writes will use one of the non-allocating 
       commands - PCIWiL/PCIWiLF/PCINSWr/PCINSWrF. 
       Software should set this bit only when no requests are being actively issued on 
       IDI. So either a lock/quiesce flow should be employed before this bit is 
       set/cleared or it should be set up before DMA is enabled in system. 
     */
    UINT32 cballocen : 1;
    /* cballocen - Bits[25:25], RWS, default = 1'b1 
       When set, use Allocating Flows for non-DCA writes from Intel QuickData 
       Technology DMA. This bit does not affect DCA requests when DCA requests are 
       enabled (bit 21 of this register). A DCA request is identified as matching the 
       DCA requestor ID and having a Tag of non-zero. All DCA requests are always 
       allocating, unless they are disabled, or unless all allocating flows are 
       disabled (bit 24). If all allocating flows are disabled, then DCA requests are 
       also disabled. 
       
       BIOS is to leave this bit at default of 1b for all but DMI port.
     */
    UINT32 rsvd_26 : 4;
    /* rsvd_26 - Bits[29:26], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_30 : 1;
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IIOMISCCTRL_N0_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* IIOMISCCTRL_N1_IIO_VTD_REG supported on:                                   */
/*       IVT_EP (0x400281C4)                                                  */
/*       IVT_EX (0x400281C4)                                                  */
/*       HSX (0x400281C4)                                                     */
/*       BDX (0x400281C4)                                                     */
/* Register default value:              0x00000040                            */
#define IIOMISCCTRL_N1_IIO_VTD_REG 0x090041C4


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * IIO MISC Control.
 */
typedef union {
  struct {
    UINT32 showportid : 1;
    /* showportid - Bits[0:0], RWS, default = 1'b0 
       When set, this allows IIO to capture port information for internal debug usage. 
       The port IDs are 4 bit fields in internal format that reflect each of the 11 
       ports and also Intel QuickData Technology and VTd. 
     */
    UINT32 force_6b_mc_group : 1;
    /* force_6b_mc_group - Bits[1:1], RW, default = 1'b0 
       0 = Use 4 bits for Multicast group
       1 = Use 6 bits for Multicast group
     */
    UINT32 rsvd_2 : 3;
    /* rsvd_2 - Bits[4:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisfen : 1;
    /* poisfen - Bits[5:5], RW, default = 1'b0 
       Enables poisoned data received inbound (either inbound posted data or 
       completions for outbound reads that have poisoned data) to be forwarded to the 
       destination (DRAM or Cache or PCIe Peer). 
       
       0: Poison indication is not forwarded with the data
       (this may result in silent corruption if AER poison reporting is disabled).
       1: Poison indication is forwarded with the data
       (this may result in a conflict with MCA poison reporting if AER poison reporting 
       is enabled) 
       
     */
    UINT32 uniphy_en_fuse4_pwrdn : 1;
    /* uniphy_en_fuse4_pwrdn - Bits[6:6], RWS_O, default = 1'b1  */
    UINT32 disable_new_apic_ordering : 1;
    /* disable_new_apic_ordering - Bits[7:7], RW, default = 1'b0 
       TBG found a problem in the IOAPIC block that causes a hang. A fix is provided
       for JKT. When this bit is set, behavior returns to the original behavior.
     */
    UINT32 enable_io_mca : 1;
    /* enable_io_mca - Bits[8:8], RW, default = 1'b0 
       Enable IIO MCA error signaling.
     */
    UINT32 en_poismsg_spec_behavior : 1;
    /* en_poismsg_spec_behavior - Bits[9:9], RW, default = 1'b0 
       For the processor a POISFEN bit forces the poison error to be logged as an 
       Advisory Non-Fatal error. When this bit is set, the poison severity bit can 
       force Fatal behavior regardless of POISFEN. Generally, however, MCA needs to 
       have priority over AER drivers, so this bit default is 0. Note that the PCIe 
       spec requires this bit to be 0. 
       When this bit is clear:
       sev pfen error
       0 0 non-fatal
       0 1 correctable
       1 0 fatal
       1 1 correctable
       
       When this bit is set:
       sev pfen error
       0 0 non-fatal
       0 1 correctable
       1 0 fatal
       1 1 fatal
     */
    UINT32 enable_pcc_eq0_sev1 : 1;
    /* enable_pcc_eq0_sev1 - Bits[10:10], RW_LB, default = 1'b0 
       0: IIO will report severity-1 errors with an encoding of UC=1, PCC=1
       1: IIO will report severity-1 errors with an encoding of UC=1, PCC=0
       Note: BIOS must NOT set the bit to 1.
     */
    UINT32 cb_partial_cohrd_op : 2;
    /* cb_partial_cohrd_op - Bits[12:11], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of CBDMA 
       that need less than 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 cb_full_cohrd_op : 2;
    /* cb_full_cohrd_op - Bits[14:13], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of CBDMA 
       that need all 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 disable_reqid_filter : 1;
    /* disable_reqid_filter - Bits[15:15], RW_O, default = 1'b0  */
    UINT32 rsvd_16 : 16;
    /* rsvd_16 - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IIOMISCCTRL_N1_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* LTDPR_IIO_VTD_REG supported on:                                            */
/*       IVT_EP (0x40028290)                                                  */
/*       IVT_EX (0x40028290)                                                  */
/*       HSX (0x40028290)                                                     */
/*       BDX (0x40028290)                                                     */
/* Register default value:              0x00000000                            */
#define LTDPR_IIO_VTD_REG 0x09004290
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * General Description: This register holds the address and size of the DMA 
 * protected memory region for Intel TXT usage. 
 */
typedef union {
  struct {
    UINT32 lock : 1;
    /* lock - Bits[0:0], RW_O, default = 1'b0 
       Bits 19:0 are locked down in this register when this bit is set.
     */
    UINT32 protregsts : 1;
    /* protregsts - Bits[1:1], RO, default = 1'b0 
       IIO sets this bit when the protection has been enabled in hardware and for all 
       practical purposes this should be immediate. When protection is disabled, then 
       this bit is clear 
     */
    UINT32 commandbit : 1;
    /* commandbit - Bits[2:2], RW_L, default = 1'b0 
       Writing a '1' to this bit will enable protection.
       Writing a '0' to this bit will disable protection.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 size : 8;
    /* size - Bits[11:4], RW_L, default = 8'b00000000 
       This is the size of memory, in MB, that will be protected from DMA accesses. A 
       value of 0x00 in this field means no additional memory is protected. The maximum 
       amount of memory that will be protected is 255 MB. 
       
       The amount of memory reported in this field will be protected from all DMA 
       accesses. The top of the protected range is typically the BASE of TSEG -1. BIOS 
       is expected to program that in to bits 31:20 of this register. 
       
       Notes:
       If TSEG is not enabled, then the top of this range becomes the base ME stolen 
       space, whichever would have been the location of TSEG, assuming it had been 
       enabled. 
       The DPR range works independently of any other range - Generic Protected ranges, 
       TSEG range, VT-d tables, VT-d protection ranges, MMCFG protection range and is 
       done post any VTd translation or Intel TXT checks. Therefore incoming cycles are 
       checked against this range after the VTd translation and faulted if they hit 
       this protected range, even if they passed the VTd translation. 
       All the memory checks are OR'ed with respect to NOT being allowed to go to 
       memory. So if either Generic protection range, DPR, VT-d, TSEG range disallows 
       the cycle, then the cycle is not allowed to go to memory. Or in other words, all 
       the above checks must pass before a cycle is allowed to DRAM. 
       DMA remap engines are allowed to access the DPR region without any faulting. It 
       is always legal for any DMA remap engine to read or write into the DPR region, 
       thus DMA remap accesses must not be checked against the DPR range. 
     */
    UINT32 rsvd_12 : 8;
    /* rsvd_12 - Bits[19:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 topofdpr : 12;
    /* topofdpr - Bits[31:20], RO_V, default = 12'b000000000000 
       Top address + 1 of DPR. This is RO, and it is copied by HW from TSEGBASE[31:20].
     */
  } Bits;
  UINT32 Data;
} LTDPR_IIO_VTD_STRUCT;
#endif /* ASM_INC */






/* CSIPINTRS_IIO_VTD_REG supported on:                                        */
/*       IVT_EP (0x40028450)                                                  */
/*       IVT_EX (0x40028450)                                                  */
/*       HSX (0x40028450)                                                     */
/*       BDX (0x40028450)                                                     */
/* Register default value:              0x00000000                            */
#define CSIPINTRS_IIO_VTD_REG 0x09004450
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x450
 */
typedef union {
  struct {
    UINT32 smi_evt_pend : 1;
    /* smi_evt_pend - Bits[0:0], RO_V, default = 1'b0 
       SMI event interrupt pended.
     */
    UINT32 nmi_evt_pend : 1;
    /* nmi_evt_pend - Bits[1:1], RO_V, default = 1'b0 
       NMI event interrupt pended.
     */
    UINT32 init_evt_pend : 1;
    /* init_evt_pend - Bits[2:2], RO_V, default = 1'b0 
       Init event interrupt pended.
     */
    UINT32 rsvd_3 : 1;
    UINT32 intr_evt_pend : 1;
    /* intr_evt_pend - Bits[4:4], RO_V, default = 1'b0 
       Intr event interrupt pended.
     */
    UINT32 smi_ras_evt_pend : 1;
    /* smi_ras_evt_pend - Bits[5:5], RO_V, default = 1'b0 
       SMI RAS event interrupt pended.
     */
    UINT32 nmi_ras_evt_pend : 1;
    /* nmi_ras_evt_pend - Bits[6:6], RO_V, default = 1'b0 
       NMI RAS event interrupt pended.
     */
    UINT32 mca_ras_evt_pend : 1;
    /* mca_ras_evt_pend - Bits[7:7], RO_V, default = 1'b0 
       MCA event interrupt pended.
     */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CSIPINTRS_IIO_VTD_STRUCT;
#endif /* ASM_INC */












































/* IRP_MISC_DFX0_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x40028800)                                                  */
/*       IVT_EX (0x40028800)                                                  */
/*       HSX (0x40028800)                                                     */
/*       BDX (0x40028800)                                                     */
/* Register default value on IVT_EP:    0x010193E8                            */
/* Register default value on IVT_EX:    0x010193E8                            */
/* Register default value on HSX:       0x02FF3181                            */
/* Register default value on BDX:       0x02FF3181                            */
#define IRP_MISC_DFX0_IIO_VTD_REG 0x09004800


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x800
 */
typedef union {
  struct {
    UINT32 p_pf_snp_rsp_holdoff_cnt : 4;
    /* p_pf_snp_rsp_holdoff_cnt - Bits[3:0], RW_L, default = 4'b0001 
       Controls the amount of time a posted prefetch will wait to respond to a snoop 
       while waiting for its fetch to arrive (in hopes of responding with modified data 
       rather than dumping the prefetch). 
       Encodings:
       0: disabled
       1: something bigger than 0
       2: something bigger than 1
       etc
     */
    UINT32 dis_early_coh_prh_cmplt : 1;
    /* dis_early_coh_prh_cmplt - Bits[4:4], RW_L, default = 1'b0 
       If set, IRP will wait to send the switch a prh_complete for a coherent request 
       until any eviction or transfer is completed (makes coherent behavior match 
       non-snoop and remote P2P). 
     */
    UINT32 lterr_log_dis : 1;
    /* lterr_log_dis - Bits[5:5], RW_L, default = 1'b0 
       Disable error logging for Intel TXT transactions
     */
    UINT32 spare3 : 1;
    /* spare3 - Bits[6:6], RW_L, default = 1'b0  */
    UINT32 check_ltrd_format : 1;
    /* check_ltrd_format - Bits[7:7], RW_L, default = 1'b1 
       does some format checking for Intel TXT transactions
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 check_iocfg_format : 1;
    /* check_iocfg_format - Bits[8:8], RW_L, default = 1'b1 
       does some format checking (address alignment) for io and cfg transactions
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 dis_fp_on_snp_hit : 1;
    /* dis_fp_on_snp_hit - Bits[9:9], RW_L, default = 1'b0 
       If set, IRP will reject fastpath requests that arrive to lines that have been 
       hit by a snoop but are waiting for their fetch. 
     */
    UINT32 dis_snp_go_byp_go_rcvd : 1;
    /* dis_snp_go_byp_go_rcvd - Bits[10:10], RW_L, default = 1'b0 
       If set, IRP will wait for the normal snoop/GO drain time for transactions that 
       have already received their GO (not necessary because the transaction is not 
       waiting for a GO). 
     */
    UINT32 dis_snp_go_byp_nonalloc : 1;
    /* dis_snp_go_byp_nonalloc - Bits[11:11], RW_L, default = 1'b0 
       If set, IRP will wait for the normal snoop/GO drain time for non-allocating 
       writes (not necessary because a non-allocating write is not waiting for a GO if 
       it has valid data). 
     */
    UINT32 snp_go_pulse_cnt : 3;
    /* snp_go_pulse_cnt - Bits[14:12], RW_L, default = 3'b011 
       Period of snoop/GO counter pulse minus 1 (3 means a pulse every 4th cycle).
       WARNING: Setting this to be less than 3 may cause coherence failures.
     */
    UINT32 drop_ncs_with_error : 1;
    /* drop_ncs_with_error - Bits[15:15], RW_L, default = 1'b0 
       Drop outbound NCS messages that have errors in formatting. Do not forward to 
       Switch. This is consistent with JKT behavior. 
     */
    UINT32 ctagentry_avail_mask : 8;
    /* ctagentry_avail_mask - Bits[23:16], RW_LV, default = 8'b11111111 
       This DFX feature will mask out write cache entries in strides of 8. Each bit 
       maps to the 
       relevant write cache entries noted below:
       
       bit0: write cache entries 7 downto 0
       bit1: write cache entries 15 downto 8
       bit2: write cache entries 23 downto 16
       bit3: write cache entries 31 downto 24
       bit4: write cache entries 39 downto 32
       bit5: write cache entries 47 downto 40
       bit6: write cache entries 55 downto 48
       bit7: write cache entries 63 downto 56
       
       where a bit is defined as:
       
       '0': Mask out write cache entries
       '1': Don't mask out write cache entries
       
       HW will not allow a write of 0 to this field.
       User must also ensure that the Switch CSIPOOLDFX0/1 CSRs (max_cache_* fields) 
       are programmed 
       accordingly to refect the actual number of write cache entries enabled in IRP, 
       else unknown 
       behavior may result.
       
     */
    UINT32 disable_pciitom : 1;
    /* disable_pciitom - Bits[24:24], RW_L, default = 1'b0 
       If set, IRP will issue RFO instead of PCIItoM for full-line coherent writes.
     */
    UINT32 disregard_posted_ordering : 1;
    /* disregard_posted_ordering - Bits[25:25], RW_L, default = 1'b1 
       Setting this allows writes to be sent in any random order. Performance may 
       improve if IRP keeps requests in the order that the switch sent them (since 
       posted ordering limits the order in which writes can be committed, and switch 
       uarch sends completions out in order). 
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 disable_fp_transfer : 1;
    /* disable_fp_transfer - Bits[26:26], RW_L, default = 1'b0 
       If set, IRP will not initiate fastpath transfers from primary to secondary ctag 
       entries. 
     */
    UINT32 disable_pf_ack_hint : 1;
    /* disable_pf_ack_hint - Bits[27:27], RW_L, default = 1'b0 
       If set, IRP will not send early prefetch ack hints from primary to secondary 
       ctag entries. 
     */
    UINT32 disable_early_writeback : 1;
    /* disable_early_writeback - Bits[28:28], RW_L, default = 1'b0 
       If set, IRP will wait to issue the WbMtoI marker on the ring until it has 
       received the data for the write from the switch. 
     */
    UINT32 force_no_snp_on_vc1_vcm : 1;
    /* force_no_snp_on_vc1_vcm - Bits[29:29], RW_L, default = 1'b0 
       This forces VC1/VCm transactions to use non-snoop flows. This needs to be used 
       in conjunction with fastpath disable for VC1/VCm, otherwise the switch will 
       receive an additional prh_done. A better option is 
       tswctl_w.force_no_snp_on_vc1_vcm. 
       per HSX b248868 must be 0
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 enable_parity_err_checking : 1;
    /* enable_parity_err_checking - Bits[30:30], RW_L, default = 1'b0 
       Enables Parity Error Checking in the IRP on the data received from the IIO 
       switch. 
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 disable_pf_ack_bypass_path : 1;
    /* disable_pf_ack_bypass_path - Bits[31:31], RW_L, default = 1'b0 
       A bypass path for the pf_ack reduces latency by 3 cycles. This bit disables the 
       bypass. 
       
       Notes:
       Locked by DBGBUSLCK
     */
  } Bits;
  UINT32 Data;
} IRP_MISC_DFX0_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* IRP_MISC_DFX1_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x40028804)                                                  */
/*       IVT_EX (0x40028804)                                                  */
/*       HSX (0x40028804)                                                     */
/*       BDX (0x40028804)                                                     */
/* Register default value on IVT_EP:    0x2001A802                            */
/* Register default value on IVT_EX:    0x2001A802                            */
/* Register default value on HSX:       0x40C12800                            */
/* Register default value on BDX:       0x80C12800                            */
#define IRP_MISC_DFX1_IIO_VTD_REG 0x09004804


#if defined(HSX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x804
 */
typedef union {
  struct {
    UINT32 dbg_sig_en : 1;
    /* dbg_sig_en - Bits[0:0], RW_L, default = 1'b0 
       enables reading address CAM in unsed cycles
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 dbg_field_sel : 3;
    /* dbg_field_sel - Bits[3:1], RW_L, default = 3'b000 
       Controls which of the 3 debug groups is dumped for each way. Each bit enables a 
       group, can be multi-hot. 
       Locked by DBGBUSLCK
     */
    UINT32 dbg_entry_num_sel : 6;
    /* dbg_entry_num_sel - Bits[9:4], RW_L, default = 6'b000000 
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 cfg_retry_timeout : 2;
    /* cfg_retry_timeout - Bits[11:10], RW_L, default = 2'b10 
       0: 256ms
       1: 4s
       2: disabled
       3: 2us
       
       has a +100% timeout error
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 early_xfer_enable : 1;
    /* early_xfer_enable - Bits[12:12], RW_L, default = 1'b0 
       Enable the early transfer to secondary when the primary is processing a snoop 
       and accepts a fastpath transaction. Transferring early reduces the effective 
       latency that the secondary sees. 
     */
    UINT32 use_bgf_cdt_for_bgf_empty : 1;
    /* use_bgf_cdt_for_bgf_empty - Bits[13:13], RW_L, default = 1'b1  */
    UINT32 auto_dbg_way_en : 1;
    /* auto_dbg_way_en - Bits[14:14], RW_L, default = 1'b0 
       Enable automatic walking of cache ways for dumping debug data.
       Locked by DBGBUSLCK
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 aggressive_rd_pf_ack : 1;
    /* aggressive_rd_pf_ack - Bits[16:16], RW_L, default = 1'b1 
       1
     */
    UINT32 gddb_cb_en : 1;
    /* gddb_cb_en - Bits[17:17], RW_L, default = 1'b0 
       1
     */
    UINT32 dump_ns_in_fastpath : 1;
    /* dump_ns_in_fastpath - Bits[18:18], RW_L, default = 1'b0 
       1
     */
    UINT32 dump_p2p_in_fastpath : 1;
    /* dump_p2p_in_fastpath - Bits[19:19], RW_L, default = 1'b0 
       1
     */
    UINT32 set_pe_based_on_swrid : 1;
    /* set_pe_based_on_swrid - Bits[20:20], RW_L, default = 1'b0 
       1
     */
    UINT32 p_pf_timeout_flush_itom : 1;
    /* p_pf_timeout_flush_itom - Bits[21:21], RW_L, default = 1'b0 
       If we timeout on a posted prefetch and we have ownership but no data, issue a 
       CLFlush before transferring the line to the secondary. Only set this if there is 
       a bug with the handling of a silent E->I downgrade. 
     */
    UINT32 use_isoc_ovf_q : 1;
    /* use_isoc_ovf_q - Bits[22:22], RW_L, default = 1'b1 
       use a different queue between switch and IRP for isoc transaction
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 p_pf_timeout_ext_reset_en : 1;
    /* p_pf_timeout_ext_reset_en - Bits[23:23], RW_L, default = 1'b1 
       Reset the ctag posted prefetch timeout counter on extra conditions:
       - received a fastpath transfer
       - prefetch rejected its fastpath request
       - transaction in progress on the ring
     */
    UINT32 p_pf_timeout_cnt : 4;
    /* p_pf_timeout_cnt - Bits[27:24], RW_L, default = 4'b0000 
       Controls the amount of time a posted prefetch to coherent memory with a 
       secondary will wait for its fetch before giving up and passing ownership to its 
       secondary. 
       Encodings:
       0: disabled
       1: something bigger than 0
       2: something bigger than 1
       etc
     */
    UINT32 spare : 4;
    /* spare - Bits[31:28], RW_L, default = 4'b0100  */
  } Bits;
  UINT32 Data;
} IRP_MISC_DFX1_IIO_VTD_HSX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) */

#if defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x804
 */
typedef union {
  struct {
    UINT32 dbg_sig_en : 1;
    /* dbg_sig_en - Bits[0:0], RW_L, default = 1'b0 
       enables reading address CAM in unsed cycles
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 dbg_field_sel : 3;
    /* dbg_field_sel - Bits[3:1], RW_L, default = 3'b000 
       Controls which of the 3 debug groups is dumped for each way. Each bit enables a 
       group, can be multi-hot. 
       Locked by DBGBUSLCK
     */
    UINT32 dbg_entry_num_sel : 6;
    /* dbg_entry_num_sel - Bits[9:4], RW_L, default = 6'b000000 
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 cfg_retry_timeout : 2;
    /* cfg_retry_timeout - Bits[11:10], RW_L, default = 2'b10 
       0: 256ms
       1: 4s
       2: disabled
       3: 2us
       
       has a +100% timeout error
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 early_xfer_enable : 1;
    /* early_xfer_enable - Bits[12:12], RW_L, default = 1'b0 
       Enable the early transfer to secondary when the primary is processing a snoop 
       and accepts a fastpath transaction. Transferring early reduces the effective 
       latency that the secondary sees. 
     */
    UINT32 use_bgf_cdt_for_bgf_empty : 1;
    /* use_bgf_cdt_for_bgf_empty - Bits[13:13], RW_L, default = 1'b1  */
    UINT32 auto_dbg_way_en : 1;
    /* auto_dbg_way_en - Bits[14:14], RW_L, default = 1'b0 
       Enable automatic walking of cache ways for dumping debug data.
       Locked by DBGBUSLCK
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 aggressive_rd_pf_ack : 1;
    /* aggressive_rd_pf_ack - Bits[16:16], RW_L, default = 1'b1 
       1
     */
    UINT32 gddb_cb_en : 1;
    /* gddb_cb_en - Bits[17:17], RW_L, default = 1'b0 
       1
     */
    UINT32 dump_ns_in_fastpath : 1;
    /* dump_ns_in_fastpath - Bits[18:18], RW_L, default = 1'b0 
       1
     */
    UINT32 dump_p2p_in_fastpath : 1;
    /* dump_p2p_in_fastpath - Bits[19:19], RW_L, default = 1'b0 
       1
     */
    UINT32 set_pe_based_on_swrid : 1;
    /* set_pe_based_on_swrid - Bits[20:20], RW_L, default = 1'b0 
       1
     */
    UINT32 p_pf_timeout_flush_itom : 1;
    /* p_pf_timeout_flush_itom - Bits[21:21], RW_L, default = 1'b0 
       If we timeout on a posted prefetch and we have ownership but no data, issue a 
       CLFlush before transferring the line to the secondary. Only set this if there is 
       a bug with the handling of a silent E->I downgrade. 
     */
    UINT32 use_isoc_ovf_q : 1;
    /* use_isoc_ovf_q - Bits[22:22], RW_L, default = 1'b1 
       use a different queue between switch and IRP for isoc transaction
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 p_pf_timeout_ext_reset_en : 1;
    /* p_pf_timeout_ext_reset_en - Bits[23:23], RW_L, default = 1'b1 
       Reset the ctag posted prefetch timeout counter on extra conditions:
       - received a fastpath transfer
       - prefetch rejected its fastpath request
       - transaction in progress on the ring
     */
    UINT32 p_pf_timeout_cnt : 4;
    /* p_pf_timeout_cnt - Bits[27:24], RW_L, default = 4'b0000 
       Controls the amount of time a posted prefetch to coherent memory with a 
       secondary will wait for its fetch before giving up and passing ownership to its 
       secondary. 
       Encodings:
       0: disabled
       1: something bigger than 0
       2: something bigger than 1
       etc
     */
    UINT32 disable_e2e_parity : 1;
    /* disable_e2e_parity - Bits[28:28], RW_L, default = 1'b0 
       If set to 1 then disables the end to end parity checks in IRP
     */
    UINT32 disable_io_range_0x3f8_0x3ff : 1;
    /* disable_io_range_0x3f8_0x3ff - Bits[29:29], RW_L, default = 1'b0 
       Bit to disable IO trans acceptance for BDX-DE, as these ranges are used by UART 
       in SC Address. This bit controls 
       UART Port0 for address range 0x3F8-0x3FF
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 disable_io_range_0x2f8_0x2ff : 1;
    /* disable_io_range_0x2f8_0x2ff - Bits[30:30], RW_L, default = 1'b0 
       Bit to disable IO trans acceptance for BDX-DE, as these ranges are used by UART 
       in SC Address. This bit controls 
       UART Port1 for address range 0x2F8-0x2FF
       
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 spare : 1;
    /* spare - Bits[31:31], RW_L, default = 1'b1  */
  } Bits;
  UINT32 Data;
} IRP_MISC_DFX1_IIO_VTD_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (BDX_HOST) */



/* IRP_MISC_DFX2_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x40028850)                                                  */
/*       IVT_EX (0x40028850)                                                  */
/*       HSX (0x40028808)                                                     */
/*       BDX (0x40028808)                                                     */
/* Register default value on IVT_EP:    0x1FFF0000                            */
/* Register default value on IVT_EX:    0x1FFF0000                            */
/* Register default value on HSX:       0x00000000                            */
/* Register default value on BDX:       0x00000000                            */
#define IRP_MISC_DFX2_IIO_VTD_REG 0x0900C001


#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file HSX\0.5.0.CFG.xml.
 * generated by critter 05_0_0x808
 */
typedef union {
  struct {
    UINT32 xfer_hint_inj_del : 2;
    /* xfer_hint_inj_del - Bits[1:0], RW_L, default = 2'b00 
       Controls the xfer_hint injector delay. 0: no delay, 1: 0-3 cycles, 2: 0-15 
       cycles, 3: 0-63 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 xfer_arb_inj_del : 2;
    /* xfer_arb_inj_del - Bits[3:2], RW_L, default = 2'b00 
       Controls the xfer_arb injector delay. 0: no delay, 1: 4-7 cycles, 2: 8-15 
       cycles, 3: 32-63 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 cmp_arb_inj_del : 2;
    /* cmp_arb_inj_del - Bits[5:4], RW_L, default = 2'b00 
       Controls the cmp_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 cycles, 
       3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 ctag_snp_arb_inj_del : 2;
    /* ctag_snp_arb_inj_del - Bits[7:6], RW_L, default = 2'b00 
       Controls the ctag_snp_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 
       cycles, 3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 srq_snp_arb_inj_del : 2;
    /* srq_snp_arb_inj_del - Bits[9:8], RW_L, default = 2'b00 
       Controls the srq_snp_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 
       cycles, 3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 snp_iss_inj_del : 2;
    /* snp_iss_inj_del - Bits[11:10], RW_L, default = 2'b00 
       Controls the snp_iss injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 cycles, 
       3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 pf_ack_arb_inj_del : 2;
    /* pf_ack_arb_inj_del - Bits[13:12], RW_L, default = 2'b00 
       Controls the pf_ack_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 
       cycles, 3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 data_arb_inj_del : 2;
    /* data_arb_inj_del - Bits[15:14], RW_L, default = 2'b00 
       Controls the data_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 cycles, 
       3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 hdrp1_arb_inj_del : 2;
    /* hdrp1_arb_inj_del - Bits[17:16], RW_L, default = 2'b00 
       Controls the hdrp1_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 
       cycles, 3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 send_data_arb_inj_del : 2;
    /* send_data_arb_inj_del - Bits[19:18], RW_L, default = 2'b00 
       Controls the send_data_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 
       cycles, 3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 prh_done_arb_inj_del : 2;
    /* prh_done_arb_inj_del - Bits[21:20], RW_L, default = 2'b00 
       Controls the prh_done_arb injector delay. 0: no delay, 1: 2-3 cycles, 2: 4-7 
       cycles, 3: 15-31 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 wbq_avail_inj_del : 2;
    /* wbq_avail_inj_del - Bits[23:22], RW_L, default = 2'b00 
       Controls the wbq_avail injector delay. 0: no delay, 1: 4-7 cycles, 2: 8-15 
       cycles, 3: 32-63 cycles 
       Locked by DBGBUSLCK
     */
    UINT32 rsvd : 7;
    /* rsvd - Bits[30:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 inj_del_en : 1;
    /* inj_del_en - Bits[31:31], RW_L, default = 1'b0 
       Enables the delay injector counter. Writing this bit to 0 resets the counter for 
       determinism. 
       Locked by DBGBUSLCK
     */
  } Bits;
  UINT32 Data;
} IRP_MISC_DFX2_IIO_VTD_HSX_BDX_STRUCT;
#endif /* ASM_INC */
#endif /* (HSX_HOST) || defined(BDX_HOST) */




/* IRPEGCREDITS_IIO_VTD_REG supported on:                                     */
/*       HSX (0x40028840)                                                     */
/*       BDX (0x40028840)                                                     */
/* Register default value:              0x8C415B41                            */
#define IRPEGCREDITS_IIO_VTD_REG 0x09004840

#if defined(HSX_HOST) || defined(BDX_HOST)
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.5.0.CFG.xml.
 * Credits used by IRP when transmitting messages to various destinations on 
 * various rings.  
 */
typedef union {
  struct {
    UINT32 qpi_ndr_shared_cdt_threshold : 3;
    /* qpi_ndr_shared_cdt_threshold - Bits[2:0], RW_L, default = 3'b001 
       Number of shared AD egress credits that QPI NDR can consume.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vc0p0_shared_cdt_threshold : 4;
    /* vc0p0_shared_cdt_threshold - Bits[7:4], RW_L, default = 4'b0100 
       Number of shared AD egress credits that VC0 posted=0 can consume.
       You must set (vc0p0_shared_cdt_threshold >= 1).
     */
    UINT32 ad_shared_cdt_threshold : 4;
    /* ad_shared_cdt_threshold - Bits[11:8], RW_L, default = 4'b1011 
       Number of shared AD egress credits per pool in R2. R2 has 2 pools of 15, but 1 
       entry is for Ubox. 
       
       type | dedicated credits | uses shared credits? | max outstanding
       ====================================================
       VC1 | 1 | no | 1
       VC0p1 | 1 | yes (AD) | 1 + ad_shared_cdt_threshold
       VC0p0 | 0 | yes (AD) | vc0p0_shared_cdt_threshold
       qpi_ndr | 1 | yes (AD) | 1 + qpi_ndr_shared_cdt_threshold
       ====================================================
       You must set (ad_shared_cdt_threshold <= 11).
       You must set ((vc0p0_shared_cdt_threshold + qpi_ndr_shared_cdt_threshold) <= 
       ad_shared_cdt_threshold). 
     */
    UINT32 ak_shared_cdt_threshold : 3;
    /* ak_shared_cdt_threshold - Bits[14:12], RW_L, default = 3'b101 
       Number of shared AK egress credits per pool in R2. R2 has 2 pools of 8, but 1 
       entry is for Ubox. 
       
       type | dedicated credits | uses shared credits? | max outstanding
       ====================================================
       local_ndr | 1 | yes (AK) | 1 + ak_shared_cdt_threshold
       snp_rsp | 1 | yes (AK) | 1 + ak_shared_cdt_threshold
       ====================================================
       You must set (ak_shared_cdt_threshold <= 5).
     */
    UINT32 ad0_ak0_plus_one_shared_cdt : 1;
    /* ad0_ak0_plus_one_shared_cdt - Bits[15:15], RW_L, default = 1'b0 
       Increase the shared AD and AK credit thresholds by 1 in AD0 and AK0 to take 
       advantage of extra poolA slots in R2 egress. Note that there is not actually an 
       extra slot in AK poolA . 
     */
    UINT32 en_cdt_bgf_backpressure : 1;
    /* en_cdt_bgf_backpressure - Bits[16:16], RW_L, default = 1'b1 
       Causes IRP to pay attention to BGF backpressure when sending credit refunds to 
       R2. Could be set to 0 if this causes performance issues. 
     */
    UINT32 rsvd_17 : 5;
    /* rsvd_17 - Bits[21:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 qpi_drs_cdt_threshold : 2;
    /* qpi_drs_cdt_threshold - Bits[23:22], RW_L, default = 2'b01  */
    UINT32 idi_cdt_threshold : 4;
    /* idi_cdt_threshold - Bits[27:24], RW_L, default = 4'b1100 
       Specifies the credits used for
       I2U data for VC0
       I2U data VC1/VCm
       I2U data VCp
       DRS to CBox
       
       These use R2PCIe BL Pool A entries.
     */
    UINT32 fifo_cdt_threshold : 4;
    /* fifo_cdt_threshold - Bits[31:28], RW_L, default = 4'b1000 
       The IRP has a FIFO on the inbound path feeding the R2PCIe. This is only a 
       staging FIFO to assist in the flow of inbound traffic. This field pecifies the 
       number of FIFO entries to use in this IRP staging FIFO. 
     */
  } Bits;
  UINT32 Data;
} IRPEGCREDITS_IIO_VTD_STRUCT;
#endif /* ASM_INC */
#endif /* defined(HSX_HOST) || defined(BDX_HOST) */




/* MMCFG_BASE_IIO_VTD_REG supported on:                                       */
/*       IVT_EP (0x40028084)                                                  */
/*       IVT_EX (0x40028084)                                                  */
/* Register default value:              0xFC000000                            */
#define MMCFG_BASE_IIO_VTD_REG 0x09004084



/* MMCFG_LIMIT_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x40028088)                                                  */
/*       IVT_EX (0x40028088)                                                  */
/* Register default value:              0x00000000                            */
#define MMCFG_LIMIT_IIO_VTD_REG 0x09004088



/* CIPINTRC_N0_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x4002814C)                                                  */
/*       IVT_EX (0x4002814C)                                                  */
/* Register default value:              0x00003F00                            */
#define CIPINTRC_N0_IIO_VTD_REG 0x0900414C





/* IRP0DELS_N0_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x40028808)                                                  */
/*       IVT_EX (0x40028808)                                                  */
/* Register default value:              0x00000000                            */
#define IRP0DELS_N0_IIO_VTD_REG 0x09004808



/* IRP0DELS_N1_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x4002880C)                                                  */
/*       IVT_EX (0x4002880C)                                                  */
/* Register default value:              0x00000000                            */
#define IRP0DELS_N1_IIO_VTD_REG 0x0900480C



/* IRP1DELS_N0_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x40028810)                                                  */
/*       IVT_EX (0x40028810)                                                  */
/* Register default value:              0x00000000                            */
#define IRP1DELS_N0_IIO_VTD_REG 0x09004810



/* IRP1DELS_N1_IIO_VTD_REG supported on:                                      */
/*       IVT_EP (0x40028814)                                                  */
/*       IVT_EX (0x40028814)                                                  */
/* Register default value:              0x00000000                            */
#define IRP1DELS_N1_IIO_VTD_REG 0x09004814



/* IRP0DBGRING0_N0_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x40028818)                                                  */
/*       IVT_EX (0x40028818)                                                  */
/* Register default value:              0x00000000                            */
#define IRP0DBGRING0_N0_IIO_VTD_REG 0x09004818



/* IRP0DBGRING0_N1_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x4002881C)                                                  */
/*       IVT_EX (0x4002881C)                                                  */
/* Register default value:              0x00000000                            */
#define IRP0DBGRING0_N1_IIO_VTD_REG 0x0900481C



/* IRP1DBGRING0_N0_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x40028820)                                                  */
/*       IVT_EX (0x40028820)                                                  */
/* Register default value:              0x00000000                            */
#define IRP1DBGRING0_N0_IIO_VTD_REG 0x09004820



/* IRP1DBGRING0_N1_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x40028824)                                                  */
/*       IVT_EX (0x40028824)                                                  */
/* Register default value:              0x00000000                            */
#define IRP1DBGRING0_N1_IIO_VTD_REG 0x09004824



/* IRP0DBGRING1_IIO_VTD_REG supported on:                                     */
/*       IVT_EP (0x10028828)                                                  */
/*       IVT_EX (0x10028828)                                                  */
/* Register default value:              0x00                                  */
#define IRP0DBGRING1_IIO_VTD_REG 0x09001828



/* IRP1DBGRING1_IIO_VTD_REG supported on:                                     */
/*       IVT_EP (0x10028829)                                                  */
/*       IVT_EX (0x10028829)                                                  */
/* Register default value:              0x00                                  */
#define IRP1DBGRING1_IIO_VTD_REG 0x09001829



/* IRPSPAREREGS_IIO_VTD_REG supported on:                                     */
/*       IVT_EP (0x1002882A)                                                  */
/*       IVT_EX (0x1002882A)                                                  */
/* Register default value:              0xF0                                  */
#define IRPSPAREREGS_IIO_VTD_REG 0x0900182A



/* IRP0RNG_IIO_VTD_REG supported on:                                          */
/*       IVT_EP (0x40028830)                                                  */
/*       IVT_EX (0x40028830)                                                  */
/* Register default value:              0x00000000                            */
#define IRP0RNG_IIO_VTD_REG 0x09004830



/* IRP1RNG_IIO_VTD_REG supported on:                                          */
/*       IVT_EP (0x40028834)                                                  */
/*       IVT_EX (0x40028834)                                                  */
/* Register default value:              0x00000000                            */
#define IRP1RNG_IIO_VTD_REG 0x09004834



/* IRPEGCREDITS_N0_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x40028840)                                                  */
/*       IVT_EX (0x40028840)                                                  */
/* Register default value:              0x218566DF4                           */
#define IRPEGCREDITS_N0_IIO_VTD_REG 0x09004840



/* IRPEGCREDITS_N1_IIO_VTD_REG supported on:                                  */
/*       IVT_EP (0x40028844)                                                  */
/*       IVT_EX (0x40028844)                                                  */
/* Register default value:              0x00000008                            */
#define IRPEGCREDITS_N1_IIO_VTD_REG 0x09004844



/* IRP_MISC_DFX3_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x40028854)                                                  */
/*       IVT_EX (0x40028854)                                                  */
/* Register default value:              0x1FFF0000                            */
#define IRP_MISC_DFX3_IIO_VTD_REG 0x09004854



/* IRP_MISC_DFX4_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x40028858)                                                  */
/*       IVT_EX (0x40028858)                                                  */
/* Register default value:              0x00000000                            */
#define IRP_MISC_DFX4_IIO_VTD_REG 0x09004858



/* IRP_MISC_DFX5_IIO_VTD_REG supported on:                                    */
/*       IVT_EP (0x4002885C)                                                  */
/*       IVT_EX (0x4002885C)                                                  */
/* Register default value:              0x00000000                            */
#define IRP_MISC_DFX5_IIO_VTD_REG 0x0900485C



#endif /* IIO_VTD_h */
