/* Date Stamp: 8/23/2014 */

#ifndef IIO_PCIEIOSF2_h
#define IIO_PCIEIOSF2_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For BDX_HOST:                                                              */
/* IIO_PCIEIOSF2_BDX_DEV 2                                                    */
/* IIO_PCIEIOSF2_BDX_FUN 2                                                    */

/* VID_IIO_PCIEIOSF2_REG supported on:                                        */
/*       BDX (0x20012000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_PCIEIOSF2_REG 0x15022000

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DID_IIO_PCIEIOSF2_REG supported on:                                        */
/*       BDX (0x20012002)                                                     */
/* Register default value:              0x6F06                                */
#define DID_IIO_PCIEIOSF2_REG 0x15022002

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'b0110111100000110 
       Device ID values vary from function to function. Bits 15:8 are equal to 0x6F for 
       the processor. The following list is a breakdown of the function groups. 
       0x6F00 - 0x6F1F : PCI Express and DMI ports
       0x6F20 - 0x6F3F : IO Features (Intel QuickData Technology, APIC, VT, RAS, Intel 
       TXT) 
       0x6F40 - 0x6F5F : Performance Monitors
       0x6F60 - 0x6F7F : DFX
       0x6F80 - 0x6F9F : Intel QPI
       0x6FA0 - 0x6FBF : Home Agent/Memory Controller
       0x6FC0 - 0x6FDF : Power Management
       0x6FE0 - 0x6FFF : Cbo/Ring
       
       Default value may vary based on bus, device, and function of this CSR location.
     */
  } Bits;
  UINT16 Data;
} DID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PCICMD_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x20012004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_PCIEIOSF2_REG 0x15022004

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x004
 */
typedef union {
  struct {
    UINT16 iose : 1;
    /* iose - Bits[0:0], RW, default = 1'b0 
       1
     */
    UINT16 mse : 1;
    /* mse - Bits[1:1], RW, default = 1'b0 
       1
     */
    UINT16 bme : 1;
    /* bme - Bits[2:2], RW, default = 1'b0 
       Bus Master Enable
       Controls the ability of the PCI Express port in generating and also in 
       forwarding memory (including MSI writes) or I/O transactions (and not messages) 
       or configuration transactions from the secondary side to the primary side. 
       1: Enables the PCI Express port to a) generate MSI writes internally for 
       AER/HP/PM events (note: there are several other RP MSI related control/enable 
       bits. See the RAS Chapter and PCI Express Base Specification, Revision 2.0 for 
       complete details) and also to b) forward memory (including MSI writes from 
       devices south of the RP), config or I/O read/write requests from secondary to 
       primary side 
       0: The Bus Master is disabled. When this bit is 0, IIO root ports will a) treat 
       upstream PCI Express memory writes/reads, IO writes/reads, and configuration 
       reads and writes as unsupported requests (and follow the rules for handling 
       unsupported requests). This behavior is also true towards transactions that are 
       already pending in the IIO root port's internal queues when the BME bit is 
       turned off. b) mask the root port from generating MSI writes internally for 
       AER/HP/PM events at the root port. 
     */
    UINT16 sce : 1;
    /* sce - Bits[3:3], RO, default = 1'b0 
       Special Cycle Enable
       Not applicable to DMI/PCI Express devices. Hardwired to 0.
     */
    UINT16 mwie : 1;
    /* mwie - Bits[4:4], RO, default = 1'b0 
       Memory Write and Invalidate Enable
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 perre : 1;
    /* perre - Bits[6:6], RW, default = 1'b0 
       Parity Error Reporting Enable
       For PCI Express ports, IIO ignores this bit and always does parity checking and 
       signaling for data/address of transactions both to and from root port. This bit 
       though affects the setting of bit 8 in the PCISTS register. 
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal IIO devices. Hardwired to 0.
     */
    UINT16 serre : 1;
    /* serre - Bits[8:8], RW, default = 1'b0 
       SERR Reporting Enable
       For PCI Express ports, this field enables notifying the internal IIO core error 
       logic of occurrence of an uncorrectable error (fatal or non-fatal) at the port. 
       The internal core error logic of IIO then decides if/how to escalate the error 
       further (pins/message etc.). Note this bit also controls the propagation of PCI 
       Express ERR_FATAL and ERR_NONFATAL messages received from the port to the 
       internal IIO core error logic. 
       1: Fatal and Non-fatal error message generation and Fatal and Non-fatal error 
       message forwarding is enabled 
       0: Fatal and Non-fatal error message generation and Fatal and Non-fatal error 
       message forwarding is disabled 
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0.
     */
    UINT16 interrupt_disable : 1;
    /* interrupt_disable - Bits[10:10], RW, default = 1'b0 
       1
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PCISTS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x20012006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_PCIEIOSF2_REG 0x15022006

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Status
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO_V, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure.
     */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0 
       Master Data Parity Error
       This bit is set by a root port if the Parity Error Response bit in the PCI 
       Command register is set and it either receives a completion with poisoned data 
       from the primary side or it forwards a packet with data (including MSI writes) 
       to the primary side with poison. 
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0 
       Signalled Target Abort
       This bit is set when a root port signals a completer abort completion status on 
       the primary side (internal bus of uncore). This condition includes a PCI Express 
       port forwarding a completer abort status received on a completion from the 
       secondary 
     */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0 
       Received Target Abort
       This bit is set when a device experiences a completer abort condition on a 
       transaction it mastered on the primary interface (uncore internal bus). Note 
       that certain errors might be detected right at the PCI Express interface and 
       those transactions might not 'propagate' to the primary interface before the 
       error is detected (e.g. accesses to memory above VTBAR). Such errors do not 
       cause this bit to be set, and are reported via the PCI Express interface error 
       bits (secondary status register). 
       Conditions that cause bit 12 to be set, include:
       - Device receives a completion on the primary interface (internal bus of uncore) 
       with completer abort completion Status. This includes CA status received on the 
       primary side of a PCI Express port on peer-to-peer completions also. 
       - Other completer abort conditions detected on the uncore internal bus.
     */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0 
       Received Master Abort
       This bit is set when a root port experiences a master abort condition on a 
       transaction it mastered on the primary interface (uncore internal bus). 
       Note that certain errors might be detected right at the PCI Express interface 
       and those transactions might not 'propagate' to the primary interface before the 
       error is detected (e.g. accesses to memory above TOCM in cases where the PCIE 
       interface logic itself might have visibility into TOCM). Such errors do not 
       cause this bit to be set, and are reported via the PCI Express interface error 
       bits (secondary status register). 
       Conditions that cause bit 13 to be set, include:
       - Device receives a completion on the primary interface (internal bus of uncore) 
       with Unsupported Request or master abort completion Status. This includes UR 
       status received on the primary side of a PCI Express port on peer-to-peer 
       completions also. 
       - Other master abort conditions detected on the IIO internal bus amongst those 
       listed in the Chapter 5, 'Inbound Address Decoding,' chapter. 
     */
    UINT16 sse : 1;
    /* sse - Bits[14:14], RW1C, default = 1'b0 
       Signalled System Error
       1: The root port reported fatal/non-fatal (and not correctable) errors it 
       detected on its PCI Express (or DMI) interface to the IIO core error logic 
       (which might eventually escalate the error through the ERR[2:0] pins or message 
       to cpu core or message to PCH). Note that the SERRE bit in the PCICMD register 
       must be set for a device to report the error the IIO core error logic.Software 
       clears this bit by writing a '1' to it. This bit is also set (when SERR enable 
       bit is set) when a FATAL/NON-FATAL message is forwarded to the IIO core error 
       logic. Note that IIO internal 'core' errors (like parity error in the internal 
       queues) are not reported via this bit. 
       0: The root port did not report a fatal/non-fatal error
     */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0 
       Detected Parity Error
       This bit is set by a root port when it receives a packet on the primary side 
       with an uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RID_IIO_PCIEIOSF2_REG supported on:                                        */
/*       BDX (0x10012008)                                                     */
/* Register default value:              0x00                                  */
#define RID_IIO_PCIEIOSF2_REG 0x15021008

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * "PCIe header Revision ID register"
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], ROS_V, default = 8'b00000000 
       Reflects the Uncore Revision ID after reset.
       Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID 
       register in the processor uncore. 
       
     */
  } Bits;
  UINT8 Data;
} RID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CCR_N0_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x10012009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_PCIEIOSF2_REG 0x15021009

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT8 register_level_programming_interface : 8;
    /* register_level_programming_interface - Bits[7:0], RO_V, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} CCR_N0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CCR_N1_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x2001200A)                                                     */
/* Register default value:              0x0604                                */
#define CCR_N1_IIO_PCIEIOSF2_REG 0x1502200A

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO_V, default = 8'b00000100 
       The value changes dependent upon the dev/func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h80 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h01. 
                 dev-0x0 through 0x7 (return 0x4, d0f0 return 0x0 under default 
       settings) 
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO_V, default = 8'b00000110 
       The value changes dependent upon the dev-func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h08 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h11. 
                 dev-0x0 through 0x7 (return 0x6)
       	  dev-0x8 func-2
       	  dev-0x9 func-2
       	  dev-0xA func-2
       	  dev-0xB func-1,2,5,6
       	  dev-0x10 func-1,6
       	  dev-0x12 func-1,5
       	  
     */
  } Bits;
  UINT16 Data;
} CCR_N1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CLSR_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x1001200C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_PCIEIOSF2_REG 0x1502100C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only.
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLAT_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x1001200D)                                                     */
/* Register default value:              0x00                                  */
#define PLAT_IIO_PCIEIOSF2_REG 0x1502100D

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x00d
 */
typedef union {
  struct {
    UINT8 primary_latency_timer : 8;
    /* primary_latency_timer - Bits[7:0], RO, default = 8'b00000000 
       Not applicable to PCI-Express. Hardwired to 00h.
     */
  } Bits;
  UINT8 Data;
} PLAT_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDR_IIO_PCIEIOSF2_REG supported on:                                        */
/*       BDX (0x1001200E)                                                     */
/* Register default value:              0x81                                  */
#define HDR_IIO_PCIEIOSF2_REG 0x1502100E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x00e
 */
typedef union {
  struct {
    UINT8 cl : 7;
    /* cl - Bits[6:0], RO, default = 7'b0000001 
       This field identifies the format of the configuration header layout. It is Type1 
       for all PCI Express root ports. The default is 01h, indicating a 'PCI to PCI 
       Bridge'. 
     */
    UINT8 mfd : 1;
    /* mfd - Bits[7:7], RO_V, default = 1'b1 
       This bit defaults to 1 for Devices 1-3 since these are multi-function devices.
       BIOS can individually control the value of this bit in Function 0 of these 
       devices, based on HDRTYPCTRL register. BIOS will write to that register to 
       change this field to 0 in Function 0 of these devices, if it exposes only 
       Function 0 in the device to OS. 
       Notes:
       In product SKUs where only Function 0 of the device is exposed to any software 
       (BIOS/OS), BIOS would have to still set the control bits mentioned above to set 
       the this bit in this register to be compliant per PCI rules. 
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* BIST_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x1001200F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_IIO_PCIEIOSF2_REG 0x1502100F

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x00f
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} BIST_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PBUS_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x10012018)                                                     */
/* Register default value:              0x00                                  */
#define PBUS_IIO_PCIEIOSF2_REG 0x15021018

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x018
 */
typedef union {
  struct {
    UINT8 pbn : 8;
    /* pbn - Bits[7:0], RW, default = 8'b00000000 
       Configuration software programs this field with the number of the bus on the 
       primary side of the bridge. This register has to be kept consistent with the 
       Internal Bus Number 0 in the CPUBUSNO01 register. BIOS (and OS if internal bus 
       number gets moved) must program this register to the correct value since IIO 
       hardware would depend on this register for inbound configuration cycle decode 
       purposes. 
     */
  } Bits;
  UINT8 Data;
} PBUS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SECBUS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x10012019)                                                     */
/* Register default value:              0x00                                  */
#define SECBUS_IIO_PCIEIOSF2_REG 0x15021019

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x019
 */
typedef union {
  struct {
    UINT8 sbn : 8;
    /* sbn - Bits[7:0], RW, default = 8'b00000000 
       This field is programmed by configuration software to assign a bus number to the 
       secondary bus of the virtual P2P bridge. IIO uses this register to either 
       forward a configuration transaction as a Type 1 or Type 0 to PCI Express. 
       
     */
  } Bits;
  UINT8 Data;
} SECBUS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SUBBUS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x1001201A)                                                     */
/* Register default value:              0x00                                  */
#define SUBBUS_IIO_PCIEIOSF2_REG 0x1502101A

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x01a
 */
typedef union {
  struct {
    UINT8 subordinate_bus_number : 8;
    /* subordinate_bus_number - Bits[7:0], RW, default = 8'b00000000 
       This register is programmed by configuration software with the number of the 
       highest subordinate bus that is behind the PCI Express port. Any transaction 
       that falls between the secondary and subordinate bus number (both inclusive) of 
       an Express port is forwarded to the express port. 
     */
  } Bits;
  UINT8 Data;
} SUBBUS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* IOBAS_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x1001201C)                                                     */
/* Register default value:              0xF0                                  */
#define IOBAS_IIO_PCIEIOSF2_REG 0x1502101C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x01c
 */
typedef union {
  struct {
    UINT8 i_o_address_capability : 2;
    /* i_o_address_capability - Bits[1:0], RO, default = 2'b00 
       IIO supports only 16 bit addressing
     */
    UINT8 more_i_o_base_address : 2;
    /* more_i_o_base_address - Bits[3:2], RW_L, default = 2'b00 
       When EN1K is set in the IIOMISCCTRL register, these bits become RW and allow for 
       1K granularity of I/O addressing, otherwise these are RO. 
     */
    UINT8 i_o_base_address : 4;
    /* i_o_base_address - Bits[7:4], RW, default = 4'b1111 
       Corresponds to A[15:12] of the I/O base address of the PCI Express port. See 
       also the IOLIM register description. 
     */
  } Bits;
  UINT8 Data;
} IOBAS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* IOLIM_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x1001201D)                                                     */
/* Register default value:              0x00                                  */
#define IOLIM_IIO_PCIEIOSF2_REG 0x1502101D

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x01d
 */
typedef union {
  struct {
    UINT8 i_o_address_limit_capability : 2;
    /* i_o_address_limit_capability - Bits[1:0], RO, default = 2'b00 
       IIO only supports 16 bit addressing
     */
    UINT8 more_i_o_address_limit : 2;
    /* more_i_o_address_limit - Bits[3:2], RW_L, default = 2'b00 
       When EN1K is set in the IIOMISCCTRL register, these bits become RW and allow for 
       1K granularity of I/O addressing, otherwise these are RO. 
     */
    UINT8 i_o_address_limit : 4;
    /* i_o_address_limit - Bits[7:4], RW, default = 4'b0000 
       Corresponds to A[15:12] of the I/O limit address of the PCI Express port.The I/O 
       Base and I/O Limit registers define an address range that is used by the PCI 
       Express port to determine when to forward I/O transactions from one interface to 
       the other using the following formula: 
       
       IO_BASE &lt;= A[15:12] &lt;=IO_LIMIT
       
       The bottom of the defined I/O address range will be aligned to a 4KB boundary 
       (1KB if EN1K bit is set. Refer to the IIOMISCCTRL register for definition of 
       EN1K bit) while the top of the region specified by IO_LIMIT will be one less 
       than a 4 KB (1KB if EN1K bit is set) multiple. 
       
       Notes:
       Setting the I/O limit less than I/O base disables the I/O range altogether.
       General the I/O base and limit registers won't be programmed by software without 
       clearing the IOSE bit first. 
     */
  } Bits;
  UINT8 Data;
} IOLIM_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SECSTS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x2001201E)                                                     */
/* Register default value:              0x0000                                */
#define SECSTS_IIO_PCIEIOSF2_REG 0x1502201E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Secondary Status Register
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 pci66_mhz_capability : 1;
    /* pci66_mhz_capability - Bits[5:5], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back_transactions_capable : 1;
    /* fast_back_to_back_transactions_capable - Bits[7:7], RO, default = 1'b0 
       Not applicable to DMI or PCI Express. Hardwired to 0.
     */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0 
       Master Data Parity Error
       This bit is set by the root port on the secondary side (PCI Express link) if the 
       Parity Error Response Enable bit (PERRE) is set in Bridge Control register and 
       either of the following two conditions occurs: 
       - The PCI Express port receives a Completion from PCI Express marked poisoned.
       - The PCI Express port poisons an outgoing packet with data
       If the Parity Error Response Enable bit in Bridge Control Register is cleared, 
       this bit is never set. 
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0 
       Signalled Target Abort
       This bit is set when the root port sends a completion packet with a 'Completer 
       Abort' Status (including peer-to-peer completions that are forwarded from one 
       port to another). 
     */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0 
       Received Target Abort Status
       This bit is set when the root port receives a Completion with 'Completer Abort' 
       Status. 
     */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0 
       Received Master Abort Status
       This bit is set when the root port receives a Completion with 'Unsupported 
       Request Completion' Status or when the root port master aborts a Type0 
       configuration packet that has a non-zero device number. 
     */
    UINT16 rse : 1;
    /* rse - Bits[14:14], RW1C, default = 1'b0 
       Received System Error
       This bit is set by the root port when it receives a ERR_FATAL or ERR_NONFATAL 
       message from PCI Express. Note this does not include the virtual ERR* messages 
       that are internally generated from the root port when it detects an error on its 
       own. 
     */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0 
       Detected Parity Error
       This bit is set by the root port whenever it receives a poisoned TLP in the PCI 
       Express port. This bit is set regardless of the state the Parity Error Response 
       Enable bit in the Bridge Control register. 
     */
  } Bits;
  UINT16 Data;
} SECSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MBAS_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x20012020)                                                     */
/* Register default value:              0xFFF0                                */
#define MBAS_IIO_PCIEIOSF2_REG 0x15022020

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x020
 */
typedef union {
  struct {
    UINT16 rsvd : 4;
    /* rsvd - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 memory_base_address : 12;
    /* memory_base_address - Bits[15:4], RW, default = 12'b111111111111 
       Corresponds to A[31:20] of the 32 bit memory window's base address of the PCI 
       Express port. See also the MLIM register description. 
     */
  } Bits;
  UINT16 Data;
} MBAS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MLIM_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x20012022)                                                     */
/* Register default value:              0x0000                                */
#define MLIM_IIO_PCIEIOSF2_REG 0x15022022

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x022
 */
typedef union {
  struct {
    UINT16 rsvd : 4;
    /* rsvd - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 memory_limit_address : 12;
    /* memory_limit_address - Bits[15:4], RW, default = 12'b000000000000 
       Corresponds to A[31:20] of the 32 bit memory window's limit address that 
       corresponds to the upper limit of the range of memory accesses that will be 
       passed by the PCI Express bridge.The Memory Base and Memory Limit registers 
       define a memory mapped I/O non-prefetchable address range (32-bit addresses) and 
       the IIO directs accesses in this range to the PCI Express port based on the 
       following formula: 
       MEMORY_BASE &lt;= A[31:20] &lt;= MEMORY_LIMIT
       The upper 12 bits of both the Memory Base and Memory Limit registers are 
       read/write and corresponds to the upper 12 address bits, A[31:20] of 32-bit 
       addresses. Thus, the bottom of the defined memory address range will be aligned 
       to a 1 MB boundary and the top of the defined memory address range will be one 
       less than a 1 MB boundary. 
       Notes:
       Setting the memory limit less than memory base disables the 32-bit memory range 
       altogether. 
       Note that in general the memory base and limit registers won't be programmed by 
       software without clearing the MSE bit first. 
     */
  } Bits;
  UINT16 Data;
} MLIM_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PBAS_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x20012024)                                                     */
/* Register default value:              0xFFF1                                */
#define PBAS_IIO_PCIEIOSF2_REG 0x15022024

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x024
 */
typedef union {
  struct {
    UINT16 prefetchable_memory_base_address_capability : 4;
    /* prefetchable_memory_base_address_capability - Bits[3:0], RO, default = 4'b0001 
       IIO sets this bit to 01h to indicate 64bit capability.
     */
    UINT16 prefetchable_memory_base_address : 12;
    /* prefetchable_memory_base_address - Bits[15:4], RW, default = 12'b111111111111 
       Corresponds to A[31:20] of the prefetchable memory address range's base address 
       of the PCI Express port. See also the PLIMU register description. 
     */
  } Bits;
  UINT16 Data;
} PBAS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLIM_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x20012026)                                                     */
/* Register default value:              0x0001                                */
#define PLIM_IIO_PCIEIOSF2_REG 0x15022026

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x026
 */
typedef union {
  struct {
    UINT16 prefetchable_memory_limit_address_capability : 4;
    /* prefetchable_memory_limit_address_capability - Bits[3:0], RO, default = 4'b0001 
       IIO sets this field to 01h to indicate 64bit capability.
     */
    UINT16 prefetchable_memory_limit_address : 12;
    /* prefetchable_memory_limit_address - Bits[15:4], RW, default = 12'b000000000000 
       Corresponds to A[31:20] of the prefetchable memory address range's limit address 
       of the PCI Express port. See also the PLIMU register description. 
     */
  } Bits;
  UINT16 Data;
} PLIM_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PBASU_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x40012028)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define PBASU_IIO_PCIEIOSF2_REG 0x15024028

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x028
 */
typedef union {
  struct {
    UINT32 prefetchable_upper_32_bit_memory_base_address : 32;
    /* prefetchable_upper_32_bit_memory_base_address - Bits[31:0], RW, default = 32'b11111111111111111111111111111111 
       Corresponds to A[63:32] of the prefetchable memory address range's base address 
       of the PCI Express port. See also the PLIMU register description. 
     */
  } Bits;
  UINT32 Data;
} PBASU_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PLIMU_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x4001202C)                                                     */
/* Register default value:              0x00000000                            */
#define PLIMU_IIO_PCIEIOSF2_REG 0x1502402C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x02c
 */
typedef union {
  struct {
    UINT32 prefetchable_upper_32_bit_memory_limit_address : 32;
    /* prefetchable_upper_32_bit_memory_limit_address - Bits[31:0], RW, default = 32'b00000000000000000000000000000000 
       Corresponds to A[63:32] of the prefetchable memory address range's limit address 
       of the PCI Express port.The Prefetchable Memory Base and Memory Limit registers 
       define a memory mapped I/O prefetchable address range (64-bit addresses) which 
       is used by the PCI Express bridge to determine when to forward memory 
       transactions based on the following formula: 
       
       PREFETCH_MEMORY_BASE_UPPER PREFETCH_MEMORY_BASE &lt;= A[63:20] &lt;= 
       PREFETCH_MEMORY_LIMIT_UPPERPREFETCH_MEMORY_LIMIT 
       
       The upper 12 bits of both the Prefetchable Memory Base and Memory Limit 
       registers are read/write and corresponds to the upper 12 address bits, A[31:20] 
       of 32-bit addresses. The bottom of the defined memory address range will be 
       aligned to a 1 MB boundary and the top of the defined memory address range will 
       be one less than a 1 MB boundary. 
       
       The bottom 4 bits of both the Prefetchable Memory Base and Prefetchable Memory 
       Limit registers are read-only, contain the same value, and encode whether or not 
       the bridge supports 64-bit addresses. 
       If these four bits have the value 0h, then the bridge supports only 32 bit 
       addresses. 
       If these four bits have the value 1h, then the bridge supports 64-bit addresses 
       and the Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits 
       registers hold the rest of the 64-bit prefetchable base and limit addresses 
       respectively. 
       Setting the prefetchable memory limit less than prefetchable memory base 
       disables the 64-bit prefetchable memory range altogether. 
       
       Notes:
       In general the memory base and limit registers won't be programmed by software 
       without clearing the MSE bit first. 
     */
  } Bits;
  UINT32 Data;
} PLIMU_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CAPPTR_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x10012034)                                                     */
/* Register default value:              0x40                                  */
#define CAPPTR_IIO_PCIEIOSF2_REG 0x15021034

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'b01000000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* INTL_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x1001203C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_PCIEIOSF2_REG 0x1502103C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RW, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* INTPIN_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x1001203D)                                                     */
/* Register default value:              0x01                                  */
#define INTPIN_IIO_PCIEIOSF2_REG 0x1502103D

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x03d
 */
typedef union {
  struct {
    UINT8 intp : 8;
    /* intp - Bits[7:0], RW_O, default = 8'b00000001 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* BCTRL_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x2001203E)                                                     */
/* Register default value:              0x0000                                */
#define BCTRL_IIO_PCIEIOSF2_REG 0x1502203E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT16 perre : 1;
    /* perre - Bits[0:0], RW, default = 1'b0 
       Parity Error Response Enable
       This only effect this bit has is on the setting of bit 8 in the SECSTS register.
     */
    UINT16 serre : 1;
    /* serre - Bits[1:1], RW, default = 1'b0 
       SERR Response Enable
       This bit controls forwarding of ERR_COR, ERR_NONFATAL and ERR_FATAL messages 
       from the PCI Express port to the primary side. 
       1: Enables forwarding of ERR_COR, ERR_NONFATAL and ERR_FATAL messages.
       0: Disables forwarding of ERR_COR, ERR_NONFATAL and ERR_FATAL
       Refer to PCI Express Base Specification, Revision 2.0 details of the control 
       bits that control error reporting in IIO. 
     */
    UINT16 isaen : 1;
    /* isaen - Bits[2:2], RW, default = 1'b0 
       Modifies the response by the root port to an I/O access issued by the core that 
       target ISA I/O addresses. This applies only to I/O addresses that are enabled by 
       the IOBASE and IOLIM registers. 
       
       1: The root port will not forward to PCI Express any I/O transactions addressing 
       the last 768 bytes in each 1KB block even if the addresses are within the range 
       defined by the IOBASE and IOLIM registers. 
       0: All addresses defined by the IOBASE and IOLIM for core issued I/O 
       transactions will be mapped to PCI Express. 
     */
    UINT16 vgaen : 1;
    /* vgaen - Bits[3:3], RW, default = 1'b0 
       Controls the routing of CPU initiated transactions targeting VGA compatible I/O 
       and memory address ranges. This bit must only be set for one p2p port in the 
       entire system. 
       
       Notes:
       When Device 3 Function 0 is in NTB mode, then the Device 3 Function 0 versoin of 
       this bit must be left at default value. VGA compatible devices are not supported 
       on the secondary side of the NTB. 
     */
    UINT16 vga16b : 1;
    /* vga16b - Bits[4:4], RW, default = 1'b0 
       This bit enables the virtual PCI-to-PCI bridge to provide 16-bit decoding of VGA 
       I/O address precluding the decoding of alias addresses every 1 KB. 
       
       0: execute 10-bit address decodes on VGA I/O accesses.
       1: execute 16-bit address decodes on VGA I/O accesses.
       
       Notes:
       This bit only has meaning if bit 3 of this register is also set to 1, enabling 
       VGA I/O decoding and forwarding by the bridge. 
       Refer to PCI-PCI Bridge Specification Revision 1.2 for further details of this 
       bit behavior. 
     */
    UINT16 rsvd_5 : 1;
    /* rsvd_5 - Bits[5:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 sbr : 1;
    /* sbr - Bits[6:6], RW, default = 1'b0  */
    UINT16 rsvd_7 : 9;
    /* rsvd_7 - Bits[15:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} BCTRL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SCAPID_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x10012040)                                                     */
/* Register default value:              0x0D                                  */
#define SCAPID_IIO_PCIEIOSF2_REG 0x15021040

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x040
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00001101 
       Assigned by PCI-SIG for subsystem capability ID
     */
  } Bits;
  UINT8 Data;
} SCAPID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SNXTPTR_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x10012041)                                                     */
/* Register default value:              0x60                                  */
#define SNXTPTR_IIO_PCIEIOSF2_REG 0x15021041

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x041
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b01100000 
       This field is set to 60h for the next capability list (MSI capability structure) 
       in the chain. 
     */
  } Bits;
  UINT8 Data;
} SNXTPTR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SVID_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x20012044)                                                     */
/* Register default value:              0x8086                                */
#define SVID_IIO_PCIEIOSF2_REG 0x15022044

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x044
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_id : 16;
    /* subsystem_vendor_id - Bits[15:0], RW_O, default = 16'b1000000010000110  */
  } Bits;
  UINT16 Data;
} SVID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SDID_IIO_PCIEIOSF2_REG supported on:                                       */
/*       BDX (0x20012046)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_PCIEIOSF2_REG 0x15022046

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x046
 */
typedef union {
  struct {
    UINT16 subsystem_device_id : 16;
    /* subsystem_device_id - Bits[15:0], RW_O, default = 16'b0000000000000000  */
  } Bits;
  UINT16 Data;
} SDID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSICAPID_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x10012060)                                                     */
/* Register default value:              0x05                                  */
#define MSICAPID_IIO_PCIEIOSF2_REG 0x15021060

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x060
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000101 
       Assigned by PCI-SIG for MSI (root ports).
     */
  } Bits;
  UINT8 Data;
} MSICAPID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSINXTPTR_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x10012061)                                                     */
/* Register default value:              0x90                                  */
#define MSINXTPTR_IIO_PCIEIOSF2_REG 0x15021061

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x061
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RW_O, default = 8'b10010000 
       This field is set to 90h for the next capability list (PCI Express capability 
       structure) in the chain. 
     */
  } Bits;
  UINT8 Data;
} MSINXTPTR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSIMSGCTL_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x20012062)                                                     */
/* Register default value:              0x0102                                */
#define MSIMSGCTL_IIO_PCIEIOSF2_REG 0x15022062

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x062
 */
typedef union {
  struct {
    UINT16 msien : 1;
    /* msien - Bits[0:0], RW, default = 1'b0 
       Software sets this bit to select INTx style interrupt or MSI interrupt for root 
       port generated interrupts. 
       
       0: INTx interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       1: MSI interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       
       Note there bits 4:2 and bit 2 MISCCTRLSTS can disable both MSI and INTx 
       interrupt from being generated on root port interrupt events. 
     */
    UINT16 mmc : 3;
    /* mmc - Bits[3:1], RO, default = 3'b001 
       Multiple Message Capable
       IIO Root Ports support two messages for all their internal events.
     */
    UINT16 mme : 3;
    /* mme - Bits[6:4], RW, default = 3'b000 
       Applicable only to PCI Express ports. Software writes to this field to indicate 
       the number of allocated messages which is aligned to a power of two. When MSI is 
       enabled, the software will allocate at least one message to the device. A value 
       of 000 indicates 1 message. Any value greater than or equal to 001 indicates a 
       message of 2. 
       
       See MSIDR for discussion on how the interrupts are distributed amongst the 
       various sources of interrupt based on the number of messages allocated by 
       software for the PCI Express ports. 
     */
    UINT16 b64ac : 1;
    /* b64ac - Bits[7:7], RO, default = 1'b0 
       This field is hardwired to 0h since the message addresses are only 32-bit 
       addresses (e.g. FEEx_xxxxh). 
     */
    UINT16 pvmc : 1;
    /* pvmc - Bits[8:8], RO, default = 1'b1 
       This bit indicates that PCI Express ports support MSI per-vector masking.
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} MSIMSGCTL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSGADR_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x40012064)                                                     */
/* Register default value:              0x00000000                            */
#define MSGADR_IIO_PCIEIOSF2_REG 0x15024064

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * The MSI Address Register (MSIAR) contains the system specific address 
 * information to route MSI interrupts from the root ports and is broken into its 
 * constituent fields. 
 */
typedef union {
  struct {
    UINT32 rsvd : 2;
    /* rsvd - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 address_id : 30;
    /* address_id - Bits[31:2], RW, default = 30'b000000000000000000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
  } Bits;
  UINT32 Data;
} MSGADR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSGDAT_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x40012068)                                                     */
/* Register default value:              0x00000000                            */
#define MSGDAT_IIO_PCIEIOSF2_REG 0x15024068

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x068
 */
typedef union {
  struct {
    UINT32 data : 16;
    /* data - Bits[15:0], RW, default = 16'b0000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSGDAT_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSIMSK_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x4001206C)                                                     */
/* Register default value:              0x00000000                            */
#define MSIMSK_IIO_PCIEIOSF2_REG 0x1502406C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x06c
 */
typedef union {
  struct {
    UINT32 mask_bits : 2;
    /* mask_bits - Bits[1:0], RW, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. For each Mask bit that is set, the PCI Express port is prohibited from 
       sending the associated message. When only one message is allocated to the root 
       port by software, only mask bit 0 is relevant and used by hardware. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MSIPENDING_IIO_PCIEIOSF2_REG supported on:                                 */
/*       BDX (0x40012070)                                                     */
/* Register default value:              0x00000000                            */
#define MSIPENDING_IIO_PCIEIOSF2_REG 0x15024070

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x070
 */
typedef union {
  struct {
    UINT32 pending_bits : 2;
    /* pending_bits - Bits[1:0], RO_V, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. When MSI is not enabled or used by the root port, this register always 
       reads a value 0. For each Pending bit that is set, the PCI Express port has a 
       pending associated message. When only one message is allocated to the root port 
       by software, only pending bit 0 is set/cleared by hardware and pending bit 1 
       always reads 0. 
       Hardware sets this bit whenever it has an interrupt pending to be sent. This bit 
       remains set till either the interrupt is sent by hardware or the status bits 
       associated with the interrupt condition are cleared by software. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIPENDING_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PXPCAPID_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x10012090)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_PCIEIOSF2_REG 0x15021090

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x090
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PXPNXTPTR_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x10012091)                                                     */
/* Register default value:              0xE0                                  */
#define PXPNXTPTR_IIO_PCIEIOSF2_REG 0x15021091

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x091
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b11100000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PXPCAP_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x20012092)                                                     */
/* Register default value:              0x0042                                */
#define PXPCAP_IIO_PCIEIOSF2_REG 0x15022092

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x092
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RW_O, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure, which 
       is 2h as of now. This register field is left as RW-O to cover any unknowns with 
       Gen3. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO_V, default = 4'b0100 
       This field identifies the type of device. It is set to 0100 for all the Express 
       ports. 
     */
    UINT16 slot_implemented : 1;
    /* slot_implemented - Bits[8:8], RW_O, default = 1'b0 
       Applies only to the root ports.
       1: indicates that the PCI Express link associated with the port is connected to 
       a slot. 
       0: indicates no slot is connected to this port.
       
       Notes:
       This register bit is of type 'write once' and is set by BIOS.
     */
    UINT16 interrupt_message_number : 5;
    /* interrupt_message_number - Bits[13:9], RO, default = 5'b00000 
       Applies to root ports. This field indicates the interrupt message number that is 
       generated for Power Management/Hot Plug/Bandwidth-change events. When there are 
       more than one MSI interrupt Number allocated for the root port MSI interrupts, 
       this register field is required to contain the offset between the base Message 
       Data and the MSI Message that is generated when there are these change 
       interrupts. IIO assigns the first vector for these change events and so this 
       field is set to 0. 
     */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCAP_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x40012094)                                                     */
/* Register default value:              0x00008001                            */
#define DEVCAP_IIO_PCIEIOSF2_REG 0x15024094

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * The PCI Express Device Capabilities register identifies device specific 
 * information for the device. 
 */
typedef union {
  struct {
    UINT32 max_payload_size_supported : 3;
    /* max_payload_size_supported - Bits[2:0], RO, default = 3'b001 
       1
     */
    UINT32 phantom_functions_supported : 2;
    /* phantom_functions_supported - Bits[4:3], RO, default = 2'b00 
       CB DMA does not support phantom functions.
     */
    UINT32 extended_tag_field_supported : 1;
    /* extended_tag_field_supported - Bits[5:5], RW_O, default = 1'b0  */
    UINT32 endpoint_l0s_acceptable_latency : 3;
    /* endpoint_l0s_acceptable_latency - Bits[8:6], RO, default = 3'b000 
       N/A
     */
    UINT32 endpoint_l1_acceptable_latency : 3;
    /* endpoint_l1_acceptable_latency - Bits[11:9], RO, default = 3'b000 
       N/A
     */
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[12:12], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[13:13], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 power_indicator_present_on_device : 1;
    /* power_indicator_present_on_device - Bits[14:14], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 role_based_error_reporting : 1;
    /* role_based_error_reporting - Bits[15:15], RO, default = 1'b1 
       IIO is 1.1 compliant and so supports this feature
     */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 captured_slot_power_limit_value : 8;
    /* captured_slot_power_limit_value - Bits[25:18], RO, default = 8'b00000000 
       Does not apply to CB DMA
     */
    UINT32 captured_slot_power_limit_scale : 2;
    /* captured_slot_power_limit_scale - Bits[27:26], RO, default = 2'b00 
       Does not apply to CB DMA
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCTRL_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x20012098)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL_IIO_PCIEIOSF2_REG 0x15022098

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x098
 */
typedef union {
  struct {
    UINT16 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Controls the reporting of correctable errors that IIO detects on the PCI 
       Express/DMI interface 
       0: Reporting of link Correctable error detected by the port is disabled
       1: Reporting of link Correctable error detected by port is enabled
     */
    UINT16 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Controls the reporting of non-fatal errors that IIO detects on the PCI Express 
       interface. 
       0: Reporting of Non Fatal error detected by device is disabled
       1: Reporting of Non Fatal error detected by device is enabled
     */
    UINT16 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Controls the reporting of fatal errors that IIO detects on the PCI Express/DMI 
       interface. 
       0: Reporting of Fatal error detected by device is disabled
       1: Reporting of Fatal error detected by device is enabled
     */
    UINT16 unsupported_request_reporting_enable : 1;
    /* unsupported_request_reporting_enable - Bits[3:3], RW, default = 1'b0 
       This bit controls the reporting of unsupported requests that IIO itself detects 
       on requests its receives from a PCI Express port. 
       0: Reporting of unsupported requests is disabled
       1: Reporting of unsupported requests is enabled.
     */
    UINT16 enable_relaxed_ordering : 1;
    /* enable_relaxed_ordering - Bits[4:4], RO, default = 1'b0 
       Not applicable to root ports since they never set relaxed ordering bit as a 
       requester (this does not include tx forwarded from peer devices). This bit has 
       no impact on forwarding of relaxed ordering attribute on peer requests. 
     */
    UINT16 max_payload_size : 3;
    /* max_payload_size - Bits[7:5], RW, default = 3'b000 
       000: 128B max payload size
       001: 256B max payload size
       others: alias to 128B
       
       IIO can receive packets equal to the size set by this field.
       IIO generate read completions as large as the value set by this field.
       IIO generates memory writes of max 64B.
     */
    UINT16 extended_tag_field_enable : 1;
    /* extended_tag_field_enable - Bits[8:8], RW, default = 1'b0 
       Not applicable, since IIO never generates any requests on its own that uses tags 
       7:5. However, IIO forwards the entire tag field for peer to peer requests, so 
       tag[7:5] could be set. 
     */
    UINT16 phantom_functions_enable : 1;
    /* phantom_functions_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable, since IIO never uses phantom functions as a requestor.
     */
    UINT16 auxiliary_power_management_enable : 1;
    /* auxiliary_power_management_enable - Bits[10:10], RO, default = 1'b0 
       Not applicable
     */
    UINT16 enable_no_snoop : 1;
    /* enable_no_snoop - Bits[11:11], RO, default = 1'b0 
       Not applicable to PCIe root ports since they never set the 'No Snoop' bit for 
       transactions they originate (not forwarded from peer) to PCI Express/DMI. This 
       bit has no impact on forwarding of NoSnoop attribute on peer requests. 
     */
    UINT16 max_read_request_size : 3;
    /* max_read_request_size - Bits[14:12], RO, default = 3'b000 
       PCI Express ports do not generate requests greater than 64B and this field is 
       RO. 
     */
    UINT16 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVSTS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x2001209A)                                                     */
/* Register default value:              0x0000                                */
#define DEVSTS_IIO_PCIEIOSF2_REG 0x1502209A

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Express Device Status
 */
typedef union {
  struct {
    UINT16 correctable_error_detected : 1;
    /* correctable_error_detected - Bits[0:0], RW1C, default = 1'b0 
       This bit gets set if a correctable error is detected by the root port. Errors 
       are logged in this register regardless of whether error reporting is enabled or 
       not in the PCI Express Device Control register. 
       1: correctable errors detected
       0: No correctable errors detected
     */
    UINT16 non_fatal_error_detected : 1;
    /* non_fatal_error_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit gets set if a non-fatal uncorrectable error is detected by the root 
       port. Errors are logged in this register regardless of whether error reporting 
       is enabled or not in the Device Control register. 
       1: Non Fatal errors detected
       0: No non-Fatal Errors detected
     */
    UINT16 fatal_error_detected : 1;
    /* fatal_error_detected - Bits[2:2], RW1C, default = 1'b0 
       This bit indicates that a fatal (uncorrectable) error is detected by the root 
       port. Errors are logged in this register regardless of whether error reporting 
       is enabled or not in the Device Control register. 
       1: Fatal errors detected
       0: No Fatal errors detected
     */
    UINT16 unsupported_request_detected : 1;
    /* unsupported_request_detected - Bits[3:3], RW1C, default = 1'b0 
       This bit indicates that the root port port detected an Unsupported Request. 
       Errors are logged in this register regardless of whether error reporting is 
       enabled or not in the Device Control Register. 
       1: Unsupported Request detected at the device/port. These unsupported requests 
       are NP requests inbound that the root port port received and it detected them as 
       unsupported requests (e.g. address decoding failures that the root port detected 
       on a packet, receiving inbound lock reads, BME bit is clear etc.). 
       0: No unsupported request detected by the root port
       
       This bit is not set on peer2peer completions with UR status that are forwarded 
       by the root port to the PCIe link. 
     */
    UINT16 aux_power_detected : 1;
    /* aux_power_detected - Bits[4:4], RO, default = 1'b0 
       Does not apply to IIO
     */
    UINT16 transactions_pending : 1;
    /* transactions_pending - Bits[5:5], RO, default = 1'b0 
       Does not apply to Root/DMI ports, i.e. bit hardwired to 0 for these devices.
     */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCAP_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x4001209C)                                                     */
/* Register default value:              0x00100011                            */
#define LNKCAP_IIO_PCIEIOSF2_REG 0x1502409C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * The Link Capabilities register identifies the PCI Express specific link 
 * capabilities. The link capabilities register needs some default values setup by 
 * the local host. This register is relocated to the enhanced configuration space 
 * region in while in NTB mode. 
 */
typedef union {
  struct {
    UINT32 maxlnkspd : 4;
    /* maxlnkspd - Bits[3:0], RW_O, default = 4'b0001 
       This field indicates the maximum link speed of this Port.
       The encoding is the binary value of the bit location in the Supported Link 
       Speeds Vector (in LNKCAP2) that corresponds to the maximum link speed. 
       0010b = (5Gbps)
       0011b = (8Gbps)
     */
    UINT32 maximum_link_width : 6;
    /* maximum_link_width - Bits[9:4], RW_O, default = 6'b000001 
       This field indicates the maximum width of the given PCI Express Link attached to 
       the port. 
       000001: x1
       000010: x2
       000100: x4
       001000: x8
       010000: x16
       Others: Reserved
       
       This is left as a RW-O register for bios to update based on the platform usage 
       of the links. 
     */
    UINT32 active_state_link_pm_support : 2;
    /* active_state_link_pm_support - Bits[11:10], RW_O, default = 2'b00 
       This field indicates the level of active state power management supported on the 
       given PCI-Express port. 
       00: Disabled
       01: L0s Entry Supported
       10: L1 Entry Supported (Gen3; spec allows 0x2)
       11: L0s and L1 Supported
       L0s is not supported on the processor.
     */
    UINT32 l0s_exit_latency : 3;
    /* l0s_exit_latency - Bits[14:12], RW_O, default = 3'b000 
       This field indicates the L0s exit latency (i.e L0s to L0) for the PCI-Express 
       port. 
       L0s is not supported on the processor.
     */
    UINT32 l1_exit_latency : 3;
    /* l1_exit_latency - Bits[17:15], RW_O, default = 3'b000 
       This field indicates the L1 exit latency for the given PCI-Express port. It 
       indicates the length of time this port requires to complete transition from L1 
       to L0. 
       000: Less than 1us
       001: 1 us to less than 2 us
       010: 2 us to less than 4 us
       011: 4 us to less than 8 us
       100: 8 us to less than 16 us
       101: 16 us to less than 32 us
       110: 32 us to 64 us
       111: More than 64us
       
       This register is made writable once by BIOS so that the value is settable based 
       on experiments post-si. 
     */
    UINT32 clock_power_management : 1;
    /* clock_power_management - Bits[18:18], RW_O, default = 1'b0 
       Does not apply to processor
     */
    UINT32 surprise_down_error_reporting_capable : 1;
    /* surprise_down_error_reporting_capable - Bits[19:19], RW_O, default = 1'b0 
       IIO supports reporting a surprise down error condition
     */
    UINT32 data_link_layer_link_active_reporting_capable : 1;
    /* data_link_layer_link_active_reporting_capable - Bits[20:20], RW_O, default = 1'b1 
       IIO supports reporting status of the data link layer so software knows when it 
       can enumerate a device on the link or otherwise know the status of the link. 
     */
    UINT32 link_bandwidth_notification_capability : 1;
    /* link_bandwidth_notification_capability - Bits[21:21], RW_O, default = 1'b0 
       A value of 1b indicates support for the Link Bandwidth Notification status and 
       interrupt mechanisms. 
     */
    UINT32 aspm_optionality_compliance : 1;
    /* aspm_optionality_compliance - Bits[22:22], RW_O, default = 1'b0  */
    UINT32 rsvd : 1;
    /* rsvd - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 port_number : 8;
    /* port_number - Bits[31:24], RW_O, default = 8'b00000000 
       This field indicates the PCI Express port number for the link and is initialized 
       by software/BIOS. IIO hardware does nothing with this bit. 
     */
  } Bits;
  UINT32 Data;
} LNKCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCON_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x200120A0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON_IIO_PCIEIOSF2_REG 0x150220A0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Express Link Control
 */
typedef union {
  struct {
    UINT16 active_state_link_pm_control : 2;
    /* active_state_link_pm_control - Bits[1:0], RW, default = 2'b00 
       When 01b or 11b, L0s on transmitter is enabled, otherwise it is disabled. 10 and 
       11 enables L1 ASPM. 
     */
    UINT16 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 read_completion_boundary : 1;
    /* read_completion_boundary - Bits[3:3], RO, default = 1'b0 
       Set to zero to indicate IIO could return read completions at 64B boundaries.
     */
    UINT16 link_disable : 1;
    /* link_disable - Bits[4:4], RW, default = 1'b0  */
    UINT16 rsvd_5 : 1;
    /* rsvd_5 - Bits[5:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 common_clock_configuration : 1;
    /* common_clock_configuration - Bits[6:6], RW, default = 1'b0  */
    UINT16 extended_synch : 1;
    /* extended_synch - Bits[7:7], RW, default = 1'b0  */
    UINT16 enable_clock_power_management : 1;
    /* enable_clock_power_management - Bits[8:8], RO, default = 1'b0  */
    UINT16 hardware_autonomous_width_disable : 1;
    /* hardware_autonomous_width_disable - Bits[9:9], RW, default = 1'b0  */
    UINT16 link_bandwidth_management_interrupt_enable : 1;
    /* link_bandwidth_management_interrupt_enable - Bits[10:10], RW, default = 1'b0 
       For root ports, when set to 1b this bit enables the generation of an interrupt 
       to indicate that the Link Bandwidth Management Status bit has been set.For DMI 
       mode on Dev#0, interrupt is not supported and hence this bit is not useful. 
       Expectation is that BIOS will set MISCCTRLSTS[27] to notify the system of 
       autonomous BW change event on that port. 
     */
    UINT16 link_autonomous_bandwidth_interrupt_enable : 1;
    /* link_autonomous_bandwidth_interrupt_enable - Bits[11:11], RW, default = 1'b0 
       For root ports, when set to 1b this bit enables the generation of an interrupt 
       to indicate that the Link Autonomous Bandwidth Status bit has been set.For DMI 
       mode on Dev#0, interrupt is not supported and hence this bit is not useful. 
       Expectation is that BIOS will set MISCCTRLSTS[27] to notify the system of 
       autonomous BW change event on that port. 
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKCON_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKSTS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x200120A2)                                                     */
/* Register default value:              0x1011                                */
#define LNKSTS_IIO_PCIEIOSF2_REG 0x150220A2

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0a2
 */
typedef union {
  struct {
    UINT16 current_link_speed : 4;
    /* current_link_speed - Bits[3:0], RO_V, default = 4'b0001  */
    UINT16 negotiated_link_width : 6;
    /* negotiated_link_width - Bits[9:4], RO_V, default = 6'b000001  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 link_training : 1;
    /* link_training - Bits[11:11], RO_V, default = 1'b0  */
    UINT16 slot_clock_configuration : 1;
    /* slot_clock_configuration - Bits[12:12], RW_O, default = 1'b1  */
    UINT16 data_link_layer_link_active : 1;
    /* data_link_layer_link_active - Bits[13:13], RO_V, default = 1'b0  */
    UINT16 link_bandwidth_management_status : 1;
    /* link_bandwidth_management_status - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_status : 1;
    /* link_autonomous_bandwidth_status - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} LNKSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SLTCAP_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x400120A4)                                                     */
/* Register default value:              0x00000000                            */
#define SLTCAP_IIO_PCIEIOSF2_REG 0x150240A4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0a4
 */
typedef union {
  struct {
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[0:0], RW_O, default = 1'b0 
       This bit indicates that the Attention Button event signal is routed (from slot 
       or on-board in the chassis) to the IIO's hotplug controller. 
       0: indicates that an Attention Button signal is routed to IIO
       1: indicates that an Attention Button is not routed to IIO
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_controller_present : 1;
    /* power_controller_present - Bits[1:1], RW_O, default = 1'b0 
       This bit indicates that a software controllable power controller is implemented 
       on the chassis for this slot. 
       0: indicates that a software controllable power controller is not present
       1: indicates that a software controllable power controller is present
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 mrl_sensor_present : 1;
    /* mrl_sensor_present - Bits[2:2], RW_O, default = 1'b0 
       This bit indicates that an MRL Sensor is implemented on the chassis for this 
       slot. 
       0: indicates that an MRL Sensor is not present
       1: indicates that an MRL Sensor is present
       BIOS programs this field with a 0 for Express Module FF always. If CEM slot is 
       hotplug capable, BIOS programs this field with either 0 or 1 depending on system 
       design. 
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[3:3], RW_O, default = 1'b0 
       This bit indicates that an Attention Indicator is implemented for this slot and 
       is electrically controlled by the chassis 
       0: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_indicator_present : 1;
    /* power_indicator_present - Bits[4:4], RW_O, default = 1'b0 
       This bit indicates that a Power Indicator is implemented for this slot and is 
       electrically controlled by the chassis. 
       0: indicates that a Power Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that Power Indicator that is electrically controlled by the chassis 
       is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 hot_plug_surprise : 1;
    /* hot_plug_surprise - Bits[5:5], RW_O, default = 1'b0 
       This field indicates that a device in this slot may be removed from the system 
       without prior notification. This field is initialized by BIOS. 
       0: indicates that hot-plug surprise is not supported
       1: indicates that hot-plug surprise is supported
       Generally this bit is not expected to be set because the only know usage case 
       for this is the ExpressCard FF. But that is not really expected usage in the 
       processor context. But this bit is present regardless to allow a usage if it 
       arises. 
       This bit is used by IIO hardware to determine if a transition from DL_active to 
       DL_Inactive is to be treated as a surprise down error or not. If a port is 
       associated with a hotpluggable slot and the hotplug surprise bit is set, then 
       any transition to DL_Inactive is not considered an error. Refer to PCI Express 
       Base Specification, Revision 2.0 for further details. 
     */
    UINT32 hot_plug_capable : 1;
    /* hot_plug_capable - Bits[6:6], RW_O, default = 1'b0 
       This field defines hot-plug support capabilities for the PCI Express port.
       0: indicates that this slot is not capable of supporting Hot-plug operations.
       1: indicates that this slot is capable of supporting Hot-plug operations
       This bit is programed by BIOS based on the system design. This bit must be 
       programmed by bios to be consistent with the VPP enable bit for the port. 
     */
    UINT32 slot_power_limit_value : 8;
    /* slot_power_limit_value - Bits[14:7], RW_O, default = 8'b00000000 
       This field specifies the upper limit on power supplied by slot in conjunction 
       with the Slot Power Limit Scale value. This field is initialized by BIOS. IIO 
       uses this field when it sends a Set_Slot_Power_Limit message on PCI Express. 
       Writes to this register trigger a Set_Slot_Power_Limit message to be sent. The 
       IIO sends the Set_Slot_Power_Limit message on the link at first link up 
       condition (except on the DMI link operating in DMI mode) without regards to 
       whether this register and the Slot Power Limit Scale register are programmed yet 
       by BIOS. 
     */
    UINT32 slot_power_limit_scale : 2;
    /* slot_power_limit_scale - Bits[16:15], RW_O, default = 2'b00 
       This field specifies the scale used for the Slot Power Limit Value and is 
       initialized by BIOS. IIO uses this field when it sends a Set_Slot_Power_Limit 
       message on PCI Express. 
       Range of Values:
       00: 1.0x
       01: 0.1x
       10: 0.01x
       11: 0.001x
       Writes to this register trigger a Set_Slot_Power_Limit message to be sent.
     */
    UINT32 electromechanical_interlock_present : 1;
    /* electromechanical_interlock_present - Bits[17:17], RW_O, default = 1'b0 
       This bit when set indicates that an Electromechanical Interlock is implemented 
       on the chassis for this slot and that lock is controlled by bit 11 in Slot 
       Control register. This field is initialized by BIOS based on the system 
       architecture. 
       BIOS note: this capability is not set if the Electromechanical Interlock control 
       is connected to main slot power control. 
       This is expected to be used only for Express Module hotpluggable slots.
     */
    UINT32 command_complete_not_capable : 1;
    /* command_complete_not_capable - Bits[18:18], RO, default = 1'b0 
       The processor is capable of command complete interrupt.
     */
    UINT32 physical_slot_number : 13;
    /* physical_slot_number - Bits[31:19], RW_O, default = 13'b0000000000000 
       This field indicates the physical slot number of the slot connected to the PCI 
       Express port and is initialized by BIOS. 
     */
  } Bits;
  UINT32 Data;
} SLTCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SLTCON_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x200120A8)                                                     */
/* Register default value:              0x07C0                                */
#define SLTCON_IIO_PCIEIOSF2_REG 0x150220A8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Any write to this register will set the Command Completed bit in the SLTSTS 
 * register, ONLY if the VPP enable bit for the port is set. If the port's VPP 
 * enable bit is set (i.e. hotplug for that slot is enabled), then the required 
 * actions on VPP are completed before the Command Completed bit is set in the 
 * SLTSTS register. If the VPP enable bit for the port is clear, then the write 
 * simply updates this register (see individual bit definitions for details) but 
 * the Command Completed bit in the SLTSTS register is not set 
 */
typedef union {
  struct {
    UINT16 attention_button_pressed_enable : 1;
    /* attention_button_pressed_enable - Bits[0:0], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via an 
       attention button pressed event. 
       0: disables generation of hot-plug interrupts or wake messages when the 
       attention button is pressed. 
       1: Enables generation of hot-plug interrupts or wake messages when the attention 
       button is pressed. 
     */
    UINT16 power_fault_detected_enable : 1;
    /* power_fault_detected_enable - Bits[1:1], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       power fault event. 
       0: disables generation of hot-plug interrupts or wake messages when a power 
       fault event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when a power fault 
       event happens. 
     */
    UINT16 mrl_sensor_changed_enable : 1;
    /* mrl_sensor_changed_enable - Bits[2:2], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       MRL Sensor changed event. 
       0: disables generation of hot-plug interrupts or wake messages when an MRL 
       Sensor changed event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when an MRL Sensor 
       changed event happens. 
     */
    UINT16 presence_detect_changed_enable : 1;
    /* presence_detect_changed_enable - Bits[3:3], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       presence detect changed event. 
       0: disables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
       1- Enables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
     */
    UINT16 command_completed_interrupt_enable : 1;
    /* command_completed_interrupt_enable - Bits[4:4], RW, default = 1'b0 
       This field enables software notification (Interrupt - MSI/INTx or WAKE) when a 
       command is completed by the Hot-plug controller connected to the PCI Express 
       port 
       0: disables hot-plug interrupts on a command completion by a hot-plug Controller
       1: Enables hot-plug interrupts on a command completion by a hot-plug Controller
     */
    UINT16 hot_plug_interrupt_enable : 1;
    /* hot_plug_interrupt_enable - Bits[5:5], RW, default = 1'b0 
       When set to 1b, this bit enables generation of Hot-Plug interrupt (MSI or INTx 
       interrupt depending on the setting of the MSI enable bit on enabled Hot-Plug 
       events, provided ACPI mode for hotplug is disabled. 
       0: disables interrupt generation on Hot-plug events
       1: enables interrupt generation on Hot-plug events
     */
    UINT16 attention_indicator_control : 2;
    /* attention_indicator_control - Bits[7:6], RW, default = 2'b11 
       If an Attention Indicator is implemented, writes to this field will set the 
       Attention Indicator to the written state. Reads of this field reflect the value 
       from the latest write, even if the corresponding hot-plug command is not 
       executed yet at the VPP, unless software issues a write without waiting for the 
       previous command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (Processor drives 1 Hz square wave)
       11: Off
       IIO does not generated the Attention_Indicator_On/Off/Blink messages on PCI 
       Express when this field is written to by software. 
     */
    UINT16 power_indicator_control : 2;
    /* power_indicator_control - Bits[9:8], RW, default = 2'b11 
       If a Power Indicator is implemented, writes to this field will set the Power 
       Indicator to the written state. Reads of this field must reflect the value from 
       the latest write, even if the corresponding hot-plug command is not executed yet 
       at the VPP, unless software issues a write without waiting for the previous 
       command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (IIO drives 1 Hz square wave for Chassis mounted LEDs)
       11: Off
       IIO does not generated the Power_Indicator_On/Off/Blink messages on PCI Express 
       when this field is written to by software. 
     */
    UINT16 power_controller_control : 1;
    /* power_controller_control - Bits[10:10], RWS, default = 1'b1 
       If a power controller is implemented, when writes to this field will set the 
       power state of the slot per the defined encodings. Reads of this field must 
       reflect the value from the latest write, even if the corresponding hot-plug 
       command is not executed yet at the VPP, unless software issues a write without 
       waiting for the previous command to complete in which case the read value is 
       undefined. 
       0: Power On
       1: Power Off
       Note: If the link experiences an unexpected DL_Down condition that is not the 
       result of a Hot Plug removal, the processor follows the PCI Express 
       specification for logging Surprise Link Down. SW is required to set SLTCON[10] 
       to 0 (Power On) in all devices that do not connect to a slot that supports 
       Hot-Plug to enable logging of this error in that device. 
       For devices connected to slots supporting Hot-Plug operations, SLTCON[10] usage 
       to control PWREN# assertion is as described elsewhere. 
     */
    UINT16 electromechanical_interlock_control : 1;
    /* electromechanical_interlock_control - Bits[11:11], RW, default = 1'b0 
       When software writes either a 1 to this bit, IIO pulses the EMIL pin per PCI 
       Express Server/Workstation Module Electromechanical Spec Rev 1.0. Write of 0 has 
       no effect. This bit always returns a 0 when read. If electromechanical lock is 
       not implemented, then either a write of 1 or 0 to this register has no effect. 
     */
    UINT16 data_link_layer_state_changed_enable : 1;
    /* data_link_layer_state_changed_enable - Bits[12:12], RWS, default = 1'b0 
       When set to 1, this field enables software notification when Data Link Layer 
       Link Active bit in the LNKSTS register changes state 
     */
    UINT16 rsvd : 3;
    /* rsvd - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTCON_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* SLTSTS_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x200120AA)                                                     */
/* Register default value:              0x0000                                */
#define SLTSTS_IIO_PCIEIOSF2_REG 0x150220AA

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0aa
 */
typedef union {
  struct {
    UINT16 attention_button_pressed : 1;
    /* attention_button_pressed - Bits[0:0], RW1C, default = 1'b0 
       This bit is set by IIO when the attention button is pressed. It is subsequently 
       cleared by software after the field has been read and processed.Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
       IIO silently discards the Attention_Button_Pressed message if received from PCI 
       Express link without updating this bit. 
     */
    UINT16 power_fault_detected : 1;
    /* power_fault_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit is set by IIO when a power fault event is detected by the power 
       controller (which is reported via the VPP bit stream). It is subsequently 
       cleared by software after the field has been read and processed. Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
     */
    UINT16 mrl_sensor_changed : 1;
    /* mrl_sensor_changed - Bits[2:2], RW1C, default = 1'b0 
       This bit is set if the value reported in bit 5 changes. It is subsequently 
       cleared by software after the field has been read and processed. 
     */
    UINT16 presence_detect_changed : 1;
    /* presence_detect_changed - Bits[3:3], RW1C, default = 1'b0 
       This bit is set by IIO when the value reported in bit 6 is changes. It is 
       subsequently cleared by software after the field has been read and processed. 
     */
    UINT16 command_completed : 1;
    /* command_completed - Bits[4:4], RW1C, default = 1'b0 
       This bit is set by IIO when the hot-plug command has completed and the hot-plug 
       controller is ready to accept a subsequent command. It is subsequently cleared 
       by software after the field has been read and processed. This bit provides no 
       guarantee that the action corresponding to the command is complete. Any write to 
       SLTCON (regardless of the port is capable or enabled for hot-plug) is considered 
       a 'hot-plug' command. 
       If the port is not hot-plug capable or hot-plug enabled, then the hot-plug 
       command does not trigger any action on the VPP port but the command is still 
       completed via this bit. 
     */
    UINT16 mrl_sensor_state : 1;
    /* mrl_sensor_state - Bits[5:5], RO_V, default = 1'b0 
       This bit reports the status of an MRL sensor if it is implemented.
       0: MRL Closed
       1: MRL Open
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 presence_detect_state : 1;
    /* presence_detect_state - Bits[6:6], RO_V, default = 1'b0 
       For ports with slots (where the Slot Implemented bit of the PCI Express 
       Capabilities Registers is 1b), this field is the logical OR of the Presence 
       Detect status determined via an in-band mechanism and sideband Present Detect 
       pins. Refer to how PCI Express Base Specification, Revision 2.0 for how the 
       inband presence detect mechanism works (certain states in the LTSSM constitute 
       'card present' and others don't). 
       0: Card/Module slot empty
       1: Card/module Present in slot (powered or unpowered)
       For ports with no slots, IIO hardwires this bit to 1b.
       Note: OS could get confused when it sees an empty PCI Express root port i.e. 'no 
       slots + no presence', since this is now disallowed in the spec. So bios must 
       hide all unused root ports devices in IIO config space, via the DEVHIDE 
       register. 
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 electromechanical_latch_status : 1;
    /* electromechanical_latch_status - Bits[7:7], RO_V, default = 1'b0 
       When read this register returns the current state of the Electromechanical 
       Interlock (the EMILS pin) which has the defined encodings as: 
       0: Electromechanical Interlock Disengaged
       1: Electromechanical Interlock Engaged
     */
    UINT16 data_link_layer_state_changed : 1;
    /* data_link_layer_state_changed - Bits[8:8], RW1C, default = 1'b0 
       This bit is set (if it is not already set) when the state of the Data Link Layer 
       Link Active bit in the Link Status register changes. Software must read Data 
       Link Layer Active field to determine the link state before initiating 
       configuration cycles to the hot plugged device. 
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ROOTCON_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x200120AC)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCON_IIO_PCIEIOSF2_REG 0x150220AC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT16 seceen : 1;
    /* seceen - Bits[0:0], RW, default = 1'b0 
       System Error on Correctable Error Enable
       This field controls notifying the internal IIO core error logic of the 
       occurrence of a correctable error in the device or below its hierarchy. The 
       internal core error logic of IIO then decides if/how to escalate the error 
       further (pins/message etc). 
       1: indicates that an internal core error logic notification should be generated 
       if a correctable error (ERR_COR) is reported by any of the devices in the 
       hierarchy associated with and including this port. 
       0: No internal core error logic notification should be generated on a 
       correctable error (ERR_COR) reported by any of the devices in the hierarchy 
       associated with and including this port. 
       Note that generation of system notification on a PCI Express correctable error 
       is orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a correctable error or software 
       can chose one of the two. 
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode correctable errors, BIOS must set MISCCTRLSTS[33] to a 1 to override 
       this bit on Device#0 in DMI mode. 
       
     */
    UINT16 senfeen : 1;
    /* senfeen - Bits[1:1], RW, default = 1'b0 
       System Error on Non-Fatal Error Enable
       This field enables notifying the internal IIO core error logic of occurrence of 
       an uncorrectable non-fatal error at the port or below its hierarchy. The 
       internal IIO core error logic then decides if/how to escalate the error further 
       (pins/message etc). 
       1: indicates that a internal IIO core error logic notification should be 
       generated if a non-fatal error (ERR_NONFATAL) is reported by any of the devices 
       in the hierarchy associated with and including this port. 
       0: No internal core error logic notification should be generated on a non-fatal 
       error (ERR_NONFATAL) reported by any of the devices in the hierarchy associated 
       with and including this port. 
       Note that generation of system notification on a PCI Express non-fatal error is 
       orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a non-fatal error or software can 
       chose one of the two. 
       
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode non-fatal errors, BIOS must set MISCCTRLSTS[34] to a 1 to override this 
       bit on Device#0 in DMI mode. 
     */
    UINT16 sefeen : 1;
    /* sefeen - Bits[2:2], RW, default = 1'b0 
       System Error on Fatal Error Enable
       This field enables notifying the internal IIO core error logic of occurrence of 
       an uncorrectable fatal error at the port or below its hierarchy. The internal 
       core error logic of IIO then decides if/how to escalate the error further 
       (pins/message etc). Refer to RAS Chapter for details of how/which system 
       notification is generated for a PCI Express fatal error. 
       1: indicates that an internal IIO core error logic notification should be 
       generated if a fatal error (ERR_FATAL) is reported by any of the devices in the 
       hierarchy associated with and including this port. 
       0: No internal IIO core error logic notification should be generated on a fatal 
       error (ERR_FATAL) reported by any of the devices in the hierarchy associated 
       with and including this port. 
       Note that generation of system notification on a PCI Express fatal error is 
       orthogonal to generation of an MSI/INTx interrupt for the same error. Both a 
       system error and MSI/INTx can be generated on a fatal error or software can 
       chose one of the two. 
       Refer to PCI Express Base Specification, Revision 2.0 for details of how this 
       bit is used in conjunction with other error control bits to generate core logic 
       notification of error events in a PCI Express port. 
       Note that since this register is defined only in PCIe mode for Device#0, this 
       bit will read a 0 in DMI mode. So, to enable core error logic notification on 
       DMI mode fatal errors, BIOS must set bit MISCCTRLSTS[35] to a 1 to override this 
       bit in DMI mode. 
     */
    UINT16 pmeinten : 1;
    /* pmeinten - Bits[3:3], RW, default = 1'b0 
       This field controls the generation of MSI interrupts/INTx interrupts for PME 
       messages. 
       
       1: Enables interrupt generation upon receipt of a PME message
       0: Disables interrupt generation for PME messages
     */
    UINT16 crsswvisen : 1;
    /* crsswvisen - Bits[4:4], RW, default = 1'b0 
       CRS software visibility Enable
       1: The Root Port to returns Configuration Request Retry Status (CRS) Completion 
       Status to software by returning data of 0x01 when a configuration retry is 
       returned by the connected device. 
       0: Retry status cannot be returned to software so the Configuration Request is 
       re-issued to the connected device, unless the Configuration Retry Timer expires. 
       If the timer expires, then a master abort response is returned to software. 
     */
    UINT16 rsvd : 11;
    /* rsvd - Bits[15:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCON_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ROOTCAP_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x200120AE)                                                     */
/* Register default value:              0x0001                                */
#define ROOTCAP_IIO_PCIEIOSF2_REG 0x150220AE

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0ae
 */
typedef union {
  struct {
    UINT16 crs_software_visibility : 1;
    /* crs_software_visibility - Bits[0:0], RO, default = 1'b1 
       This bit, when set, indicates that the Root Port is capable of returning 
       Configuration Request Retry Status (CRS) Completion Status to software. The 
       processor supports this capability. 
     */
    UINT16 rsvd : 15;
    /* rsvd - Bits[15:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ROOTSTS_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x400120B0)                                                     */
/* Register default value:              0x00000000                            */
#define ROOTSTS_IIO_PCIEIOSF2_REG 0x150240B0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0b0
 */
typedef union {
  struct {
    UINT32 pme_requester_id : 16;
    /* pme_requester_id - Bits[15:0], RO_V, default = 16'b0000000000000000 
       This field indicates the PCI requester ID of the last PME requestor. If the root 
       port itself was the source of the (virtual) PME message, then a RequesterID of 
       CPUBUSNO0:DevNo:FunctionNo is logged in this field. 
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[16:16], RW1C, default = 1'b0 
       This field indicates a PM_PME message (either from the link or internally from 
       within that root port) was received at the port.1: PME was asserted by a 
       requester as indicated by the PME Requester ID field 
       This bit is cleared by software by writing a '1'. Note that the root port itself 
       could be the source of a PME event when a hotplug event is observed when the 
       port is in D3hot state. 
     */
    UINT32 pme_pending : 1;
    /* pme_pending - Bits[17:17], RO_V, default = 1'b0 
       This field indicates that another PME is pending when the PME Status bit is set. 
       When the PME Status bit is cleared by software; the pending PME is delivered by 
       hardware by setting the PME Status bit again and updating the Requestor ID 
       appropriately. The PME pending bit is cleared by hardware if no more PMEs are 
       pending. 
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ROOTSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCAP2_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x400120B4)                                                     */
/* Register default value:              0x000013BE                            */
#define DEVCAP2_IIO_PCIEIOSF2_REG 0x150240B4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0b4
 */
typedef union {
  struct {
    UINT32 cmpltovalsup : 4;
    /* cmpltovalsup - Bits[3:0], RO, default = 4'b1110  */
    UINT32 cmpltodissup : 1;
    /* cmpltodissup - Bits[4:4], RO, default = 1'b1  */
    UINT32 ari_en : 1;
    /* ari_en - Bits[5:5], RW_LB, default = 1'b1 
       1
     */
    UINT32 atomicroutsup : 1;
    /* atomicroutsup - Bits[6:6], RO, default = 1'b0  */
    UINT32 atomic32bcompsup : 1;
    /* atomic32bcompsup - Bits[7:7], RO, default = 1'b1  */
    UINT32 atomic64bcompsup : 1;
    /* atomic64bcompsup - Bits[8:8], RO, default = 1'b1  */
    UINT32 atomic128bcascompsup : 1;
    /* atomic128bcascompsup - Bits[9:9], RO, default = 1'b1  */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ltr_en : 1;
    /* ltr_en - Bits[11:11], RW_LB, default = 1'b0  */
    UINT32 tph_completer_supported : 2;
    /* tph_completer_supported - Bits[13:12], RW_LB, default = 2'b01 
       1
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP2_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* DEVCTRL2_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x200120B8)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL2_IIO_PCIEIOSF2_REG 0x150220B8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Express Device Control 2
 */
typedef union {
  struct {
    UINT16 compltoval : 4;
    /* compltoval - Bits[3:0], RW, default = 4'b0000 
       Completion Timeout Value on NP Tx that IIO issues on PCIe/DMI
       In Devices that support Completion Timeout programmability, this field allows 
       system software to modify the Completion Timeout range. The following encodings 
       and corresponding timeout ranges are defined: 
       0000b = 10ms to 50ms
       0001b = Reserved (IIO aliases to 0000b)
       0010b = Reserved (IIO aliases to 0000b)
       0101b = 16ms to 55ms
       0110b = 65ms to 210ms
       1001b = 260ms to 900ms
       1010b = 1s to 3.5s
       1101b = 4s to 13s
       1110b = 17s to 64s
       
       When software selects 17s to 64s range, CTOCTRL further controls the timeout 
       value within that range. For all other ranges selected by OS, the timeout value 
       within that range is fixed in IIO hardware. 
       Software can change this field while there is active traffic in the root port.
       This value will also be used to control PME_TO_ACK Timeout. That is this field 
       sets the timeout value for receiving a PME_TO_ACK message after a PME_TURN_OFF 
       message has been transmitted. The PME_TO_ACK Timeout has meaning only if bit 6 
       of MISCCTRLSTS register is set to a 1b. 
     */
    UINT16 compltodis : 1;
    /* compltodis - Bits[4:4], RW, default = 1'b0 
       Completion Timeout Disable
       When set to 1b, this bit disables the Completion Timeout mechanism for all NP tx 
       that IIO issues on the PCIE/DMI link. When 0b, completion timeout is enabled. 
       Software can change this field while there is active traffic in the root/DMI 
       port. 
     */
    UINT16 ari : 1;
    /* ari - Bits[5:5], RW_L, default = 1'b0 
       Alternative RID InterpretationEnable
       Applies only to root ports. When set to 1b, ARI is enabled for the Root Port. 
       For Device#0 in DMI mode, this bit is ignored. 
     */
    UINT16 atomicreqen : 1;
    /* atomicreqen - Bits[6:6], RO, default = 1'b0  */
    UINT16 atomicegressblock : 1;
    /* atomicegressblock - Bits[7:7], RO, default = 1'b0  */
    UINT16 rsvd_8 : 2;
    /* rsvd_8 - Bits[9:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 ltr_en : 1;
    /* ltr_en - Bits[10:10], RW_LV, default = 1'b0  */
    UINT16 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL2_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCAP2_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x400120BC)                                                     */
/* Register default value:              0x00000000                            */
#define LNKCAP2_IIO_PCIEIOSF2_REG 0x150240BC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0bc
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lnkspdvec : 7;
    /* lnkspdvec - Bits[7:1], RW_O, default = 7'b0000000  */
    UINT32 rsvd_8 : 24;
    /* rsvd_8 - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCAP2_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LNKCON2_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x200120C0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON2_IIO_PCIEIOSF2_REG 0x150220C0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0c0
 */
typedef union {
  struct {
    UINT16 target_link_speed : 4;
    /* target_link_speed - Bits[3:0], RO, default = 4'b0000  */
    UINT16 enter_compliance : 1;
    /* enter_compliance - Bits[4:4], RO, default = 1'b0  */
    UINT16 hardware_autonomous_speed_disable : 1;
    /* hardware_autonomous_speed_disable - Bits[5:5], RO, default = 1'b0  */
    UINT16 selectable_de_emphasis : 1;
    /* selectable_de_emphasis - Bits[6:6], RO, default = 1'b0  */
    UINT16 transmit_margin : 3;
    /* transmit_margin - Bits[9:7], RO, default = 3'b000  */
    UINT16 enter_modified_compliance : 1;
    /* enter_modified_compliance - Bits[10:10], RO, default = 1'b0  */
    UINT16 compliance_sos : 1;
    /* compliance_sos - Bits[11:11], RO, default = 1'b0  */
    UINT16 compliance_de_emphasis : 4;
    /* compliance_de_emphasis - Bits[15:12], RO, default = 4'b0000  */
  } Bits;
  UINT16 Data;
} LNKCON2_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PMCAP_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x400120E0)                                                     */
/* Register default value:              0xC8030001                            */
#define PMCAP_IIO_PCIEIOSF2_REG 0x150240E0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0e0
 */
typedef union {
  struct {
    UINT32 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000001 
       Provides the PM capability ID assigned by PCI-SIG.
     */
    UINT32 next_capability_pointer : 8;
    /* next_capability_pointer - Bits[15:8], RO, default = 8'b00000000 
       This is the last capability in the chain and hence set to 0.
     */
    UINT32 version : 3;
    /* version - Bits[18:16], RO, default = 3'b011 
       This field is set to 3h (PM 1.2 compliant) as version number.
     */
    UINT32 pme_clock : 1;
    /* pme_clock - Bits[19:19], RO, default = 1'b0 
       This field is hardwired to 0h as it does not apply to PCI Express.
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[20:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 device_specific_initialization : 1;
    /* device_specific_initialization - Bits[21:21], RO, default = 1'b0  */
    UINT32 aux_current : 3;
    /* aux_current - Bits[24:22], RO, default = 3'b000  */
    UINT32 d1_support : 1;
    /* d1_support - Bits[25:25], RO, default = 1'b0 
       I/OxAPIC does not support power management state D1.
     */
    UINT32 d2_support : 1;
    /* d2_support - Bits[26:26], RO, default = 1'b0 
       I/OxAPIC does not support power management state D2.
     */
    UINT32 pme_support : 5;
    /* pme_support - Bits[31:27], RO_V, default = 5'b11001 
       Bits 31, 30 and 27 must be set to \q1\q for PCI-PCI bridge structures 
       representing ports on root complexes. 
     */
  } Bits;
  UINT32 Data;
} PMCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PMCSR_IIO_PCIEIOSF2_REG supported on:                                      */
/*       BDX (0x400120E4)                                                     */
/* Register default value:              0x00000008                            */
#define PMCSR_IIO_PCIEIOSF2_REG 0x150240E4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x0e4
 */
typedef union {
  struct {
    UINT32 power_state : 2;
    /* power_state - Bits[1:0], RW, default = 2'b00 
       This 2-bit field is used to determine the current power state of the function 
       and to set a new power state as well. 
       00: D0
       01: D1 (not supported by IOAPIC)
       10: D2 (not supported by IOAPIC)
       11: D3_hot
       If Software tries to write 01 or 10 to this field, the power state does not 
       change from the existing power state (which is either D0 or D3hot) and nor do 
       these bits1:0 change value. 
       When in D3hot state, I/OxAPIC will
       a) respond to only Type 0 configuration transactions targeted at the device's 
       configuration space, when in D3hot state 
       c) will not respond to memory (i.e. D3hot state is equivalent to MSE ), accesses 
       to MBAR region (note: ABAR region access still go through in D3hot state, if it 
       enabled) 
       d) will not generate any MSI writes
     */
    UINT32 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 no_soft_reset : 1;
    /* no_soft_reset - Bits[3:3], RW_O, default = 1'b1 
       Indicates I/OxAPIC does not reset its registers when transitioning from D3hot to 
       D0. 
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pme_enable : 1;
    /* pme_enable - Bits[8:8], RWS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data_select : 4;
    /* data_select - Bits[12:9], RO, default = 4'b0000 
       Not relevant for I/OxAPIC
     */
    UINT32 data_scale : 2;
    /* data_scale - Bits[14:13], RO, default = 2'b00 
       Not relevant for I/OxAPIC
     */
    UINT32 pme_status : 1;
    /* pme_status - Bits[15:15], RW1CS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 rsvd_16 : 6;
    /* rsvd_16 - Bits[21:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 b2_b3_support : 1;
    /* b2_b3_support - Bits[22:22], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 bus_power_clock_control_enable : 1;
    /* bus_power_clock_control_enable - Bits[23:23], RO, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data : 8;
    /* data - Bits[31:24], RO, default = 8'b00000000 
       Not relevant for I/OxAPIC
     */
  } Bits;
  UINT32 Data;
} PMCSR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPREUT_HDR_EXT_IIO_PCIEIOSF2_REG supported on:                             */
/*       BDX (0x40012100)                                                     */
/* Register default value:              0x1101000B                            */
#define XPREUT_HDR_EXT_IIO_PCIEIOSF2_REG 0x15024100

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * REUT PCIe Header Extended
 */
typedef union {
  struct {
    UINT32 pciecapid : 16;
    /* pciecapid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe Extended CapID
       This field has the value 0Bh to identify the CAP_ID assigned by the PCI SIG 
       indicating a vendor specific capability. 
     */
    UINT32 pciecapversion : 4;
    /* pciecapversion - Bits[19:16], RO, default = 4'b0001 
       Capability Version
       This field is a PCI-SIG defined version number that indicates the nature and 
       format of the extended capability. This indicates the version of the REUT 
       Capability. 
     */
    UINT32 pcienextptr : 12;
    /* pcienextptr - Bits[31:20], RO, default = 12'b000100010000 
       Next Capability Pointer
       This field contains the offset to the next PCI capability structure or 00h if no 
       other items exist in the linked list of capabilities. 
       In DMI Mode, it points to the Vendor Specific Error Capability.
       In PCIe Mode, it points to the ACS Capability.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_EXT_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPREUT_HDR_CAP_IIO_PCIEIOSF2_REG supported on:                             */
/*       BDX (0x40012104)                                                     */
/* Register default value:              0x00C00002                            */
#define XPREUT_HDR_CAP_IIO_PCIEIOSF2_REG 0x15024104

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * REUT Header Capability
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000010 
       This field is a Intel-defined ID number that indicates the nature and format of 
       the VSEC structure. Software must qualify the Vendor ID before interpreting this 
       field. 
     */
    UINT32 vsecidrev : 4;
    /* vsecidrev - Bits[19:16], RO, default = 4'b0000 
       This field is defined as the version number that indicates the nature and format 
       of the VSEC structure. Software must quality the Vendor ID before interpreting 
       this field. 
     */
    UINT32 vseclength : 12;
    /* vseclength - Bits[31:20], RO, default = 12'b000000001100 
       This field defines the length of the REUT 'capability body'. The size of the 
       leaf body is 12 bytes including the _EXT, _CAP and _LEF registers. 
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_CAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPREUT_HDR_LEF_IIO_PCIEIOSF2_REG supported on:                             */
/*       BDX (0x40012108)                                                     */
/* Register default value:              0x00003807                            */
#define XPREUT_HDR_LEF_IIO_PCIEIOSF2_REG 0x15024108

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT32 leafreutengid : 8;
    /* leafreutengid - Bits[7:0], RO_V, default = 8'b00000111 
       This field identifies the REUT engine associated with the link (same as the REUT 
       ID). 
     */
    UINT32 leafreutdevnum : 8;
    /* leafreutdevnum - Bits[15:8], RO_V, default = 8'b00111000 
       This field identifies the PCI Device/Function # where the REUT engine associated 
       with this link resides. 
       Device6 = 00110b & function0 = 000b = 30h
       Device6 = 00110b & function1 = 001b = 31h
       Device6 = 00110b & function2 = 010b = 32h
       Device6 = 00110b & function3 = 011b = 33h
       Device6 = 00110b & function4 = 100b = 34h
       Device6 = 00110b & function5 = 101b = 35h
       Device6 = 00110b & function6 = 110b = 36h
       Device7 = 00111b & function0 = 000b = 38h
       Device7 = 00111b & function1 = 001b = 39h
       Device7 = 00111b & function2 = 010b = 3Ah
       Device7 = 00111b & function3 = 011b = 3Bh
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_LEF_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ACSCAPHDR_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x40012110)                                                     */
/* Register default value:              0x1481000D                            */
#define ACSCAPHDR_IIO_PCIEIOSF2_REG 0x15024110

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Access Control Services Extended Capability Header
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000001101 
       Assigned for Access Control Services capability by PCISIG.
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001 
       Capability version of the PCI Express logic.
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO_V, default = 12'b000101001000 
       This field points to the next Capability in extended configuration space.
     */
  } Bits;
  UINT32 Data;
} ACSCAPHDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ACSCAP_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x20012114)                                                     */
/* Register default value:              0x001F                                */
#define ACSCAP_IIO_PCIEIOSF2_REG 0x15022114

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x114
 */
typedef union {
  struct {
    UINT16 v : 1;
    /* v - Bits[0:0], RO, default = 1'b1  */
    UINT16 b : 1;
    /* b - Bits[1:1], RO, default = 1'b1  */
    UINT16 r : 1;
    /* r - Bits[2:2], RO, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS P2P 
       Request Redirect. 
     */
    UINT16 c : 1;
    /* c - Bits[3:3], RO, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS P2P 
       Completion Redirect. 
     */
    UINT16 u : 1;
    /* u - Bits[4:4], RO, default = 1'b1 
       Applies only to root portsIndicates that the component implements ACS Upstream 
       Forwarding. 
     */
    UINT16 e : 1;
    /* e - Bits[5:5], RO, default = 1'b0 
       Applies only to root portsIndicates that the component does not implement ACS 
       P2P Egress Control. 
     */
    UINT16 t : 1;
    /* t - Bits[6:6], RO, default = 1'b0 
       Applies only to root portsIndicates that the component does not implement ACS 
       Direct Translated P2P. 
     */
    UINT16 rsvd : 1;
    /* rsvd - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 egress_control_vector_size : 8;
    /* egress_control_vector_size - Bits[15:8], RO, default = 8'b00000000 
       N/A for IIO
     */
  } Bits;
  UINT16 Data;
} ACSCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ACSCTRL_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x20012116)                                                     */
/* Register default value:              0x0000                                */
#define ACSCTRL_IIO_PCIEIOSF2_REG 0x15022116

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x116
 */
typedef union {
  struct {
    UINT16 v : 1;
    /* v - Bits[0:0], RW, default = 1'b0 
       Applies only to root portsWhen set, the component validates the Bus Number from 
       the Requester ID of upstream Requests against the secondary / subordinate Bus 
       Numbers. 
     */
    UINT16 b : 1;
    /* b - Bits[1:1], RW, default = 1'b0 
       Applies only to root portsWhen set, the component blocks all upstream Memory 
       Requests whose Address Translation (AT) field is not set to the default value. 
     */
    UINT16 r : 1;
    /* r - Bits[2:2], RW, default = 1'b0 
       When this bit is set, transactions arriving from a root port that target the 
       same port back down, will be forwarded. Normally such traffic would be aborted. 
       Applies only to root ports. 
     */
    UINT16 c : 1;
    /* c - Bits[3:3], RW, default = 1'b0 
       Applies only to root portsDetermines when the component redirects peer-to-peer 
       Completions upstream; applicable only to Read Completions whose Relaxed Ordering 
       Attribute is clear. 
     */
    UINT16 u : 1;
    /* u - Bits[4:4], RW, default = 1'b0 
       When this bit is set, transactions arriving from a root port that target the 
       same port back down, will be forwarded. Normally such traffic would be aborted. 
       Applies only to root ports. 
     */
    UINT16 e : 1;
    /* e - Bits[5:5], RO, default = 1'b0 
       Applies only to root portsThe component does not implement ACS P2P Egress 
       Control and hence this bit should not be used by SW. 
     */
    UINT16 t : 1;
    /* t - Bits[6:6], RO, default = 1'b0 
       Applies only to root portsThis is hardwired to 0b as the component does not 
       implement ACS Direct Translated P2P. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[15:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ACSCTRL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* APICBASE_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x20012140)                                                     */
/* Register default value:              0x0000                                */
#define APICBASE_IIO_PCIEIOSF2_REG 0x15022140

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x140
 */
typedef union {
  struct {
    UINT16 en : 1;
    /* en - Bits[0:0], RW, default = 1'b0 
       enables the decode of the APIC window
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       These are addr bits 19:9. Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a 
       don't care for address decode. Address decoding to the APIC range is done as 
       APICBASE.ADDR[31:9] &lt;= A[31:9] &lt;= APICLIMIT.ADDR[31:9]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if bit 0 is set, even if the MSE bit of the root port is clear or the 
       root port itself is in D3hot state. 
     */
    UINT16 rsvd : 4;
    /* rsvd - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICBASE_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* APICLIMIT_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x20012142)                                                     */
/* Register default value:              0x0000                                */
#define APICLIMIT_IIO_PCIEIOSF2_REG 0x15022142

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x142
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Applies only to root ports. These are addr bits 19:9. Bits 31:20 are assumed to 
       be 0xFECh. Bits 8:0 are a don't care for address decode. Address decoding to the 
       APIC range is done as APICBASE.ADDR[31:9] &lt;= A[31:9] &lt;= 
       APICLIMIT.ADDR[31:9]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if the range is enabled, even if the MSE bit of the root port is clear 
       or the root 
       port itself is in D3hot state.
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICLIMIT_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRCAPHDR_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x40012148)                                                     */
/* Register default value:              0x1D010001                            */
#define ERRCAPHDR_IIO_PCIEIOSF2_REG 0x15024148

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000000001 
       Assigned for advanced error reporting.
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001 
       Version of the PCI Express logic.
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO_V, default = 12'b000111010000 
       This field points to the next Capability in extended configuration space or is 0 
       if it is that last capability. 
     */
  } Bits;
  UINT32 Data;
} ERRCAPHDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCERRSTS_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x4001214C)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRSTS_IIO_PCIEIOSF2_REG 0x1502414C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x14c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 ecrc_error_status : 1;
    /* ecrc_error_status - Bits[19:19], RW1CS, default = 1'b0  */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCERRMSK_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x40012150)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRMSK_IIO_PCIEIOSF2_REG 0x15024150

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x150
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_mask : 1;
    /* ecrc_error_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCERRSEV_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x40012154)                                                     */
/* Register default value:              0x00062030                            */
#define UNCERRSEV_IIO_PCIEIOSF2_REG 0x15024154

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x154
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 ecrc_error_severity : 1;
    /* ecrc_error_severity - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CORERRSTS_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x40012158)                                                     */
/* Register default value:              0x00000000                            */
#define CORERRSTS_IIO_PCIEIOSF2_REG 0x15024158

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x158
 */
typedef union {
  struct {
    UINT32 receiver_error_status : 1;
    /* receiver_error_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_status : 1;
    /* bad_tlp_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 bad_dllp_status : 1;
    /* bad_dllp_status - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 replay_num_rollover_status : 1;
    /* replay_num_rollover_status - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_status : 1;
    /* replay_timer_time_out_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_status : 1;
    /* advisory_non_fatal_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CORERRMSK_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x4001215C)                                                     */
/* Register default value:              0x00002000                            */
#define CORERRMSK_IIO_PCIEIOSF2_REG 0x1502415C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x15c
 */
typedef union {
  struct {
    UINT32 receiver_error_mask : 1;
    /* receiver_error_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_mask : 1;
    /* bad_tlp_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_mask : 1;
    /* bad_dllp_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_mask : 1;
    /* replay_num_rollover_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_mask : 1;
    /* replay_timer_time_out_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_mask : 1;
    /* advisory_non_fatal_error_mask - Bits[13:13], RWS, default = 1'b1  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRCAP_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x40012160)                                                     */
/* Register default value:              0x00000000                            */
#define ERRCAP_IIO_PCIEIOSF2_REG 0x15024160

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT32 first_error_pointer : 5;
    /* first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000 
       The First Error Pointer is a read-only register that identifies the bit position 
       of the first unmasked error reported in the Uncorrectable Error register. In 
       case of two errors happening at the same time, fatal error gets precedence over 
       non-fatal, in terms of being reported as first error. This field is rearmed to 
       capture new errors when the status bit indicated by this field is cleared by 
       software. 
     */
    UINT32 rsvd : 27;
    /* rsvd - Bits[31:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ERRCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG0_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x40012164)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG0_IIO_PCIEIOSF2_REG 0x15024164

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Header Log 0 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 0: Logs the first DWORD of the header on an error condition.
     */
  } Bits;
  UINT32 Data;
} HDRLOG0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG1_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x40012168)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG1_IIO_PCIEIOSF2_REG 0x15024168

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Header Log 1
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 1: Logs the second DWORD of the header on an error 
       condition. 
     */
  } Bits;
  UINT32 Data;
} HDRLOG1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG2_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x4001216C)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG2_IIO_PCIEIOSF2_REG 0x1502416C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Header Log 2 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 2: Logs the third DWORD of the header on an error condition.
     */
  } Bits;
  UINT32 Data;
} HDRLOG2_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* HDRLOG3_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x40012170)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG3_IIO_PCIEIOSF2_REG 0x15024170

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Header Log 3 
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Log of Header Dword 3: Logs the fourth DWORD of the header on an error 
       condition. 
     */
  } Bits;
  UINT32 Data;
} HDRLOG3_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPERRCMD_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x40012174)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRCMD_IIO_PCIEIOSF2_REG 0x15024174

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x174
 */
typedef union {
  struct {
    UINT32 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on correctable errors when set.
     */
    UINT32 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0 
       Applies to root ports onlyEnable interrupt on a non-fatal error when set.
     */
    UINT32 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0 
       Applies to root ports onlyEnable MSI/INTx interrupt on fatal errors when set.
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPERRCMD_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPERRSTS_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x40012178)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRSTS_IIO_PCIEIOSF2_REG 0x15024178

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Root Port Error Status
 * The Root Error Status register reports status of error Messages (ERR_COR), 
 * ERR_NONFATAL, and ERR_FATAL) received by the Root Complex in IIO, and errors 
 * detected by the Root Port itself (which are treated conceptually as if the Root 
 * Port had sent an error Message to itself). 
 * The ERR_NONFATAL and ERR_FATAL Messages are grouped together as uncorrectable. 
 * Each correctable and uncorrectable (Non-fatal and Fatal) error source has a 
 * first error bit and a next error bit associated with it respectively. When an 
 * error is received by a Root Complex, the respective first error bit is set and 
 * the Requestor ID is logged in the Error Source Identification register. 
 * A set individual error status bit indicates that a particular error category 
 * occurred; software may clear an error status by writing a 1 to the respective 
 * bit. If software does not clear the first reported error before another error 
 * Message is received of the same category (correctable or uncorrectable), the 
 * corresponding next error status bit will be set but the Requestor ID of the 
 * subsequent error Message is discarded. The next error status bits may be cleared 
 * by software by writing a 1 to the respective bit as well. 
 */
typedef union {
  struct {
    UINT32 correctable_error_received : 1;
    /* correctable_error_received - Bits[0:0], RW1CS, default = 1'b0 
       Set when a correctable error message is received and this bit is already not 
       set. i.e. log the first error message. 
     */
    UINT32 multiple_correctable_error_received : 1;
    /* multiple_correctable_error_received - Bits[1:1], RW1CS, default = 1'b0 
       Set when either a correctable error message is received and Correctable Error 
       Received bit is already set, i.e log from the 2nd Correctable error message 
       onwards. 
     */
    UINT32 error_fatal_nonfatal_received : 1;
    /* error_fatal_nonfatal_received - Bits[2:2], RW1CS, default = 1'b0 
       Set when either a fatal or a non-fatal error message is received and this bit is 
       already not set. i.e. log the first error message. Note that when this bit is 
       set bit 3 could be either set or clear. 
     */
    UINT32 multiple_error_fatal_nonfatal_received : 1;
    /* multiple_error_fatal_nonfatal_received - Bits[3:3], RW1CS, default = 1'b0 
       Set when either a fatal or a non-fatal error message is received and Error 
       Fatal/Nonfatal Received is already set, i.e log from the 2nd Fatal or No fatal 
       error message onwards. 
     */
    UINT32 first_uncorrectable_fatal : 1;
    /* first_uncorrectable_fatal - Bits[4:4], RW1CS, default = 1'b0 
       Set when bit 2 is set (from being clear) and the message causing bit 2 to be set 
       is an ERR_FATAL message. 
     */
    UINT32 non_fatal_error_messages_received : 1;
    /* non_fatal_error_messages_received - Bits[5:5], RW1CS, default = 1'b0 
       Set when one or more Non-Fatal Uncorrectable error Messages have been received.
     */
    UINT32 fatal_error_messages_received : 1;
    /* fatal_error_messages_received - Bits[6:6], RW1CS, default = 1'b0 
       Set when one or more Fatal Uncorrectable error Messages have been received.
     */
    UINT32 rsvd : 20;
    /* rsvd - Bits[26:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 advanced_error_interrupt_message_number : 5;
    /* advanced_error_interrupt_message_number - Bits[31:27], RO, default = 5'b00000 
       Advanced Error Interrupt Message Number offset between base message data an the 
       MSI message if assigned more than one message number. IIO hardware automatically 
       updates this register to 0x1h if the number of messages allocated to the root 
       port is 2. 
     */
  } Bits;
  UINT32 Data;
} RPERRSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRSID_IIO_PCIEIOSF2_REG supported on:                                     */
/*       BDX (0x4001217C)                                                     */
/* Register default value:              0x00000000                            */
#define ERRSID_IIO_PCIEIOSF2_REG 0x1502417C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Error Source Identification
 */
typedef union {
  struct {
    UINT32 correctable_error_source_id : 16;
    /* correctable_error_source_id - Bits[15:0], ROS_V, default = 16'b0000000000000000 
       Requestor ID of the source when a correctable error message is received and the 
       Correctable Error Received bit is not already set. i.e log ID of the first 
       correctable error message. Note that when the root port itself is the cause of 
       the received message (virtual message), then a Source ID of CPUBUSNO0:DevNo:0 is 
       logged into this register. 
     */
    UINT32 fatal_non_fatal_error_source_id : 16;
    /* fatal_non_fatal_error_source_id - Bits[31:16], ROS_V, default = 16'b0000000000000000 
       Requestor ID of the source when an Fatal or Non Fatal error message is received 
       and the Error Fatal/Nonfatal Received bit is not already set. i.e log ID of the 
       first Fatal or Non Fatal error message. Note that when the root port itself is 
       the cause of the received message (virtual message), then a Source ID of 
       CPUBUSNO0:DevNo:0 is logged into this register. 
     */
  } Bits;
  UINT32 Data;
} ERRSID_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PERFCTRLSTS_0_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012180)                                                     */
/* Register default value:              0x00183091                            */
#define PERFCTRLSTS_0_IIO_PCIEIOSF2_REG 0x15024180

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT32 read_stream_policy : 1;
    /* read_stream_policy - Bits[0:0], RW, default = 1'b1  */
    UINT32 read_passing_read_disable : 1;
    /* read_passing_read_disable - Bits[1:1], RW, default = 1'b0 
       Disable reads bypassing other reads.
     */
    UINT32 rsvd_2 : 2;
    UINT32 read_stream_interleave_size : 1;
    /* read_stream_interleave_size - Bits[4:4], RW, default = 1'b1  */
    UINT32 rsvd_5 : 2;
    /* rsvd_5 - Bits[6:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 use_allocating_flow_wr : 1;
    /* use_allocating_flow_wr - Bits[7:7], RW, default = 1'b1  */
    UINT32 outstanding_requests_gen2 : 6;
    /* outstanding_requests_gen2 - Bits[13:8], RW, default = 6'b110000 
       Number of outstanding RFOs and non-posted requests from a given PCIe port.
       This register controls the number of outstanding inbound non-posted requests - 
       I/O, Config, Memory - (maximum length of these requests is a single 64B 
       cacheline) that a Gen2 PCI Express downstream port can have. This register 
       provides the value for the port when it is operating in Gen2 mode and for a link 
       width of x4. BIOS programs this register based on the read latency to main 
       memory. 
       This register also specifies the number of RFOs that can be kept outstanding on 
       IDI for a given port. 
       The link speed of the port can change during a PCI Express hotplug event and the 
       port must use the appropriate multiplier. 
       A value of 1 indicates one outstanding pre-allocated request, 2 indicates two 
       outstanding pre-allocated requests, and so on. If software programs a value 
       greater than the buffer size the DMA engine supports, then the maximum hardware 
       supported value is used. 
       Current BIOS recommendation is to leave this field at it's default value.
     */
    UINT32 rsvd_14 : 2;
    /* rsvd_14 - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outstanding_requests_gen1 : 5;
    /* outstanding_requests_gen1 - Bits[20:16], RW, default = 5'b11000 
       Number of outstanding RFOs and non-posted requests from a given PCIe port.
       This register controls the number of outstanding inbound non-posted requests - 
       I/O, Config, Memory - (maximum length of these requests is a single 64B 
       cacheline) that a Gen1 PCI Express downstream port can have. This register 
       provides the value for the port when it is operating in Gen1 mode and for a link 
       width of x4. BIOS programs this register based on the read latency to main 
       memory. 
       This register also specifies the number of RFOs that can be kept outstanding on 
       IDI for a given port. 
       The link speed of the port can change during a PCI Express hotplug event and the 
       port must use the appropriate multiplier. 
       A value of 1 indicates one outstanding pre-allocated request, 2 indicates two 
       outstanding pre-allocated requests, and so on. If software programs a value 
       greater than the buffer size the DMA engine supports, then the maximum hardware 
       supported value is used. 
       Current BIOS recommendation is to leave this field at it's default value.
     */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* PERFCTRLSTS_1_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012184)                                                     */
/* Register default value:              0x00000000                            */
#define PERFCTRLSTS_1_IIO_PCIEIOSF2_REG 0x15024184

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x184
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[3:3], RW, default = 1'b0 
       Selects the maximum completion combining size.
       1: Completions are combined up to 256B
       0: Completions are combined up to 128B
       This bit is no longer used in the RTL. Completions are always combined up to the 
       maximum allowed by the Max Payload Size field in the Device Control register. 
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dca_reqid_override : 1;
    /* dca_reqid_override - Bits[8:8], RW, default = 1'b0 
       When this bit is set, Requester ID match for DCA writes is bypassed. All writes 
       from the port are treated as DCA writes and the tag field will convey if DCA is 
       enabled or not and the target information. 
     */
    UINT32 tphdis : 1;
    /* tphdis - Bits[9:9], RW, default = 1'b0 
       TLP Processing Hint Disable
       When set, writes or reads with TPH=1, will be treated as if TPH=0.
     */
    UINT32 partial_cohrd_op : 2;
    /* partial_cohrd_op - Bits[11:10], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need less than 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 full_cohrd_op : 2;
    /* full_cohrd_op - Bits[13:12], RW, default = 2'b00 
       Selects the opcode used on the ring by coherent reads issued on behalf of this 
       root port that need all 64B of data from the requested cacheline. 
       '00 = PCIRdCur
       '01 = CRd
       '10 = DRd
       '11 = RFO
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MISCCTRLSTS_0_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012188)                                                     */
/* Register default value:              0x60101000                            */
#define MISCCTRLSTS_0_IIO_PCIEIOSF2_REG 0x15024188

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Miscellaneous Control and Status 0
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 inbound_configuration_enable : 1;
    /* inbound_configuration_enable - Bits[1:1], RW_O, default = 1'b0 
       Enable Inbound Configuration Requests.
     */
    UINT32 enable_acpi_mode_for_pm : 1;
    /* enable_acpi_mode_for_pm - Bits[2:2], RW, default = 1'b0 
       Applies only to root ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, all PM events at the PCI Express 
       port are handled via _PMEGPE messages to the PCH, and no MSI interrupts are ever 
       generated for PM events at the root port (regardless of whether MSI is enabled 
       at the root port or not). When clear, _PMEGPE message generation for PM events 
       is disabled and OS can chose to generate MSI interrupts for delivering PM events 
       by setting the MSI enable bit in root ports. This bit does not apply to the DMI 
       ports. Refer to PCI Express Base Specification, Revision 2.0 for details of MSI 
       and GPE Clearing this bit (from being 1) schedules a Deassert_PMEGPE event on 
       behalf of the root port, provided there was any previous Assert_PMEGPE message 
       that was sent without an associated Deassert message. Note that this bit applies 
       to Dev#3/Fn#0 in NTB mode as well and BIOS needs to set it up appropriately in 
       that mode. 
     */
    UINT32 enable_acpi_mode_for_hotplug : 1;
    /* enable_acpi_mode_for_hotplug - Bits[3:3], RW, default = 1'b0 
       Applies only to root ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, all hotplug events from the PCI 
       Express port are handled via _HPGPE messages to the PCH and no MSI/INTx messages 
       are ever generated for hotplug events (regardless of whether MSI or INTx is 
       enabled at the root port or not) at the root port. When this bit is clear, 
       _HPGPE message generation on behalf of root port hotplug events is disabled and 
       OS can chose to generate MSI or INTx interrupt for hotplug events, by setting 
       the MSI enable bit in root ports. This bit does not apply to the DMI ports. 
       Refer to PCI Express Base Specification, Revision 2.0 for details of MSI and GPE 
       message generation for hotplug events. Clearing this bit (from being 1) 
       schedules a Deassert_HPGPE event on behalf of the root port, provided there was 
       any previous Assert_HPGPE message that was sent without an associated Deassert 
       message. Note that this bit applies to Dev#3/Fn#0 in NTB mode as well and BIOS 
       needs to set it up appropriately in that mode. 
     */
    UINT32 enable_system_error_only_for_aer : 1;
    /* enable_system_error_only_for_aer - Bits[4:4], RW, default = 1'b0 
       Applies only to root/NTB ports. For Dev#0 in DMI mode, this bit is to be left at 
       default value always. When this bit is set, the PCI Express errors do not 
       trigger an MSI or Intx interrupt, regardless of the whether MSI or INTx is 
       enabled or not. Whether or not PCI Express errors result in a system event like 
       NMI/SMI/PMI/CPEI is dependent on whether the appropriate system error or 
       override system error enable bits are set or not. When this bit is clear, PCI 
       Express errors are reported via MSI or INTx and/or NMI/SMI/MCA/CPEI. When this 
       bit is clear and if MSI enable bit in the MSI Control Register (MSICTRL)is set 
       (clear), then an MSI (INTx) interrupt is generated for PCI Express errors. When 
       this bit is clear, and 'System Error on Fatal Error Enable' bit in ROOTCON 
       register is set, then NMI/SMI/MCA is (also) generated for a PCI Express fatal 
       error. Similar behavior for non-fatal and corrected errors. Note that this bit 
       applies to Dev#3/Fn#0 in NTB mode as well and BIOS needs to set it up 
       appropriately in that mode. 
     */
    UINT32 send_pme_turn_off_message : 1;
    /* send_pme_turn_off_message - Bits[5:5], RW_V, default = 1'b0 
       When this bit is written with a 1b, IIO sends a PME_TURN_OFF message to the PCIE 
       link. Hardware clears this bit when the message has been sent on the link. 
     */
    UINT32 enable_timeout_for_receiving_pme_to_ack : 1;
    /* enable_timeout_for_receiving_pme_to_ack - Bits[6:6], RW, default = 1'b0 
       Enable timeout for receiving PME_TO_ACK.
       When set, IIO enables the timeout to receiving the PME_TO_ACK.
     */
    UINT32 pme2acktoctrl : 2;
    /* pme2acktoctrl - Bits[8:7], RW, default = 2'b00  */
    UINT32 dispdspolling : 1;
    /* dispdspolling - Bits[9:9], RWS, default = 1'b0 
       Disables gen2 if timeout happens in polling.cfg.
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_ob_parity_check : 1;
    /* disable_ob_parity_check - Bits[12:12], RWS, default = 1'b1  */
    UINT32 tlp_on_any_lane : 1;
    /* tlp_on_any_lane - Bits[13:13], RWS, default = 1'b0  */
    UINT32 allow_one_np_os : 1;
    /* allow_one_np_os - Bits[14:14], RWS, default = 1'b0  */
    UINT32 dis_hdr_storage : 1;
    /* dis_hdr_storage - Bits[15:15], RWS, default = 1'b0  */
    UINT32 force_ep_biterr : 1;
    /* force_ep_biterr - Bits[16:16], RO, default = 1'b0 
       Force EP Bit Error (Poison Bit).
     */
    UINT32 force_data_perr : 1;
    /* force_data_perr - Bits[17:17], RO, default = 1'b0 
       Force Data Parity Error.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[18:18], RWS, default = 1'b0 
       Disable Read Completion Combining
       When set, all completions are returned without combining. Completions are 
       naturally broken on cacheline boundaries, so all completions will be 64B or 
       less. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maltlp_32baddr64bhdr_en : 1;
    /* maltlp_32baddr64bhdr_en - Bits[20:20], RW, default = 1'b1 
       Malformed TLP 32b address in 64b header Enable
       When set, enables reporting a Malformed packet when the TLP is a 32 bit address 
       in a 4DW header. PCI Express forbids using 4DW header sizes when the address is 
       less than 4GB, but some cards may use the 4DW header anyway. In these cases, the 
       upper 32 bits of address are all 0. 
     */
    UINT32 zero_ob_tc : 1;
    /* zero_ob_tc - Bits[21:21], RW_O, default = 1'b0 
       Force Outbound TC to Zero
       Forces the TC field to zero for outbound requests.
       1: TC is forced to zero on all outbound transactions regardless of the source TC 
       value 
       0: TC is not altered
       In DMI mode, TC is always forced to zero and this bit has no effect.
       
     */
    UINT32 check_cpl_tc : 1;
    /* check_cpl_tc - Bits[22:22], RWS, default = 1'b0  */
    UINT32 phold_disable : 1;
    /* phold_disable - Bits[23:23], RW, default = 1'b0 
       Applies only to Dev#0
       When set, the IIO responds with Unsupported request on receiving assert_phold 
       message from ICH and results in generating a fatal error. 
     */
    UINT32 peer2peer_memory_read_disable : 1;
    /* peer2peer_memory_read_disable - Bits[24:24], RW, default = 1'b0 
       When set, peer2peer memory reads are master aborted otherwise they are allowed 
       to progress per the peer2peer decoding rules. 
     */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 eoifd : 1;
    /* eoifd - Bits[26:26], RW, default = 1'b0 
       EOI Forwarding Disable - Disable EOI broadcast to this PCIE link
       When set, EOI message will not be broadcast down this PCIE link. When clear, the 
       port is a valid target for EOI broadcast. BIOS must set this bit on a port if it 
       is connected to a another processor NTB or root port on other end of the link. 
     */
    UINT32 system_interrupt_only_on_link_bw_management_status : 1;
    /* system_interrupt_only_on_link_bw_management_status - Bits[27:27], RWS, default = 1'b0  */
    UINT32 to_dis : 1;
    /* to_dis - Bits[28:28], RW, default = 1'b0 
       Disables timeouts completely.
     */
    UINT32 cfg_to_en : 1;
    /* cfg_to_en - Bits[29:29], RW, default = 1'b1 
       Disables/enables config timeouts, independently of other timeouts.
     */
    UINT32 inbound_io_disable : 1;
    /* inbound_io_disable - Bits[30:30], RW_O, default = 1'b1 
       Disable Inbound IO Requests.
     */
    UINT32 disable_l0s_on_transmitter : 1;
    /* disable_l0s_on_transmitter - Bits[31:31], RW, default = 1'b0 
       When set, IIO never puts its tx in L0s state, even if OS enables it via the Link 
       Control register. L0s is not supported on the processor. 
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MISCCTRLSTS_1_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x4001218C)                                                     */
/* Register default value:              0x00000000                            */
#define MISCCTRLSTS_1_IIO_PCIEIOSF2_REG 0x1502418C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Miscellaneous Control and Status 1
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0 
       When set, correctable errors on PCI Express (that have been successfully 
       propagated to the primary interface of the port) are sent to the IIO core error 
       logic (for further escalation) regardless of the setting of the equivalent bit 
       in the ROOTCTRL register. When clear, the correctable errors are only propagated 
       to the IIO core error logic if the equivalent bit in ROOTCTRL register is set. 
       For Dev#0 in DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link 
       related correctable errors will never be notified to system software. 
     */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0 
       When set, non-fatal errors on PCI Express (that have been successfully 
       propagated to the primary interface of the port) are sent to the IIO core error 
       logic (for further escalation) regardless of the setting of the equivalent bit 
       in the ROOTCTRL register. When clear, the non-fatal errors are only propagated 
       to the IIO core error logic if the equivalent bit in ROOTCTRL register is set. 
       For Dev#0 in DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link 
       related non-fatal errors will never be notified to system software. 
     */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0 
       When set, fatal errors on PCI Express (that have been successfully propagated to 
       the primary interface of the port) are sent to the IIO core error logic (for 
       further escalation) regardless of the setting of the equivalent bit in the 
       ROOTCTRL register. When clear, the fatal errors are only propagated to the IIO 
       core error logic if the equivalent bit in ROOTCTRL register is set. For Dev#0 in 
       DMI mode and Dev#3/Fn#0, unless this bit is set, DMI/NTB link related fatal 
       errors will never be notified to system software. 
     */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 rsvd_5 : 1;
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0 
       This bit is set by BIOS when it knows that this port is connected to a device 
       that creates Posted-Posted dependency on its In-Out queues. 
       Briefly, this bit is set on a link if:
       This link is connected to a processor RP or processor NTB port on the other side 
       of the link. 
       This link is connected to a port or device that creates Posted-Posted dependency 
       on its In-Out queues. 
       IIO lock flows depend on the setting of this bit to treat this port in a special 
       way during the flows. Note that if BIOS is setting up the lock flow to be in the 
       'QPI compatible' mode then this bit must be set to 0. 
       An inbound MSI request can block the posted channel until EOI's are posted to 
       all outbound queues enabled to receive EOI. Because of this, this bit cannot be 
       set unless EOIFD is also set. 
     */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0 
       For TPH/DCA requests, the Completer ID can be returned with SocketID when this 
       bit is set. 
     */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0 
       Indicates that IIO received a PME turn off ack packet or it timed out waiting 
       for the packet. 
     */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0 
       Indicates that a locked read request incurred a completion time-out on PCI 
       Express/DMI. 
     */
    UINT32 rsvd_18 : 12;
    /* rsvd_18 - Bits[29:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_sending_pme_to_port : 1;
    /* disable_sending_pme_to_port - Bits[30:30], RW, default = 1'b0  */
    UINT32 mimic_pme_to_ack_received : 1;
    /* mimic_pme_to_ack_received - Bits[31:31], RW, default = 1'b0  */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRINJCAP_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x400121D0)                                                     */
/* Register default value:              0x2501000B                            */
#define ERRINJCAP_IIO_PCIEIOSF2_REG 0x150241D0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Express Error Injection
 */
typedef union {
  struct {
    UINT32 extcapid : 16;
    /* extcapid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCI Express Extended CAP ID
       Vendor Specific Capability
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability Version
       Set to 1h for this version of the PCI Express logic
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001001010000 
       Next Capability Offset
       This field points to the next capability or 0 if there isn't a next capability.
       For non-DMI (x4) port next capability is at 0x250.
       For DMI port next capability is at 0x280.
     */
  } Bits;
  UINT32 Data;
} ERRINJCAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRINJHDR_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x400121D4)                                                     */
/* Register default value:              0x00A10003                            */
#define ERRINJHDR_IIO_PCIEIOSF2_REG 0x150241D4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Express Error Injection
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000011 
       Vendor Specific ID
       Assigned for WHEA Error Injection
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0001 
       Vendor Specific Capability Revision
       Set to 1h for this version of the WHEA Error Injection logic
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000001010 
       Vendor Specific Capability Length
       Indicates the length of the capability structure, including header bytes.
     */
  } Bits;
  UINT32 Data;
} ERRINJHDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* ERRINJCON_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x200121D8)                                                     */
/* Register default value:              0x0000                                */
#define ERRINJCON_IIO_PCIEIOSF2_REG 0x150221D8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCI Express Error Injection Control Register
 */
typedef union {
  struct {
    UINT16 errinjdis : 1;
    /* errinjdis - Bits[0:0], RW_O, default = 1'b0 
       Error Injection Disable
       This bit disables the use of the PCIe error injection bits.
     */
    UINT16 cause_rcverr : 1;
    /* cause_rcverr - Bits[1:1], RW, default = 1'b0 
       Cause a Receiver Error
       When this bit is written to transition from 0 to 1, one and only one error 
       assertion pulse is produced on the error source signal for the given port. This 
       error will appear equivalent to an actual error assertion because this event is 
       OR'd into the existing error reporting structure. To log another error, this bit 
       must be cleared first, before setting again. Leaving this bit in a 1 state does 
       not produce a persistent error condition. 
       This bit is used for an correctable error test.
       This bit must be cleared by software before creating another event.
       This bit is disabled by bit 0 of this register.
     */
    UINT16 cause_ctoerr : 1;
    /* cause_ctoerr - Bits[2:2], RW, default = 1'b0 
       Cause a Completion Timeout Error
       When this bit is written to transition from 0 to 1, one and only one error 
       assertion pulse is produced on the error source signal for the given port. This 
       error will appear equivalent to an actual error assertion because this event is 
       OR'd into the existing error reporting structure. To log another error, this bit 
       must be cleared first, before setting again. Leaving this bit in a 1 state does 
       not produce a persistent error condition. 
       This bit is used for an uncorrectable error test.
       This bit must be cleared by software before creating another event.
       This bit is disabled by bit 0 of this register.
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ERRINJCON_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* CTOCTRL_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x400121E0)                                                     */
/* Register default value:              0x00000000                            */
#define CTOCTRL_IIO_PCIEIOSF2_REG 0x150241E0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Completion Timeout Control
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    /* rsvd_0 - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 xp_to_pcie_timeout_select : 2;
    /* xp_to_pcie_timeout_select - Bits[9:8], RW, default = 2'b00 
       When OS selects a timeout range of 17s to 64s for XP (that affect NP tx issued 
       to the PCIE/DMI) using the root port's DEVCTRL2 register, this field selects the 
       sub-range within that larger range, for additional controllability. 
       00: 17s-30s
       01: 31s-45s
       10: 46s-64s
       11: Reserved
       This field is not used at all when NTB is enabled on Dev#3/Fn#0 since there is 
       no programmability of completion timeout in that mode. 
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CTOCTRL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPCORERRSTS_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012200)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRSTS_IIO_PCIEIOSF2_REG 0x15024200

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x200
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPCORERRMSK_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012204)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRMSK_IIO_PCIEIOSF2_REG 0x15024204

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x204
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRSTS_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012208)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRSTS_IIO_PCIEIOSF2_REG 0x15024208

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x208
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected : 1;
    /* outbound_switch_fifo_data_parity_error_detected - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort : 1;
    /* sent_completion_with_completer_abort - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request : 1;
    /* sent_completion_with_unsupported_request - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status : 1;
    /* received_pcie_completion_with_ca_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status : 1;
    /* received_pcie_completion_with_ur_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data : 1;
    /* received_msi_writes_greater_than_a_dword_data - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 outbound_poisoned_data : 1;
    /* outbound_poisoned_data - Bits[9:9], RW1CS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRMSK_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x4001220C)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRMSK_IIO_PCIEIOSF2_REG 0x1502420C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x20c
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detected_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_mask : 1;
    /* sent_completion_with_completer_abort_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_mask : 1;
    /* sent_completion_with_unsupported_request_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRSEV_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012210)                                                     */
/* Register default value:              0x00000002                            */
#define XPUNCERRSEV_IIO_PCIEIOSF2_REG 0x15024210

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x210
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_severity : 1;
    /* outbound_switch_fifo_data_parity_error_detected_severity - Bits[1:1], RWS, default = 1'b1  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_severity : 1;
    /* sent_completion_with_completer_abort_severity - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_severity : 1;
    /* sent_completion_with_unsupported_request_severity - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_severity : 1;
    /* received_pcie_completion_with_ca_status_severity - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_severity : 1;
    /* received_pcie_completion_with_ur_status_severity - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_severity : 1;
    /* received_msi_writes_greater_than_a_dword_data_severity - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_severity : 1;
    /* outbound_poisoned_data_severity - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSEV_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCERRPTR_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x10012214)                                                     */
/* Register default value:              0x00                                  */
#define XPUNCERRPTR_IIO_PCIEIOSF2_REG 0x15021214

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * XP Uncorrectable Error Pointer
 */
typedef union {
  struct {
    UINT8 xp_uncorrectable_first_error_pointer : 5;
    /* xp_uncorrectable_first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000 
       This field points to which of the unmasked uncorrectable errors happened first. 
       This field is only valid when the corresponding error is unmasked and the status 
       bit is set and this field is rearmed to load again when the status bit indicated 
       to by this pointer is cleared by software from 1 to 0. Value of 0x0 corresponds 
       to bit 0 in XPUNCERRSTS register, value of 0x1 corresponds to bit 1 etc. 
     */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} XPUNCERRPTR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* UNCEDMASK_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x40012218)                                                     */
/* Register default value:              0x00000000                            */
#define UNCEDMASK_IIO_PCIEIOSF2_REG 0x15024218

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x218
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_detect_mask : 1;
    /* ecrc_error_detect_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* COREDMASK_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x4001221C)                                                     */
/* Register default value:              0x00000000                            */
#define COREDMASK_IIO_PCIEIOSF2_REG 0x1502421C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x21c
 */
typedef union {
  struct {
    UINT32 receiver_error_detect_mask : 1;
    /* receiver_error_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_detect_mask : 1;
    /* bad_tlp_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_detect_mask : 1;
    /* bad_dllp_detect_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_detect_mask : 1;
    /* replay_num_rollover_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_detect_mask : 1;
    /* replay_timer_time_out_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_detect_mask : 1;
    /* advisory_non_fatal_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} COREDMASK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPEDMASK_IIO_PCIEIOSF2_REG supported on:                                   */
/*       BDX (0x40012220)                                                     */
/* Register default value:              0x00000000                            */
#define RPEDMASK_IIO_PCIEIOSF2_REG 0x15024220

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x220
 */
typedef union {
  struct {
    UINT32 correctable_error_detected_status_mask : 1;
    /* correctable_error_detected_status_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 non_fatal_error_detected_status_mask : 1;
    /* non_fatal_error_detected_status_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 fatal_error_detected_status_mask : 1;
    /* fatal_error_detected_status_mask - Bits[2:2], RWS, default = 1'b0  */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPEDMASK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPUNCEDMASK_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012224)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCEDMASK_IIO_PCIEIOSF2_REG 0x15024224

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x224
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detect_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detect_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_detect_mask : 1;
    /* sent_completion_with_completer_abort_detect_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_detect_mask : 1;
    /* sent_completion_with_unsupported_request_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_detect_mask : 1;
    /* received_pcie_completion_with_ca_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_detect_mask : 1;
    /* received_pcie_completion_with_ur_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_detect_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_detect_mask : 1;
    /* outbound_poisoned_data_detect_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCEDMASK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPCOREDMASK_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012228)                                                     */
/* Register default value:              0x00000000                            */
#define XPCOREDMASK_IIO_PCIEIOSF2_REG 0x15024228

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * generated by critter 02_2_0x228
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPGLBERRSTS_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x20012230)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRSTS_IIO_PCIEIOSF2_REG 0x15022230

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * XP Global Error Status
 */
typedef union {
  struct {
    UINT16 pcie_aer_fatal_error : 1;
    /* pcie_aer_fatal_error - Bits[0:0], RW1CS, default = 1'b0 
       A PCIE fatal error (ERR_FATAL message received from externally or through a 
       virtual ERR_FATAL message generated internally) was detected anew. Note that if 
       that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage, only 'subsequent' 
       PCIE unmasked fatal errors will set this bit.See section titled PCI Express 
       Error Reporting Specifics in the RAS chapter for details of how this bit 
       interacts with other control/status bits in signalling errors to the IIO global 
       error reporting logic. 
     */
    UINT16 pcie_aer_non_fatal_error : 1;
    /* pcie_aer_non_fatal_error - Bits[1:1], RW1CS, default = 1'b0 
       A PCIE non-fatal error (ERR_NONFATAL message received from externally or through 
       a virtual ERR_NONFATAL message generated internally) was detected anew. Note 
       that if that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage only 'subsequent' PCIE 
       unmasked non-fatal errors will set this bit again.See section titled PCI Express 
       Error Reporting Specifics in the RAS chapter for details of how this bit 
       interacts with other control/status bits in signalling errors to the IIO global 
       error reporting logic. 
     */
    UINT16 pcie_aer_correctable_error : 1;
    /* pcie_aer_correctable_error - Bits[2:2], RW1CS, default = 1'b0 
       A PCIE correctable error (ERR_COR message received from externally or through a 
       virtual ERR_COR message generated internally) was detected anew. Note that if 
       that error was masked in the PCIE AER, it is not reported in this field. 
       Software clears this bit by writing a 1 and at that stage, only 'subsequent' 
       PCIE unmasked correctable errors will set this bit.Conceptually, per the flow of 
       PCI Express Base Spec 2.0 defined Error message control, this bit is set by the 
       ERR_COR message that is enabled to cause a System Error notification. See 
       section titled PCI Express Error Reporting Specifics in the RAS chapter for 
       details of how this bit interacts with other control/status bits in signalling 
       errors to the IIO global error reporting logic. 
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* XPGLBERRPTR_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x20012232)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRPTR_IIO_PCIEIOSF2_REG 0x15022232

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * XP Global Error Pointer
 */
typedef union {
  struct {
    UINT16 xp_cluster_global_first_error_pointer : 3;
    /* xp_cluster_global_first_error_pointer - Bits[2:0], ROS_V, default = 3'b000 
       This field points to which of the 3 errors indicated in the XPGLBERRSTS register 
       happened first. This field is only valid when the corresponding status bit is 
       set and this field is rearmed to load again when the status bit indicated to by 
       this pointer is cleared by software from 1 to 0.Value of 0x0 corresponds to bit 
       0 in XPGLBERRSTS register, value of 0x1 corresponds to bit 1 etc. 
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRPTR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_CAP_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x40012280)                                                     */
/* Register default value:              0x2981000B                            */
#define LER_CAP_IIO_PCIEIOSF2_REG 0x15024280

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Live Error Recovery Capability
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCI Express Extended CAP ID
       Vendor Specific Capability
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability Version
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001010011000 
       Next Capability Offset
       Default may vary depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} LER_CAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_HDR_IIO_PCIEIOSF2_REG supported on:                                    */
/*       BDX (0x40012284)                                                     */
/* Register default value:              0x01830005                            */
#define LER_HDR_IIO_PCIEIOSF2_REG 0x15024284

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Live Error Recovery Capability Header
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000101 
       Vendor Specific ID
       Represents the Live Error Recovery capability
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0011 
       Vendor Specific Capability Revision
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000011000 
       Vendor Specific Capability Length
     */
  } Bits;
  UINT32 Data;
} LER_HDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_CTRLSTS_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x40012288)                                                     */
/* Register default value:              0x00000000                            */
#define LER_CTRLSTS_IIO_PCIEIOSF2_REG 0x15024288

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0 
       Live Error Recovery Enable
       When set, allows the LER_Status to assert on error. When the status bit is set, 
       the port is in LER mode. When this bit is cleared, the LER_Status bit cannot 
       become set on an error. 
       If this bit is cleared when LER_Status bit is already set, then clearing this 
       bit does not clear the status bit and does not exit LER mode. To exit LER mode, 
       the status bit must be cleared by software. 
       This bit is also used for stop and scream and can be enabled even though LER is 
       not available. 
     */
    UINT32 ler_ss_severity_en : 1;
    /* ler_ss_severity_en - Bits[1:1], RWS, default = 1'b0 
       Live Error Recovery Severity Enable
       If set, forces the errors that trigger LER mode to be signalled as correctable 
       error of Severity 0. If cleared, then errors are signaled as Uncorrectable 
       Non-Fatal Severity 1 or Uncorrectable Fatal Severity 2 as specified for the 
       given error. 
     */
    UINT32 ler_ss_drop_txn : 1;
    /* ler_ss_drop_txn - Bits[2:2], RWS, default = 1'b0 
       Live Error Recovery Drop Transaction
       If set, after entering LER subsequent transactions will be dropped as soon as 
       the port configuration allows. 
     */
    UINT32 ler_ss_inten : 1;
    /* ler_ss_inten - Bits[3:3], RWS, default = 1'b0 
       Live Error Recovery Interrupt Enable
       If set, causes and INTx or MSI interrupt from the root port (if enabled in the 
       root port) to be generated when LER_Status is set. 
     */
    UINT32 rsvd : 26;
    /* rsvd - Bits[29:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ler_ss_lnk_up_ok : 1;
    /* ler_ss_lnk_up_ok - Bits[30:30], ROS_V, default = 1'b0 
       Live Error Recovery Port Quiesced
       Indicates when the port has no more pending inbound or outbound packets after 
       the port has entered LER mode. It is used by software to determine when it is 
       safe to clear the LER_Status bit to bring the port out of LER mode. 
     */
    UINT32 ler_ss_status : 1;
    /* ler_ss_status - Bits[31:31], RW1CS, default = 1'b0 
       Live Error Recovery Status
       Indicates that an error was detected that caused the PCIE port to go into a live 
       error recovery (LER) mode. While in LER mode, the link goes into a LinkDown 
       "Disabled" state and all outbound transactions are aborted (including packets 
       that may have caused the error). 
       This bit cannot be cleared until all the associated unmasked status bits are 
       cleared, or the corresponding LER mask bits are set. Once the unmasked error 
       considtion are cleared, then this bit may be cleared by software writing a '1'. 
       Once this status becomes cleared by clearing the error condition, the link will 
       retrain into LinkUp state and outbound transactions will no longer be aborted. 
       A link that is forced into a LinkDown state due to LER does not trigger a 
       "surprise LinkDown" error in the UNCERRSTS register. 
       It should be noted that many PCIe cards will go into internal reset when they 
       receive training sequences that indicate the "Disabled" state. 
     */
  } Bits;
  UINT32 Data;
} LER_CTRLSTS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_UNCERRMSK_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x4001228C)                                                     */
/* Register default value:              0x00000000                            */
#define LER_UNCERRMSK_IIO_PCIEIOSF2_REG 0x1502428C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Live Error Recovery Uncorrectable Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    /* rsvd_0 - Bits[3:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    /* rsvd_6 - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_err_mask : 1;
    /* ecrc_err_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_XPUNCERRMSK_IIO_PCIEIOSF2_REG supported on:                            */
/*       BDX (0x40012290)                                                     */
/* Register default value:              0x00000000                            */
#define LER_XPUNCERRMSK_IIO_PCIEIOSF2_REG 0x15024290

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Live Error Recovery XP Uncorrectable Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 sent_completion_with_ca_mask : 1;
    /* sent_completion_with_ca_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_ur_mask : 1;
    /* sent_completion_with_ur_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0 
       Masks signaling of stop and scream condition to the core error logic.
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_XPUNCERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* LER_RPERRMSK_IIO_PCIEIOSF2_REG supported on:                               */
/*       BDX (0x40012294)                                                     */
/* Register default value:              0x00000000                            */
#define LER_RPERRMSK_IIO_PCIEIOSF2_REG 0x15024294

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Live Error Recovery Root Port Error Mask
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 non_fatal_error_message_received_mask : 1;
    /* non_fatal_error_message_received_mask - Bits[5:5], RWS, default = 1'b0 
       Masks LER response to Non-Fatal Error Messages received.
     */
    UINT32 fatal_error_message_received_mask : 1;
    /* fatal_error_message_received_mask - Bits[6:6], RWS, default = 1'b0 
       Masks LER response to Fatal Error Messages received
     */
    UINT32 rsvd_7 : 25;
    /* rsvd_7 - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_RPERRMSK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_CAP_IIO_PCIEIOSF2_REG supported on:                               */
/*       BDX (0x40012298)                                                     */
/* Register default value:              0x3001000B                            */
#define RPPIOERR_CAP_IIO_PCIEIOSF2_REG 0x15024298

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCIe spec-defined capability register for enhanced root port PIO error 
 * reporting. 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe extended capability ID.
       Set to 0xb for vendor-specific capability.
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability version.
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001100000000 
       Next capability pointer.
       May not point to 0x300 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_CAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDR_IIO_PCIEIOSF2_REG supported on:                               */
/*       BDX (0x4001229C)                                                     */
/* Register default value:              0x02400007                            */
#define RPPIOERR_HDR_IIO_PCIEIOSF2_REG 0x1502429C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * PCIe spec-defined vendor-specific header register for enhanced root port PIO 
 * error reporting. 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000111 
       Vendor-specific capability ID. Intel defines 0x7 as the ID for enhanced root 
       port PIO error reporting. 
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000 
       VSEC revision.
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000100100 
       VSEC length.
       Length of the RP_PIO_ERR capability in bytes, starting from the capability ID.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HF_IIO_PCIEIOSF2_REG supported on:                                */
/*       BDX (0x400122A0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HF_IIO_PCIEIOSF2_REG 0x150242A0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Register that controls which PIO errors should cause a poison indication.
 */
typedef union {
  struct {
    UINT32 cfg_ur_hf : 1;
    /* cfg_ur_hf - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all configuration requests targeting 
       the PCIe hierarchy below the Root Port will be treated as UR, and will return 
       poison if this bit is set. 
     */
    UINT32 cfg_ca_hf : 1;
    /* cfg_ca_hf - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 cfg_to_hf : 1;
    /* cfg_to_hf - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_hf : 1;
    /* io_ur_hf - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all IO requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 io_ca_hf : 1;
    /* io_ca_hf - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 io_to_hf : 1;
    /* io_to_hf - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_hf : 1;
    /* mem_ur_hf - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all memory requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 mem_ca_hf : 1;
    /* mem_ca_hf - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 mem_to_hf : 1;
    /* mem_to_hf - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HF_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_STATUS_IIO_PCIEIOSF2_REG supported on:                            */
/*       BDX (0x400122A4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_STATUS_IIO_PCIEIOSF2_REG 0x150242A4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Register that logs the PIO errors.  Note that PIO UR errors that occur after LER 
 * has been triggered will not update this register. 
 * If a PIO error is detected and the corresponding RPPIOERR_MASK bit is cleared, 
 * then LER will be triggered if LER is enabled, and pio_err_first_header and 
 * RPPIOERR_HDRLOG[0-3] may update. 
 * Regardless of the state of the corresponding RPPIOERR_MASK bit, a PIO error may 
 * update its status bit in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_err : 1;
    /* cfg_ur_err - Bits[0:0], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ur_mask). 
     */
    UINT32 cfg_ca_err : 1;
    /* cfg_ca_err - Bits[1:1], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ca_mask). 
     */
    UINT32 cfg_to_err : 1;
    /* cfg_to_err - Bits[2:2], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_err : 1;
    /* io_ur_err - Bits[8:8], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ur_mask). 
     */
    UINT32 io_ca_err : 1;
    /* io_ca_err - Bits[9:9], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ca_mask). 
     */
    UINT32 io_to_err : 1;
    /* io_to_err - Bits[10:10], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.io_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_err : 1;
    /* mem_ur_err - Bits[16:16], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ur_mask). 
     */
    UINT32 mem_ca_err : 1;
    /* mem_ca_err - Bits[17:17], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ca_mask). 
     */
    UINT32 mem_to_err : 1;
    /* mem_to_err - Bits[18:18], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 pio_err_first_header : 5;
    /* pio_err_first_header - Bits[23:19], RW1CS, default = 5'b00000 
       These 5 bits identify the first unmasked (by rppioerr_mask) RPPIO error that was 
       observed. The encoding is as follows: 
       00: No Error
       01: CFG_UR_ERR
       02: CFG_CA_ERR
       03: CFG_TO_ERR
       04: IO_UR_ERR
       05: IO_CA_ERR
       06: IO_TO_ERR
       07: MEM_UR_ERR
       08: MEM_CA_ERR
       09: MEM_TO_ERR
       Others: undefined
       Note these bits will not record subsequent errors until the first error is 
       cleared by SW. 
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_STATUS_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_MASK_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x400122A8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_MASK_IIO_PCIEIOSF2_REG 0x150242A8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Register that masks triggering of LER on PIO errors.  When clear, LER will be 
 * triggered when LER is enabled and an error sets the corresponding bit in the 
 * RPPIOERR_STATUS. 
 * When RPPIOERR_STATUS is used to trigger LER, it is expected the end user will 
 * program the LER_XPUNCERRMSK and XPUNCERRMSK registers correctly so that they do 
 * not trigger a LER event also. 
 * If LER_CTRLSTS.LER_Enable is not set, LER will not be triggered, regardless of 
 * the setting of the RPPIOERR_MASK registers. 
 * Poison may still be returned to the requester, based on the RPPIOERR_HF 
 * register, even when the corresponding error is masked in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_mask : 1;
    /* cfg_ur_mask - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_ca_mask : 1;
    /* cfg_ca_mask - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_to_mask : 1;
    /* cfg_to_mask - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_mask : 1;
    /* io_ur_mask - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_ca_mask : 1;
    /* io_ca_mask - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_to_mask : 1;
    /* io_to_mask - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_mask : 1;
    /* mem_ur_mask - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_ca_mask : 1;
    /* mem_ca_mask - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_to_mask : 1;
    /* mem_to_mask - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_MASK_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG0_IIO_PCIEIOSF2_REG supported on:                           */
/*       BDX (0x400122AC)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG0_IIO_PCIEIOSF2_REG 0x150242AC

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 0 ([31:24]), 1 ([23:16]), 2 ([15:8]), and 3 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG1_IIO_PCIEIOSF2_REG supported on:                           */
/*       BDX (0x400122B0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG1_IIO_PCIEIOSF2_REG 0x150242B0

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 4 ([31:24]), 5 ([23:16]), 6 ([15:8]), and 7 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG2_IIO_PCIEIOSF2_REG supported on:                           */
/*       BDX (0x400122B4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG2_IIO_PCIEIOSF2_REG 0x150242B4

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 8 ([31:24]), 9 ([23:16]), 10 ([15:8]), and 11 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG2_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* RPPIOERR_HDRLOG3_IIO_PCIEIOSF2_REG supported on:                           */
/*       BDX (0x400122B8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG3_IIO_PCIEIOSF2_REG 0x150242B8

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 12 ([31:24]), 13 ([23:16]), 14 ([15:8]), and 15 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG3_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CAP_HDR_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012300)                                                     */
/* Register default value:              0x0001000B                            */
#define MCAST_CAP_HDR_IIO_PCIEIOSF2_REG 0x15024300

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Capability Header Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_HDR_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CAP_EXT_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012304)                                                     */
/* Register default value:              0x03800008                            */
#define MCAST_CAP_EXT_IIO_PCIEIOSF2_REG 0x15024304

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Extended Capability Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000001000 
       Vendor-specific capability ID. Intel defines 0x8 as the ID for dualcast.
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000111000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_EXT_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CAP_IIO_PCIEIOSF2_REG supported on:                                  */
/*       BDX (0x2001230C)                                                     */
/* Register default value:              0x000F                                */
#define MCAST_CAP_IIO_PCIEIOSF2_REG 0x1502230C

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Capability Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Capability Register (see section 7.21.2 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_max_group : 6;
    /* mc_max_group - Bits[5:0], RO, default = 6'b001111  */
    UINT16 rsvd_6 : 2;
    /* rsvd_6 - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_window_size_req : 6;
    /* mc_window_size_req - Bits[13:8], RO, default = 6'b000000  */
    UINT16 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_ecrc_regen_sup : 1;
    /* mc_ecrc_regen_sup - Bits[15:15], RO, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CAP_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_CTRL_IIO_PCIEIOSF2_REG supported on:                                 */
/*       BDX (0x2001230E)                                                     */
/* Register default value:              0x0000                                */
#define MCAST_CTRL_IIO_PCIEIOSF2_REG 0x1502230E

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Control Register (Dualcast is a version of PCIe Multicast supported on 
 * the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Control Register (see section 7.21.3 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_num_group : 6;
    /* mc_num_group - Bits[5:0], RW_L, default = 6'b000000 
       This field only supports and implements bits [3:0]. Bits [5:4] are not 
       supported. 
     */
    UINT16 rsvd : 9;
    /* rsvd - Bits[14:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 mc_enable : 1;
    /* mc_enable - Bits[15:15], RW_L, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CTRL_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_BASE_N0_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012310)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N0_IIO_PCIEIOSF2_REG 0x15024310

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Base Address Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_index_position : 6;
    /* mc_index_position - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 rsvd : 6;
    /* rsvd - Bits[11:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mc_base_address : 20;
    /* mc_base_address - Bits[31:12], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_BASE_N1_IIO_PCIEIOSF2_REG supported on:                              */
/*       BDX (0x40012314)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N1_IIO_PCIEIOSF2_REG 0x15024314

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Base Address Register (Dualcast is a version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_base_address : 32;
    /* mc_base_address - Bits[31:0], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_RCV_N0_IIO_PCIEIOSF2_REG supported on:                               */
/*       BDX (0x40012318)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_RCV_N0_IIO_PCIEIOSF2_REG 0x15024318

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Receive Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Receive Register (see section 7.21.5 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_rcv : 16;
    /* mc_rcv - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_RCV_N0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




/* MCAST_BLK_ALL_N0_IIO_PCIEIOSF2_REG supported on:                           */
/*       BDX (0x40012320)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_ALL_N0_IIO_PCIEIOSF2_REG 0x15024320

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Block All Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_All Register (see section 7.21.6 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_all : 16;
    /* mc_blk_all - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_ALL_N0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




/* MCAST_BLK_UNT_N0_IIO_PCIEIOSF2_REG supported on:                           */
/*       BDX (0x40012328)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_UNT_N0_IIO_PCIEIOSF2_REG 0x15024328

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Block Untranslated Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_Untranslated Register (see section 7.21.7 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_unt : 16;
    /* mc_blk_unt - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_UNT_N0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */




/* MCAST_OVERLAY_BAR_N0_IIO_PCIEIOSF2_REG supported on:                       */
/*       BDX (0x40012330)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N0_IIO_PCIEIOSF2_REG 0x15024330

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Overlay Bar Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_size : 6;
    /* mc_overlay_size - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 mc_overlay_addr : 26;
    /* mc_overlay_addr - Bits[31:6], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N0_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */


/* MCAST_OVERLAY_BAR_N1_IIO_PCIEIOSF2_REG supported on:                       */
/*       BDX (0x40012334)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N1_IIO_PCIEIOSF2_REG 0x15024334

#ifdef BDX_HOST
#ifndef ASM_INC
/* Struct format extracted from XML file BDX\0.2.2.IOSF.xml.
 * Dualcast Overlay Bar Register (Dualcast is a version of PCIe Multicast supported 
 * on the Haswell-EN processor and the EP/EP 4S processor used in conjunction with 
 * Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_addr : 32;
    /* mc_overlay_addr - Bits[31:0], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N1_IIO_PCIEIOSF2_STRUCT;
#endif /* ASM_INC */
#endif /*BDX_HOST */








#endif /* IIO_PCIEIOSF2_h */
